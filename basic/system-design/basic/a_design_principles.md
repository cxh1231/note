设计模式（Design Pattern）是一套被反复使用、多数人知晓、经过分类编目的优秀代码设计经验的总结。

Java设计模式贯彻的原理是：面向接口编程，而不是面向实现。

设计模式的目标原则是：降低耦合，增强灵活性。

## 1、单一职责原则

> Single Responsibility Principle，简称SRP

一个类，应当只有一个引起它变化的原因；即**一个类应该只有一个职责**。

> There should never be more than one reason for a class to change.

单一职责原则的优点有以下几个方面：

+ 降低类的复杂性；
+ 提高类的可读性；
+ 提高代码的可维护性和复用性；
+ 降低因变更引起的风险。

## 2、里氏替换原则

> Liskov Substitution Principle，简称LSP

**定义1**：

如果对一个类型为S的对象o1，都有类型为T的对象o2，使得以S定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T是类型S的子类型。

**定义2**：

所有引用基类的地方必须能透明地使用其子类对象。清晰明确地说明只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道父类还是子类；但是反过来则不可以，有子类的地方，父类未必就能适应。

一句话：**子类可以扩展父类的功能，但不能改变父类原有的功能**。

**里氏替换原则** 为良好的继承定义了一个规范，它包含4层含义：

+ 子类必须完全实现父类的方法；
+ 子类可以有自己的个性，增加自己独有的方法；
+ 覆盖或实现父类的方法时输入参数可以被放大；
+ 覆盖或实现父类的方法时输出结果可以被缩小。

## 3、依赖倒置原则

> Dependence Inversion Principle，简称DIP

依赖倒置原则的原始定义是：

> High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.

翻译过来，包括三层含义：

+ 高层模块不应该依赖低层模块，两者都依赖其抽象；
+ 抽象不依赖细节；
+ 细节应该依赖于抽象。

在Java语言中：

+ 抽象就是指接口或抽象类，两者都是不能直接被实例化的；
+ 细节就是具体的实现类，实现类实现了接口或继承了抽象类，其特点是可以直接被实例化。

**依赖倒置原则**在Java语言中的表现是：

+ 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生；
+ 接口或抽象类不依赖于实现类；
+ 实现类依赖于接口或抽象类。

依赖倒置原则的**本质**是：**通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，互不影响，实现模块间的松耦合**。

依赖倒置原则更加精确的定义就是“**面向接口编程**”——OOD（Object-Oriented Design）的精髓之一。

在**项目**中使用这个原则只要遵循以下几个规则：

+ 每个类尽量都具有接口或抽象类，或者抽象类和接口两者都具备。这是依赖倒置的基本要求，接口和抽象类都是抽象的，有了抽象才可能有依赖倒置；
+ 变量的表面类型尽量是接口或者是抽象类；
+ 任何类都不应该从具体类派生；
+ 尽量不要重写基类的方法。如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要重写。类之间依赖的是抽象，重写了非抽象方法，对依赖的稳定性会产生一定的影响；
+ 结合里氏替换原则使用。里氏替换原则指出父类出现的地方子类就可以出现，结合依赖倒置原则可以得出一个通俗的规则：**接口负责定义抽象方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确地实现业务逻辑，同时在适当的时候对父类进行细化**。

## 4、接口隔离原则

> Interface Segregation Principle，简称ISP。

首先明确 `接口` 的概念，**接口**分为两种：

+  **实例接口**（Object Interface），在Java中声明一个类，然后用new关键字产生一个实例，它是对一个类型的事物所具有的方法特征的描述，也称做一个“接口”，这仅是一种逻辑上的抽象。例如，定义一个`Person`类，使用`Person zhangsan = new Person()`产生一个实例，该实例遵从的标准是Person这个类，Person就是zhangsan的接口。
+ **类接口**（Class Interface）：是指在 Java 中使用 `interface` 严格定义的接口，例如，`java.lang.Runnable` 就是一个Java线程接口。

针对 **接口** 这两种不同的含义，接口隔离原则的表达方式以及含义都有所不同，接口隔离原则有如下两种定义：

+ 客户端不应该依赖它不需要的接口
+ 类间的依赖关系应该建立在最小的接口上

**接口隔离原则**的具体含义如下：

+ 一个类对另外一个类的依赖性应当是**建立在最小的接口**上的。
+ 一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。因此**使用多个专门的接口比使用单一的总接口要好**。
+ **不应该强迫客户依赖于它们不用的方法**。接口属于客户，不属于它所在的类层次结构，即不要强迫客户使用它们不用的方法，否则这些客户就会面临由于这些不使用的方法的改变所带来的改变。

即：**只提供调用者需要的方法，屏蔽不需要的方法**。

在**实践应用**中可以根据以下几个规则来衡量是否满足满足接口的原子性：

+ 一个接口只对一个子模块或者业务逻辑进行服务；
+ 只保留接口中业务逻辑需要的public方法；
+ 尽量修改污染了的接口，若修改的风险较大，则可采用适配器模式进行转化处理；
+ 接口设计应因项目而异，因环境而异，不能教条照搬。

## 5、迪米特法则

> Law of Demeter，简称LoD
>
> **迪米特法则** 又叫 **最少知识原则**（Least Knowledge Principle，LKP）

一个对象应当对其他对象尽可能少的了解。

+ 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用；
+ 如果一个类需要调用另一个类的某一个方法，可以通过第三者转发这个调用。

## 6、开闭原则

> Open-Closed Principle，简称OCP

**一个软件实体应当对扩展开放，对修改关闭**。

> 开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。

开闭原则描绘的愿景只是一种理想情况或是极端状态，现实世界中是很难被完全实现的，只能在某些组件，在某种程度上符合开闭原则的要求。

**开闭原则是面向对象设计的终极目标，其他设计原则都可以看做是开闭原则的实现方法**。



