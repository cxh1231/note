## 1、操作系统概述

### 1.1 操作系统的基本特征

操作系统具有并发、共享、虚拟、异步等特征。

#### 并发

|                 并发                 |                          并行                          |
| :----------------------------------: | :----------------------------------------------------: |
| 宏观上在一段时间内能同时运行多个程序 |              微观上同一时刻能运行多个指令              |
|    通过引入进程和线程可以实现并发    | 需要硬件支持，如多流水线、多核处理器或者分布式计算系统 |

#### 共享

`共享` 是指系统中的资源可以被多个并发进程共同使用。

有两种共享方式：`互斥共享` 和 `同时共享`。

`互斥共享` 的资源称为`临界资源`，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。

#### 虚拟

`虚拟` 技术把一个物理实体转换为多个逻辑实体。

主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。

`时分复用`：多个进程能在同一个处理器上并发执行，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

`空分复用`：虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

#### 异步

异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。

###

### 1.2 操作系统的基本功能

操作系统主要有以下几种基本功能：

|   功能   |                           具体功能                           |
| :------: | :----------------------------------------------------------: |
| 进程管理 |    进程控制、进程同步、进程通信、死锁处理、处理机调度等。    |
| 内存管理 |       内存分配、地址映射、内存保护与共享、虚拟内存等。       |
| 文件管理 |     文件存储空间的管理、目录管理、文件读写管理和保护等。     |
| 设备管理 | 完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。<br />主要包括缓冲管理、设备分配、设备处理、虛拟设备等。 |

### 1.3 系统调用

如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。



Linux 的系统调用主要有以下这些：

|   Task   |          Commands           |
| :------: | :-------------------------: |
| 进程控制 |   fork(); exit(); wait();   |
| 进程通信 |  pipe(); shmget(); mmap();  |
| 文件操作 |  open(); read(); write();   |
| 设备操作 |  ioctl(); read(); write();  |
| 信息维护 | getpid(); alarm(); sleep(); |
|   安全   | chmod(); umask(); chown();  |

### 1.4 宏内核与微内核

#### 宏内核

宏内核是将操作系统功能作为一个紧密结合的整体放到内核。

由于各模块共享信息，因此有很高的性能。

#### 微内核

由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。

在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。

因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。

![image-20220828203617684](https://img.zxdmy.com/2022/202208282036275.png)

### 1.5 系统中断

#### 外中断

由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。

#### 异常

由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。

#### 陷入

在用户程序中使用系统调用。

## 2、死锁

### 2.1 产生死锁的必要条件

- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
- 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

### 2.2 死锁的处理方法

主要有以下四种方法：

- 鸵鸟策略
- 死锁检测与死锁恢复
- 死锁预防
- 死锁避免

### 2.3 处理方式1：鸵鸟策略

因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

### 2.4 处理方式2：死锁检测与死锁恢复

不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

### 2.5 处理方式3：死锁预防

在程序运行之前预防发生死锁。

**破坏互斥条件**

例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。

**破坏占有和等待条件**

一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。

**破坏不可抢占条件**

**破坏环路等待**

给资源统一编号，进程只能按编号顺序来请求资源。

## 3、进程管理

### 3.1 进程与线程

#### 进程

**进程是资源分配的基本单位**。

`进程控制块` (Process Control Block, `PCB`) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 `PCB` 的操作。

下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。

![image-20220828204617227](https://img.zxdmy.com/2022/202208282046784.png)

#### 线程

**线程是独立调度的基本单位**。

一个进程中可以有多个线程，它们共享进程资源。

QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

#### 进程和线程的区别

|   区别   |                     进程                      |                线程                |
| :------: | :-------------------------------------------: | :--------------------------------: |
| 拥有资源 |              资源分配的基本单位               |       可以访问隶属进程的资源       |
|   调度   |                                               |         独立调度的基本单位         |
| 进程切换 | A 进程的线程切换至 B 进程的线程会引起进程切换 |     线程的切换不会引起进程切换     |
| 系统开销 |            分配与回收资源的开销大             |               开销小               |
|   通信   |      进程通信需要借助 IPC（进程间通信）       | 线程间可以直接读写同一进程中的数据 |

关于系统开销的详细描述：

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

### 3.2 进程状态与状态切换

一般情况下，把`进程`大致分为 5 种状态：

- **创建状态(`new`)** ：进程正在被创建，尚未到就绪状态。
- **就绪状态(`ready`)** ：进程已处于**准备**运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- **运行状态(`running`)** ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
- **阻塞状态(`waiting`)** ：又称为**等待**状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
- **结束状态(`terminated`)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

![image-20220828210313509](https://img.zxdmy.com/2022/202208282103982.png)

五种状态的**资源分配**情况：

|    状态    |                         拥有资源                         |
| :--------: | :------------------------------------------------------: |
|  创建状态  |            操作系统为新进程分配资源，创建 PCB            |
| `运行状态` | CPU :white_check_mark: 　其他所需资源 :white_check_mark: |
| `就绪状态` |        CPU :x: 　其他所需资源 :white_check_mark:         |
| `阻塞状态` |                CPU :x: 　其他所需资源 :x:                |
|  终止状态  |             操作系统回收进程的资源，撤销 PCB             |

五种进程状态间的转换情况：

|       状态       |                     简介                     |
| :--------------: | :------------------------------------------: |
|  创建 ——》 就绪  |          系统完成创建进程相关的工作          |
| `就绪 ——》 运行` |                  进程被调度                  |
| `运行 ——》 就绪` | 时间片到，或 CPU 被其他更高优先级的进程抢占  |
| `运行 ——》 阻塞` |  （主动）等待系统资源分配，或等待某事件发生  |
| `阻塞 ——》 就绪` |     （被动）资源分配到位，等待的事件发生     |
|  运行 ——》终止   | 进程运行结束，或运行过程中遇到不可修复的错误 |

### 3.3 进程调度算法

#### 批处理系统

批处理系统没有太多的用户操作，在该系统中，调度算法目标是`保证吞吐量和周转时间`（从提交到终止的时间）。

|       进程调度算法       |             简介             |     利弊     |
| :----------------------: | :--------------------------: | :----------: |
|    先来先服务（FCFS）    |   非抢占式，按请求顺序执行   | 有利于长作业 |
|    短作业优先（SJF）     | 非抢占式，按运行时间短的执行 | 有利于短作业 |
| 最短剩余时间优先（SRTN） |  抢占式，按剩余时间短的执行  |      ——      |

#### 交互式系统

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是`快速地进行响应`。

| 进程调度算法 |             简介             |                     利弊                      |
| :----------: | :--------------------------: | :-------------------------------------------: |
|  时间片轮转  | 每个进程一个时间片，轮流运行 |           时间片过长不能保证实时性            |
|  优先级调度  |  按每个进程的优先级进行调度  | 随时间 `增加等待进程的优先级`，以保证低优先级 |
| 多级反馈队列 | 时间片轮转和优先级调度的结合 |                                               |

#### 实时系统

实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

### 3.4 进程同步

在多道批处理系统中，多个进程可以并发执行，以不可预知的速度向前推进，即`异步`性。

一个进程的执行可能影响到另一个进程的执行，比如进程间的异步读写的顺序，可能导致进程阻塞。

`进程同步`就是指**协调完成某个共同任务的并发线程**，在某些位置上指定线程的先后执行次序、传递信号或消息。

| 进程同步方式 |                           简介                           |
| :----------: | :------------------------------------------------------: |
|    临界区    |                    进入临界区前先检查                    |
|  同步与互斥  | 同步：线程有先后执行关系；互斥：只有一个进程能进入临界区 |
|    信号量    |                      进行 P、V 操作                      |
|     管程     |                   控制的代码块独立出来                   |

### 3.5 进程通信

`进程同步` 与 `进程通信` 很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

`进程通信` 是一种手段，而 `进程同步` 是一种目的。

也可以说，为了能够达到 `进程同步` 的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

主要有以下六种进程通信方式：

| 通信方式 |                             简介                             |
| :------: | :----------------------------------------------------------: |
|   管道   | 通过调用 `pipe` 函数创建，`fd[0]` 用于读，`fd[1]` 用于写；半双工通信；父子进程使用 |
|   FIFO   | 又称为 `命名管道`，解除 管道只能在父子进程中使用的限制；常用于客户进程和服务器进程 |
| 消息队列 |   独立于读写进程存在；避免同步阻塞；读进程有选择性接收消息   |
|  信号量  |       `计数器`，用于为多个进程提供对共享数据对象的访问       |
| 共享存储 | 允许多个进程共享一个给定的存储区；速度最快；使用信号量同步共享存储的访问 |
|  套接字  |                   用于不同机器间的进程通信                   |

## 4、内存管理

### 页面置换算法

|        算法        | 简介 |
| :----------------: | :--: |
| 最近最久未使用 LRU |      |
|     最近未使用     |      |
|      先进先出      |      |
|        时钟        |      |

## 5、文件管理



## 6、设备管理









### 死锁是什么？发生的条件？如何尽可能避免。





### 消费者生产者模型



## 线程在操作系统怎么唤醒的