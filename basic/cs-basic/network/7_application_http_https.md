## 1、HTTP 简介

`HTTP` 协议，全称`超文本传输协议`（Hypertext Transfer Protocol），用于 `Web 浏览器与 Web 服务器之间的通信`。

超文本，也就是网络上的包括文本在内的各式各样的消，具体来说，主要是来规范浏览器和服务器端的行为的。

`HTTP` 协议基于 `TCP` 协议，发送 `HTTP` 请求之前要建立 `TCP` 连接，即进行 `3 次握手`。

`HTTP` 是一个`无状态`（`stateless`）协议，也就是说 **服务器不维护任何有关客户端过去所发请求的消息**。

这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高

`HTTP` 协议的 扩展性强、速度快、跨平台支持性好。

## 2、HTTP 协议通信过程

`HTTP` 是应用层协议，它以 `TCP`（传输层）作为底层协议，默认端口为 80。

通信过程主要如下：

1. 服务器在 80 端口等待客户的请求。
2. 浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。
3. 服务器接收来自浏览器的 TCP 连接。
4. 浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。
5. 关闭 TCP 连接。

## 3、HTTP 1.0/1.1/2.0 的异同

|            |                      HTTP/1.0                      |                           HTTP/1.1                           |                           HTTP/2.0                           |
| :--------: | :------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 响应状态码 |                        16种                        |                    更多，错误代码就有24种                    |                                                              |
|  连接方式  |                      `短链接`                      |                           `长链接`                           |                                                              |
|  缓存处理  | header 里的 If-Modified-Since,Expires 做为缓存判断 | 引入 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略 |                                                              |
|  带宽优化  |       整个对象传送，存在浪费，不支持断点续传       |       请求头引入 range 字段，允许只请求资源的某个部分        |                                                              |
|  Host 头   |                         ——                         |                    请求头加入 `Host` 字段                    |                                                              |
|  网络传输  |                      字符协议                      |                           字符协议                           |                      二进制协议（传输）                      |
|  多路复用  |                                                    |                                                              | 加入多路复用，同个链接下可以同时进行多个请求，每个请求使用ID区分，减少链接次数 |
|    头部    |                                                    |                                                              |                          压缩了头部                          |

## 4、HTTPS 简介

`HTTPS` 协议（Hyper Text Transfer Protocol Secure），是 `HTTP` 的加强安全版本。

`HTTPS` 是基于 `HTTP` 的，也是用 `TCP` 作为底层协议，并额外使用 `SSL/TLS` 协议用作加密和安全认证。

默认端口号是 `443`。

`HTTPS` 协议中，`SSL` 通道通常使用基于密钥的加密算法，`密钥`长度通常是 40 比特或 128 比特

HTTPS 的优点是 保密性好、信任度高。

## 5、HTTPS 的 SSL/TLS 协议

`HTTPS` 之所以能达到较高的安全性要求，就是结合了 `SSL/TLS` 和 `TCP` 协议，对通信数据进行加密，解决了 `HTTP` 数据透明的问题。

`SSL` 指`安全套接字协议`（`Secure Sockets Layer`），首次发布与 1996 年。

SSL 的首次发布的是 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。

在 1999 年，SSL 3.0 进一步升级，**新版本被命名为 TLS 1.0**。

`TLS` 是基于 `SSL` 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混称为 `SSL/TLS`

## 6、HTTPS 的加密工作原理

> https://zhuanlan.zhihu.com/p/43789231

因为 `HTTP` 的内容是明文传输的，明文数据会经过中间代理服务器、路由器、wifi热点、通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了。劫持者还可以篡改传输的信息且不被双方察觉，这就是`中间人攻击`。

所以我们才需要对信息进行**加密**。

#### 对称加密

> 为了保证信息的保密性，通常采用 **对称加密** 技术。

**对称加密**：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。

即使用一个秘钥，即可以对信息进行加密，也可以对加密后的信息进行解密。

`SSL/TLS` 实际 **使用对称加密，对消息进行加密**。

**对称加密的保密性完全依赖于密钥的保密性**，即通信双方的秘钥没有被破解、泄露，通信是安全的。

而对称加密存在的最大问题是：**秘钥如何仅让通信双方知晓，而不被其他第三方知晓**？服务器生成秘钥传输给浏览器时，秘钥传输过程中可能被劫持。

#### 非对称加密

> 为了解决秘钥的传输问题，需要使用 **非对称加密**。

**非对称加密**：简单说就是有两个秘钥：公钥和私钥，使用公钥加密的内容，必须使用私钥才能解开，同样使用私钥加密的内容，只有公钥才能解开。

**非对称加密**的公钥和私钥需要采用一种复杂的数学机制生成，公私钥对的生成算法依赖于**单向陷门函数**。

`SSL/TLS` 的核心要素是 **非对称加密**。

在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。

一对非对称加密公钥，不能保证数据传输的安全性：

+ 浏览器→服务器：这个过程，浏览器向服务器传输数据之前，先使用公钥加密，服务器再采用私钥解密，这条数据的安全性是可以保障的；
+ 服务器→浏览器：这个过程，浏览器只有公钥，如果服务器使用私钥加密，那任何获取到公钥的中间人，都可以对服务器发出的消息进行解密，这条消息的安全性无法保障。

一组公钥私钥只能保证单个方向传输的相对安全性，采用两对就能保证双向传输吗？

也不能。其存在最主要的两个问题是：

+ **非对称加密算法耗时**；
+ 可能存在`中间人攻击`问题。

#### 非对称加密+对称加密

> 为了解决 `非对称加密` 耗时的问题，通常采用 `非对称加密+对称加密` 结合的方式，尽量减少非对称加密的次数，且非对称加密、解密各只需用一次即可。

具体流程如下：

1. 某网站拥有用于非对称加密的公钥A、私钥A’。
2. 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
3. 浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。
4. 服务器拿到后用私钥A’解密得到密钥X。
5. 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。

但这个过程，仍有不足：`中间人攻击`。

#### 中间人攻击

所谓中间人攻击，指的是对通信双方的数据进行了篡改。比如：

1. 某网站有用于非对称加密的公钥A、私钥A’。
2. 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
3. **中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）**。
4. 浏览器生成一个用于对称加密的密钥X，用**公钥B**（浏览器无法得知公钥被替换了）加密后传给服务器。
5. **中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器**。
6. 服务器拿到后用私钥A’解密得到密钥X。

**根本原因是浏览器无法确认收到的公钥是不是网站自己的，**因为公钥本身是明文传输的。

#### 数字证书

> 为了 **证明浏览器收到的公钥是网站自己的**，通常采用 **数字证书** 的方式。

网站在使用HTTPS前，需要向**CA机构**申领一份**数字证书**，数字证书里含有证书持有者信息、公钥信息等。

服务器把证书传输给浏览器，浏览器**从证书里获取公钥**就行了，证书就如身份证，证明“该公钥对应该网站”。

“**证书本身的传输过程中，如何防止被篡改”**？即如何证明证书本身的真实性？身份证运用了一些防伪技术，而数字证书怎么防伪呢？解决这个问题我们就接近胜利了！

#### 数字签名

> 为了 **防止数字证书被篡改**，通常采用 **数字签名** 的防伪技术。

所谓数字签名，是将证书的内容，生成一份“签名”，通过对比证书内容和签名是否一致，就可以判断是否被篡改。

![image-20220901105316137](https://img.zxdmy.com/2022/202209011053486.png)

**数字签名** 的制作过程：

1. `CA机构` 拥有自身 `非对称加密` 的 `私钥` 和 `公钥`；
2. `CA机构` 首先对 `证书明文T` 进行 `hash`，得到 hash值 `H`；
3. 对 `hash` 后的值 `H`，使用 `私钥` 进行加密，得到 `数字签名S`。

> 上面的第二步，**为什么要对 证书明文 进行 hash**？
> 因为证书信息较长，hash 之后长度固定，非对称加密时速度会更快。

`证书明文T` 和 `数字签名S` 共同组成了 `数字证书`，这个数字证书就可以颁发给网站。

那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的（有没有被篡改、掉包）？

**浏览器验证** 过程：

1. 浏览器拿到 `证书` 后，即可得到该网站的 `明文T` 和 `签名S`。
2. 用 `CA机构` 的 `公钥` 对 `签名S` 进行解密，得到 `S2`（一般 CA机构 是被浏览器信任的，所以浏览器保存该机构的公钥）。
3. 用 `证书` 指明的 hash算法，对 `明文T` 进行同样的 hash 操作，得到hash值`H2`；
4. 如果解密出来的hash值 `S2` ，和 hash 操作后的 hash值 `H2` 相同，说明证书是可信的。

上面的几个问题，都可以得到解决：

**中间人不可能把证书篡改**！

中间人没有 `CA机构` 的`私钥`，如果中间人把`证书明文篡改`了，通过hash后的值，无法生成正确的签名。浏览器通过比较签名解密后的hash值，和明文的hash值不同，可以验证被篡改。

**中间人不可能把证书掉包**！

证书里包含了网站的信息，比如域名等，浏览器会通过这些信息进行对比，以验证证书是不是该网站的。

#### CA机构

前文提到，“浏览器保有它的公钥”，这是个什么保有法？怎么证明这个公钥是否可信？

让我们回想一下数字证书到底是干啥的？没错，为了证明某公钥是可信的，即“该公钥是否对应该网站”，那CA机构的公钥是否也可以用数字证书来证明？没错，操作系统、浏览器本身会预装一些它们信任的根证书，如果其中会有CA机构的根证书，这样就可以拿到它对应的可信公钥了。

实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做`信任链`或`数字证书链`。也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。

另外，不知你们是否遇到过网站访问不了、提示需安装证书的情况？这里安装的就是根证书。说明浏览器不认给这个网站颁发证书的机构，那么你就得手动下载安装该机构的根证书（风险自己承担XD）。安装后，你就有了它的公钥，就可以用它验证服务器发来的证书是否可信了。

![image-20220901111318022](https://img.zxdmy.com/2022/202209011113990.png)

**每次进行HTTPS请求时都必须在SSL/TLS层进行握手传输密钥吗？**

服务器会为每个浏览器（或客户端软件）维护一个session ID，在TLS握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！

## 7、HTTPS与 DNS 劫持

由于域名劫持往往只能在特定的被劫持的网络范围内进行，所以在此范围外的域名服务器(DNS)能够返回正常的IP地址，高级用户可以在网络设置把DNS指向这些正常的域名服务器以实现对网址的正常访问。所以域名劫持通常相伴的措施——封锁正常DNS的IP