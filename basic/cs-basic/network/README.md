## 1、网络概述

### 网络体系结构

计算机网络中常见的体系结构主要有以下三种：

|     结构名称      | 层数 |                      简介                       |
| :---------------: | :--: | :---------------------------------------------: |
|  `OSI` 体系结构   | 七层 |           理想化结构，效率低，未采用            |
|   原理体系结构    | 五层 | 结合了`OSI`和 `TCP/IP` 结构的优点，理论学习结构 |
| `TCP/IP` 体系结构 | 四层 |                 真实采用的结构                  |

![image-20220829160605330](https://img.zxdmy.com/2022/202209011126451.png)

### 七层结构用途

- **应用层** ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。
- *表示层* ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。
- *会话层* ：建立及管理会话
- **传输层** ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。
- **网络层** ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。
- **数据链路层** ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。
- **物理层** ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

|      各层      |            设备            |               协议                |     数据单元      |
| :------------: | :------------------------: | :-------------------------------: | :---------------: |
|   **应用层**   |          应用程序          |    DHCP、FTP、HTTP、SMTP、RPC     |                   |
|     表示层     |             ——             |                ——                 |        ——         |
|     会话层     |             ——             |                ——                 |        ——         |
|   **传输层**   |         进程和端口         |             TCP、UDP              | 数据段（Segment） |
|   **网络层**   | 路由器，防火墙、多层交换机 | `IP`、`ARP`、RARP、`ICMP`、ICMPv6 | 数据包（Packet）  |
| **数据链路层** |     网卡，网桥，交换机     |           CSMA/CD、ARQ            |    帧（Frame）    |
|   **物理层**   | 中继器，集线器、网线、HUB  |                ——                 |    比特（Bit）    |

### TCP/IP

![image-20220829161927784](https://img.zxdmy.com/2022/202208291619526.png)

它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。

TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

### 数据传输

在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。

路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。

## 2、物理层

根据信息在传输线上的传送方向，分为以下三种通信方式：

- 单工通信：单向传输
- 半双工通信：双向交替传输
- 全双工通信：双向同时传输

## 3、 链路层

| 信道复用技术 |                             简介                             |
| :----------: | :----------------------------------------------------------: |
|   频分复用   |          所有主机在相同的时间占用不同的频率带宽资源          |
|   时分复用   |          所有主机在不同的时间占用相同的频率带宽资源          |
| 统计时分复用 |          有数据就集中起来组成统计时分复用帧然后发送          |
|   波分复用   | 光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波 |
|   码分复用   |                                                              |

协议：

|          协议           |                             简介                             |
| :---------------------: | :----------------------------------------------------------: |
| CSMA/CD（停止等待协议） |         实现载波的多点接入、载波监听、碰撞检测等机制         |
|    PPP（点对点协议）    | 实现 IP 数据报封装至串行链路，和建立、配置、测试数据链路链接 |
| ARQ（自动重传请求协议） |   实现错误侦测、正面确认、逾时重传与负面确认继以重传等机制   |

## 4、网络层

网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。

使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。

与 IP 协议配套使用的还有三个协议：

- 地址解析协议 `ARP`（Address Resolution Protocol）
- 网际控制报文协议 `ICMP`（Internet Control Message Protocol）
- 网际组管理协议 `IGMP`（Internet Group Management Protocol）

### 4.1 IP

#### IP 数据报格式

![image-20220829170802897](https://img.zxdmy.com/2022/202208291708879.png)

#### IP 地址分类

由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。

![image-20220829170900190](https://img.zxdmy.com/2022/202208291709540.png)

### 4.2 地址解析协议 ARP

在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。

ARP 实现由 IP 地址得到 MAC 地址。

![image-20220829171024186](https://img.zxdmy.com/2022/202208291710236.png)

### 4.3 网际控制报文协议 ICMP

ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。

![image-20220829171054209](https://img.zxdmy.com/2022/202209021158403.png)

`ICMP` 的两个重要应用是 `Ping` 和 `Traceroute` ：

+ `Ping` 主要用来测试两台主机之间的连通性。
+ `Traceroute` 用来跟踪一个分组从源点到终点的路径。

## 5、传输层

`网络层` 只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。

`传输层` 提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

### 5.1 TCP 与 UDP 的异同

|   异同   |                      传输控制协议 `TCP`                      |                   用户数据报协议 `UDP`                    |
| :------: | :----------------------------------------------------------: | :-------------------------------------------------------: |
|          |                Transmission Control Protocol                 |                  User Datagram Protocol                   |
|   连接   |                           面向连接                           |                          无连接                           |
|   可靠   |                 提供可靠交付（超时重传实现）                 |                      尽最大可能交付                       |
| 拥塞控制 |                     有流量控制、拥塞控制                     |                       没有拥塞控制                        |
|          |                        提供全双工通信                        |                                                           |
| 传输形式 |                            字节流                            |                        数据报文段                         |
| 传输效率 |                              慢                              |                            快                             |
| 所需资源 |                              多                              |                            少                             |
| 首部字节 |                            20-60                             |                    8（由四个字段组成）                    |
|          | 把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块 | 对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部 |
| 交互通信 |                       点对点（一对一）                       |              一对一、一对多、多对一、多对多               |
| 应用场景 |             要求通信数据可靠（如文件、邮件传输）             |               要求通信速度高（如域名转换）                |

### 5.2 TCP 与 UDP 的头部

TCP 头部：

![image-20220829172017983](https://img.zxdmy.com/2022/202208291720084.png)

UDP 头部：

![image-20220829172025382](https://img.zxdmy.com/2022/202208291720577.png)

### 5.3 TCP 的三次握手

如下图：

![image-20220829172106146](https://img.zxdmy.com/2022/202208291721610.png)

假设 A 为客户端，B 为服务器端。

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
- A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
- A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
- B 收到 A 的确认后，连接建立。

**三次握手的原因**：

第三次握手是为了`防止失效的连接请求到达服务器，让服务器错误打开连接`。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

### 5.4 TCP 的四次挥手

如下图：

![image-20220829172242352](https://img.zxdmy.com/2022/202208291722584.png)

以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。

- A 发送连接释放报文，FIN=1。
- B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
- 当 B 不再需要连接时，发送连接释放报文，FIN=1。
- A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
- B 收到 A 的确认后释放连接。

**四次挥手的原因**

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

**TIME_WAIT**

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

### 5.5 TCP 可靠传输

TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：

![img](https://img.zxdmy.com/2022/202208291730191.gif)


其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。

超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：

![img](https://img.zxdmy.com/2022/202208291730346.gif)


其中 RTTd 为偏差的加权平均值。

### 5.6 TCP 滑动窗口

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

![img](https://img.zxdmy.com/2022/202208291729486.jpeg)

### 5.7 TCP 流量控制

流量控制是为了控制发送方发送速率，保证接收方来得及接收。

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

### 5.8 TCP 拥塞控制

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

![img](https://img.zxdmy.com/2022/202208291729913.jpeg)



TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。

发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。

为了便于讨论，做如下假设：

- 接收方有足够大的接收缓存，因此不会发生流量控制；
- 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。

![img](https://img.zxdmy.com/2022/202208291729318.png)

1. 慢开始与拥塞避免

发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

2. 快重传与快恢复

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

## 6、应用层

|        应用        | 应用层协议 | 端口号  | 传输层协议 |            备注             |
| :----------------: | :--------: | :-----: | :--------: | :-------------------------: |
|      域名解析      |    DNS     |   53    |  UDP/TCP   | 长度超过 512 字节时使用 TCP |
|  动态主机配置协议  |    DHCP    |  67/68  |    UDP     |                             |
|  简单网络管理协议  |    SNMP    | 161/162 |    UDP     |                             |
|    文件传送协议    |   `FTP`    |  20/21  |    TCP     |  控制连接 21，数据连接 20   |
|   超文本传送协议   |   `HTTP`   |   80    |    TCP     |                             |
|  简单邮件传送协议  |   `SMTP`   |   25    |    TCP     |                             |
|    邮件读取协议    |   `POP3`   |   110   |    TCP     |                             |
|  网际报文存取协议  |   `IMAP`   |   143   |    TCP     |                             |
|    远程终端协议    |  `TELNET`  |   23    |    TCP     |                             |
| 安全的网络传输协议 |   `SSH`    |   22    |    TCP     |                             |

### 6.1 HTTP 超文本传输协议

见后文。

### 6.2 SMTP 简单邮件传输协议

**简单邮件传输(发送)协议（`SMTP`，Simple Mail Transfer Protocol）** 基于 `TCP` 协议，用来`发送`电子邮件。

SMTP 协议主要涉及两个问题：

#### 电子邮件的发送过程

比如通过 `abc@163.com` 向 `xyz@qq.com` 发送邮件：

1. 通过 `SMTP` 协议，将邮件提交给 `163` 邮箱服务器（邮局）
2. `163` 邮箱服务器发现该邮件的收件箱是`qq`邮箱，则使用 `SMTP` 协议将邮件转发到 `qq` 邮箱服务器。
3. `qq`邮箱服务器接收邮件之后，通知邮箱为 `xyz@qq.com` 的用户收邮件，用户通过 `POP3/IMAP` 协议将邮件取出。

#### 邮箱存在与否的判断

1. 查找邮箱域名对应的 SMTP 服务器地址
2. 尝试与服务器建立连接
3. 连接成功后尝试向需要验证的邮箱发送邮件
4. 根据返回结果判定邮箱地址的真实性

### 6.3 POP3/IMAP 邮件接收协议

**POP3 和 IMAP 两者都是负责邮件接收的协议**。

### 6.4 FTP 文件传输协议

**FTP 协议** 主要提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。

## 7、应用层之 HTTP & HTTPS

### 7.1 HTTP 简介

`HTTP` 协议，全称`超文本传输协议`（Hypertext Transfer Protocol），用于 `Web 浏览器与 Web 服务器之间的通信`。

超文本，也就是网络上的包括文本在内的各式各样的消，具体来说，主要是来规范浏览器和服务器端的行为的。

`HTTP` 协议基于 `TCP` 协议，发送 `HTTP` 请求之前要建立 `TCP` 连接，即进行 `3 次握手`。

`HTTP` 是一个`无状态`（`stateless`）协议，也就是说 **服务器不维护任何有关客户端过去所发请求的消息**。

这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高

`HTTP` 协议的 扩展性强、速度快、跨平台支持性好。

### 7.2 HTTP 协议通信过程

`HTTP` 是应用层协议，它以 `TCP`（传输层）作为底层协议，默认端口为 80。

通信过程主要如下：

1. 服务器在 80 端口等待客户的请求。
2. 浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。
3. 服务器接收来自浏览器的 TCP 连接。
4. 浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。
5. 关闭 TCP 连接。

### 7.3 HTTP 1.0/1.1/2.0 的异同

|            |                      HTTP/1.0                      |                           HTTP/1.1                           |                           HTTP/2.0                           |
| :--------: | :------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 响应状态码 |                        16种                        |                    更多，错误代码就有24种                    |                                                              |
|  连接方式  |                      `短链接`                      |                           `长链接`                           |                                                              |
|  缓存处理  | header 里的 If-Modified-Since,Expires 做为缓存判断 | 引入 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略 |                                                              |
|  带宽优化  |       整个对象传送，存在浪费，不支持断点续传       |       请求头引入 range 字段，允许只请求资源的某个部分        |                                                              |
|  Host 头   |                         ——                         |                    请求头加入 `Host` 字段                    |                                                              |
|  网络传输  |                      字符协议                      |                           字符协议                           |                      二进制协议（传输）                      |
|  多路复用  |                                                    |                                                              | 加入多路复用，同个链接下可以同时进行多个请求，每个请求使用ID区分，减少链接次数 |
|    头部    |                                                    |                                                              |                          压缩了头部                          |



### 7.4 HTTPS 简介

`HTTPS` 协议（Hyper Text Transfer Protocol Secure），是 `HTTP` 的加强安全版本。

`HTTPS` 是基于 `HTTP` 的，也是用 `TCP` 作为底层协议，并额外使用 `SSL/TLS` 协议用作加密和安全认证。

默认端口号是 `443`。

`HTTPS` 协议中，`SSL` 通道通常使用基于密钥的加密算法，`密钥`长度通常是 40 比特或 128 比特

HTTPS 的优点是 保密性好、信任度高。

### 7.5 HTTPS 的 SSL/TLS 协议

`HTTPS` 之所以能达到较高的安全性要求，就是结合了 `SSL/TLS` 和 `TCP` 协议，对通信数据进行加密，解决了 `HTTP` 数据透明的问题。

`SSL` 指`安全套接字协议`（`Secure Sockets Layer`），首次发布与 1996 年。

SSL 的首次发布的是 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。

在 1999 年，SSL 3.0 进一步升级，**新版本被命名为 TLS 1.0**。

`TLS` 是基于 `SSL` 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混称为 `SSL/TLS`

### 7.6 HTTPS 的加密工作原理

> https://zhuanlan.zhihu.com/p/43789231

因为 `HTTP` 的内容是明文传输的，明文数据会经过中间代理服务器、路由器、wifi热点、通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了。劫持者还可以篡改传输的信息且不被双方察觉，这就是`中间人攻击`。

所以我们才需要对信息进行**加密**。

#### 对称加密

> 为了保证信息的保密性，通常采用 **对称加密** 技术。

**对称加密**：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。

即使用一个秘钥，即可以对信息进行加密，也可以对加密后的信息进行解密。

`SSL/TLS` 实际 **使用对称加密，对消息进行加密**。

**对称加密的保密性完全依赖于密钥的保密性**，即通信双方的秘钥没有被破解、泄露，通信是安全的。

而对称加密存在的最大问题是：**秘钥如何仅让通信双方知晓，而不被其他第三方知晓**？服务器生成秘钥传输给浏览器时，秘钥传输过程中可能被劫持。

#### 非对称加密

> 为了解决秘钥的传输问题，需要使用 **非对称加密**。

**非对称加密**：简单说就是有两个秘钥：公钥和私钥，使用公钥加密的内容，必须使用私钥才能解开，同样使用私钥加密的内容，只有公钥才能解开。

**非对称加密**的公钥和私钥需要采用一种复杂的数学机制生成，公私钥对的生成算法依赖于**单向陷门函数**。

`SSL/TLS` 的核心要素是 **非对称加密**。

在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。

一对非对称加密公钥，不能保证数据传输的安全性：

+ 浏览器→服务器：这个过程，浏览器向服务器传输数据之前，先使用公钥加密，服务器再采用私钥解密，这条数据的安全性是可以保障的；
+ 服务器→浏览器：这个过程，浏览器只有公钥，如果服务器使用私钥加密，那任何获取到公钥的中间人，都可以对服务器发出的消息进行解密，这条消息的安全性无法保障。

一组公钥私钥只能保证单个方向传输的相对安全性，采用两对就能保证双向传输吗？

也不能。其存在最主要的两个问题是：

+ **非对称加密算法耗时**；
+ 可能存在`中间人攻击`问题。

#### 非对称加密+对称加密

> 为了解决 `非对称加密` 耗时的问题，通常采用 `非对称加密+对称加密` 结合的方式，尽量减少非对称加密的次数，且非对称加密、解密各只需用一次即可。

具体流程如下：

1. 某网站拥有用于非对称加密的公钥A、私钥A’。
2. 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
3. 浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。
4. 服务器拿到后用私钥A’解密得到密钥X。
5. 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。

但这个过程，仍有不足：`中间人攻击`。

#### 中间人攻击

所谓中间人攻击，指的是对通信双方的数据进行了篡改。比如：

1. 某网站有用于非对称加密的公钥A、私钥A’。
2. 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
3. **中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）**。
4. 浏览器生成一个用于对称加密的密钥X，用**公钥B**（浏览器无法得知公钥被替换了）加密后传给服务器。
5. **中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器**。
6. 服务器拿到后用私钥A’解密得到密钥X。

**根本原因是浏览器无法确认收到的公钥是不是网站自己的，**因为公钥本身是明文传输的。

#### 数字证书

> 为了 **证明浏览器收到的公钥是网站自己的**，通常采用 **数字证书** 的方式。

网站在使用HTTPS前，需要向**CA机构**申领一份**数字证书**，数字证书里含有证书持有者信息、公钥信息等。

服务器把证书传输给浏览器，浏览器**从证书里获取公钥**就行了，证书就如身份证，证明“该公钥对应该网站”。

“**证书本身的传输过程中，如何防止被篡改”**？即如何证明证书本身的真实性？身份证运用了一些防伪技术，而数字证书怎么防伪呢？解决这个问题我们就接近胜利了！

#### 数字签名

> 为了 **防止数字证书被篡改**，通常采用 **数字签名** 的防伪技术。

所谓数字签名，是将证书的内容，生成一份“签名”，通过对比证书内容和签名是否一致，就可以判断是否被篡改。

![image-20220901105316137](https://img.zxdmy.com/2022/202209011053486.png)

**数字签名** 的制作过程：

1. `CA机构` 拥有自身 `非对称加密` 的 `私钥` 和 `公钥`；
2. `CA机构` 首先对 `证书明文T` 进行 `hash`，得到 hash值 `H`；
3. 对 `hash` 后的值 `H`，使用 `私钥` 进行加密，得到 `数字签名S`。

> 上面的第二步，**为什么要对 证书明文 进行 hash**？
> 因为证书信息较长，hash 之后长度固定，非对称加密时速度会更快。

`证书明文T` 和 `数字签名S` 共同组成了 `数字证书`，这个数字证书就可以颁发给网站。

那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的（有没有被篡改、掉包）？

**浏览器验证** 过程：

1. 浏览器拿到 `证书` 后，即可得到该网站的 `明文T` 和 `签名S`。
2. 用 `CA机构` 的 `公钥` 对 `签名S` 进行解密，得到 `S2`（一般 CA机构 是被浏览器信任的，所以浏览器保存该机构的公钥）。
3. 用 `证书` 指明的 hash算法，对 `明文T` 进行同样的 hash 操作，得到hash值`H2`；
4. 如果解密出来的hash值 `S2` ，和 hash 操作后的 hash值 `H2` 相同，说明证书是可信的。

上面的几个问题，都可以得到解决：

**中间人不可能把证书篡改**！

中间人没有 `CA机构` 的`私钥`，如果中间人把`证书明文篡改`了，通过hash后的值，无法生成正确的签名。浏览器通过比较签名解密后的hash值，和明文的hash值不同，可以验证被篡改。

**中间人不可能把证书掉包**！

证书里包含了网站的信息，比如域名等，浏览器会通过这些信息进行对比，以验证证书是不是该网站的。

#### CA机构

前文提到，“浏览器保有它的公钥”，这是个什么保有法？怎么证明这个公钥是否可信？

让我们回想一下数字证书到底是干啥的？没错，为了证明某公钥是可信的，即“该公钥是否对应该网站”，那CA机构的公钥是否也可以用数字证书来证明？没错，操作系统、浏览器本身会预装一些它们信任的根证书，如果其中会有CA机构的根证书，这样就可以拿到它对应的可信公钥了。

实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做`信任链`或`数字证书链`。也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。

另外，不知你们是否遇到过网站访问不了、提示需安装证书的情况？这里安装的就是根证书。说明浏览器不认给这个网站颁发证书的机构，那么你就得手动下载安装该机构的根证书（风险自己承担XD）。安装后，你就有了它的公钥，就可以用它验证服务器发来的证书是否可信了。

![image-20220901111318022](https://img.zxdmy.com/2022/202209011113990.png)

**每次进行HTTPS请求时都必须在SSL/TLS层进行握手传输密钥吗？**

服务器会为每个浏览器（或客户端软件）维护一个session ID，在TLS握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！

### HTTPS与 DNS 劫持

由于域名劫持往往只能在特定的被劫持的网络范围内进行，所以在此范围外的域名服务器(DNS)能够返回正常的IP地址，高级用户可以在网络设置把DNS指向这些正常的域名服务器以实现对网址的正常访问。所以域名劫持通常相伴的措施——封锁正常DNS的IP

## 更多面试题

### 浏览器中输入URL到显示网页的过程

比如：打开一个网页，整个过程会使用哪些协议？

![image-20220830213242670](https://img.zxdmy.com/2022/202208302132525.png)

总体来说分为以下几个过程:

1. DNS 解析
2. TCP 连接
3. 发送 HTTP 请求
4. 服务器处理请求并返回 HTTP 报文
5. 浏览器解析渲染页面
6. 连接结束

### 状态码

![状态码](https://img.zxdmy.com/2022/202208302133165.png)

### URL 与 URI 的区别

- `URI`(Uniform Resource Identifier) 是`统一资源标志符`，可以唯一标识一个资源。
- `URL`(Uniform Resource Locator) 是`统一资源定位符`，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。

### POST 和 PUT 的区别

|        |  POST  |    PUT     |
| :----: | :----: | :--------: |
|  表示  |  创建  | 创建或更新 |
| 幂等性 | 不幂等 |    幂等    |

> 幂等性：指多次操作的结果，都是一致的，不会因为多次点击而产生副作用。



网络拥塞了解吗