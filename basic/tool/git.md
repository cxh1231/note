# Git常用命令及其原理

## 1、Git概述

Git 是一个开源的 **分布式版本控制系统**，其分布式特性主要体现在，对于每次克隆操作，都对代码仓库进行完整备份，即每个开发者本地都保存了整个项目开发迭代的完整备份，有效避免集中式架构下中心服务器故障可能带来的数据丢失。

Git主要分为工作区、暂存区和版本库，具体如下：

+ 工作区：即工作目录下直接进行增删改等操作的文件目录；
+ 暂存区：一般存放在 `.git` 目录下的 `index` 文件中，有时也叫作索引，用于存放临时改动，保存即将提交的文件列表信息；
+ 版本库： 工作区有一个隐藏目录 `.git`，这个不算工作区，而是 Git 的版本库，这里保存了我们提交的所有版本的数据。

下图描述了Git工作区、暂存区和版本库之间的关系：

![image-20231009224649593](https://img.zxdmy.com/2022/202310092246081.png)

## 2、常用命令及其实现原理

### 2.1 对象操作命令

存储在Git仓库中的内容通常称为Git对象，其有四种类型：

+ 数据对象（blob）
+ 树对象（tree）
+ 提交对象（commit）
+ 标签对象（tag）

#### git add 命令与数据对象

数据对象是在使用 `git add` 命令，将文件或目录添加至暂存区时产生的，这个过程中，Git 会把文件中要存在的数据，和一个头部信息一起进行`SHA-1散列运算`，将得到的散列值作为文件的路径。

比如将含有内容为 `hello world!` 的 `hello.txt` 文件，添加至暂存区时，得到`SHA-1散列值bc7774a7b18deb1d7bd0212d34246a9b1260ae17` ，前2个字符用于命名**子目录**，其余38字符用于**命名文件**，生成的`数据对象`如下图所示：

![image-20231015221051320](https://img.zxdmy.com/2022/202310152211953.png)

> 实际使用前6个字符即可区分不同的数据对象，后文将默认用前 6 个字符表示各对象。

这个散列值路径文件中保存的只是源文件的一种压缩形式。

除了单个文件，将一系列文件（比如`git add <fileName>`、`git add .` 命令）添加至暂存区，每个文件都将生成一个数据对象。

比如将 `test` 目录下的 `hello.txt` 文件和 `world.txt` 文件，同时添加至暂存区时，将生成2个数据对象，如下图所示。

![image-20231015221848766](https://img.zxdmy.com/2022/202310152218838.png)

#### git commit命令与树对象、提交对象

数据对象中没有存储任何目录相关的信息。`树对象`，则解决了文件名保存问题，允许将多个文件组织到一起。通过 `git commit` 命令可以生成树对象。

比如将前面已添加至暂存区的文件，进行 `git commit` 后，每个文件都被设置了文件模式 `mode` ，为`100644`，表示普通文件，如下图所示。

![image-20231015223259434](https://img.zxdmy.com/2022/202310152248361.png)

再次对比 `objects` 目录发现，多了三个文件。

通过 `git cat-file -p <数据对象SHA-1散列值>` 可以解析每个文件内容，如下图所示。

![image-20231015223737108](https://img.zxdmy.com/2022/202310152248903.png)

按命名顺序：

+ 第1 个文件：是`commit`提交的对象内容，指明了树对象为`ac86fc51e061e2fc9ac01545ad011ffad3596616`，即第 3 个文件；同时包含本次提交的作者等信息；
+ 第 3 个文件：
  + 第1条记录，表示该树对象指向 `bc7774a7b18deb1d7bd0212d34246a9b1260ae17` 数据对象
  + 第2条记录，表示该树对象指向 `7f6fd15405b2303d4e2269a4d21f3e9c48143df6` 树对象（040000）
+ 第 2 个文件，是第3个文件第2条记录所指向的树对象，其包含 2 个数据对象，分别指向 `3462721fd4da6b3f451e6e720c547d0bbd546db3` 和 `c944ebc28f05731ef588ac6298485ba5e8bf3704`。

#### 提交对象

即前文中，第1个文件的解析，其包含一个`树对象`条目，代表着当前项目快照。从这个树对象，一层层往下找，就能找到所有提交的数据对象，并能够构建完整的项目目录。

至此，可以通过上述各个对象，构建完整的目录结构，如下图所示。

![image-20231017224633500](https://img.zxdmy.com/2022/202310172246330.png)

### 2.2 分支操作命令

#### 分支创建与切换

上述示例中，我们进行了一次`commit`操作，提交对象对应于 `7a4b9d`，这个过程，git默认为我们创建了一个名为 `master` 的分支，具体如下图所示。

![image-20231017225625473](https://img.zxdmy.com/2022/202310172256161.png)

> 不一定是 master，具体安装git时，可配置默认分支名称。

可以将`master`理解为一个指针，指向当前版本快照，而`HEAD`指针，表示指向当前所处的分支。

继续进行一次提交，生成的链表，可以描述为如下图所示。

![image-20231017230043536](https://img.zxdmy.com/2022/202310172300863.png)

![image-20231017230329905](https://img.zxdmy.com/2022/202310172303311.png)



当执行创建分支命令：`git branch <branch_name>` 时，实际是创建一个新的指针，指向当前版本的快照，如下图所示。

![image-20231017230524660](https://img.zxdmy.com/2022/202310172305733.png)

![image-20231017230601898](https://img.zxdmy.com/2022/202310172306982.png)

当执行切换分支命令：`git checkout <branch_name>` 时，`HEAD` 指针将指向 `feature-01` 分支，如下图所示。

![image-20231017230726307](https://img.zxdmy.com/2022/202310172334674.png)

![image-20231017230744475](https://img.zxdmy.com/2022/202310172307551.png)

在 `feature-01` 分支执行一次提交，此时将变成如下所示：

![image-20231017231208974](https://img.zxdmy.com/2022/202310172312293.png)

![image-20231017231450047](https://img.zxdmy.com/2022/202310172314085.png)

继续进行如下操作：

1. 切回  master 分支
2. 创建 feature-02 分支，并切换至此分支
3. 修改内容，进行 2 次 commit
4. 再切回  feature-01 分支
5. 修改内容，进行 1 次 commit

之后，整体的链表如下图所示。

![image-20231017232017397](https://img.zxdmy.com/2022/202310172320645.png)

![image-20231017232441233](https://img.zxdmy.com/2022/202310172334896.png)

#### 分支合并

上述操作过程，切回 `master` 分支后，可以通过分支合并命令：`git merge <branch_name>` 将分支 `feature-01` 合并至 `master` 分支。

![image-20231017232850448](https://img.zxdmy.com/2022/202310172328575.png)

这个过程中，由于 `feature-01` 分支包含 `master` 的全部内容，所以，直接将 `master` 指向快照 `663db66`，如下图所示。

![image-20231017233202534](https://img.zxdmy.com/2022/202310172332494.png)

在 `feature-01` 、 `feature-02` 分支提交时，都修改的是同一个文件的同一行，会有冲突，如下图所示。

![image-20231017233411978](https://img.zxdmy.com/2022/202310172353305.png)

输出日志表明文件 `hello.txt` 有冲突，通过 `git status` 命令查看当前状态：

![image-20231017233751043](https://img.zxdmy.com/2022/202310172337070.png)

通过命令 `git ls-files -s` 查看到底是哪些文件发生了合并冲突

![image-20231017233840227](https://img.zxdmy.com/2022/202310172338432.png)

其数值含义：

+ 0：对应的文件没有冲突，合并成功
+ 1：之前一个共同版本的对应文件内容
+ 2：当前 `master` 分支对应的文件版本
+ 3：合并分支 `feature-02` 对应的文件版本

通过命令 `git show :n:filename`可以查看对应文件的对应版本的内容：

![image-20231017234216558](https://img.zxdmy.com/2022/202310172344680.png)

此时，冲突文件 `hello.txt` 的内容，已经发生变化：

![image-20231017234603690](https://img.zxdmy.com/2022/202310172346983.png)

需要手动解决冲突后、`commit` 后，才能进行后续的操作：

![image-20231017234801650](https://img.zxdmy.com/2022/202310172348007.png)

此时，其链表结构如下图所示。

![image-20231017235150643](https://img.zxdmy.com/2022/202310172351213.png)

### 2.3 其他常用命令

#### stash

将所有未提交的修改（工作区和暂存区）保存至堆栈中：`git stash`

将堆栈中的内容应用到当前目录：`git stash apply`

更多如下：

```
# 保存当前未commit的代码
git stash

# 保存当前未commit的代码并添加备注
git stash save "备注的内容"

# 列出stash的所有记录
git stash list

# 删除stash的所有记录
git stash clear

# 应用最近一次的stash
git stash apply

# 应用最近一次的stash，随后删除该记录
git stash pop

# 删除最近的一次stash
git stash drop
```

#### reset

git reset --hard：回退已提交的 commit，修改内容不保存

git reset --soft：回退已提交的 commit，并将 commit 的修改内容放回到暂存区

```
# 恢复最近一次 commit
git reset --soft HEAD^
```

#### revert

撤回合并



参考：

https://blog.csdn.net/qq_38526623/article/details/117950702

https://blog.csdn.net/m0_62083249/article/details/126622251

Git 对象：https://blog.csdn.net/songyunzu/article/details/92023816