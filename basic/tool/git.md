# Git常用命令及其原理

## 1、Git概述

Git 是一个开源的 **分布式版本控制系统**，其分布式特性主要体现在，对于每次克隆操作，都对代码仓库进行完整备份，即每个开发者本地都保存了整个项目开发迭代的完整备份，有效避免集中式架构下中心服务器故障可能带来的数据丢失。

Git主要分为工作区、暂存区和版本库，具体如下：

+ **工作区**：即工作目录下直接进行增删改等操作的文件目录；
+ **暂存区**：也被成为索引（index），一般存放在 `.git` 目录下的 `index` 文件中，用于存放临时改动，保存下一次即将提交的文件列表修改与变更信息；
+ **版本库**： 工作区有一个隐藏目录 `.git`，这个不算工作区，而是 Git 的版本库，这里保存了我们提交的所有版本的数据。

下图描述了Git工作区、暂存区和版本库之间的关系：

![image-20231009224649593](https://img.zxdmy.com/2022/202310092246081.png)

Git 的本质是一个**文件系统**，工作目录中，所有文件的历史版本以及提交记录（commit）都是以文件对象的方式保存在 `.git` 目录中，其目录结构如下：

![image-20231022160906248](https://img.zxdmy.com/2022/202310221609189.png)

可重点关注以下几个文件与目录：

+ **HEAD**：工作目录当前状态对应的 commit，一般来说是当前 branch 的 head；
+ **config**：Git 的配置信息，包括 remote 地址，本地 branch 与 remote branch 的对应关系；
+ **objects**：真正保存 Git 对象的目录，包括**数据对象blob**、**树对象tree** 和 **提交对象commit**；
+ **refs**：用来保存 branch 和 tag 对应的 commit

## 2、常用命令及其实现原理

### 2.1 对象操作命令

存储在Git仓库中的内容通常称为Git对象，其有四种类型：

+ 数据对象（blob）
+ 树对象（tree）
+ 提交对象（commit）
+ 标签对象（tag）

#### git add 命令与数据对象

**数据对象blob** 是在使用 `git add` 命令，将文件或目录添加至暂存区时产生的，这个过程中，Git 会把文件中要存储的数据，和一个头部信息一起进行`SHA-1散列运算`，将得到的散列值作为文件的路径。

比如将含有内容为 `hello world!` 的 `hello.txt` 文件，添加至暂存区时，得到`SHA-1散列值bc7774a7b18deb1d7bd0212d34246a9b1260ae17` ，取2个字符用于命名**子目录**，其余38字符用于**命名文件**，生成的`数据对象`如下图所示：

![image-20231015221051320](https://img.zxdmy.com/2022/202310152211953.png)

> 实际使用前几个字符即可区分不同的数据对象，后文将默认用前 6/7 个字符表示各对象。

**这个散列值路径文件中保存的只是源文件的一种压缩形式**，通过 `git cat-file -p <数据对象SHA-1散列值>` 可以解析数据对象中的内容，如下图所示。

![image-20231022162927925](https://img.zxdmy.com/2022/202310221629446.png)

除了单个文件，将一系列文件（比如`git add <fileName>`、`git add .` 命令）添加至暂存区，每个文件都将生成一个数据对象。

比如将 `test` 目录下的 `hello.txt` 文件和 `world.txt` 文件，同时添加至暂存区时，将生成 **2** 个数据对象`3462721` 和 `c944ebc`，如下图所示。

![image-20231015221848766](https://img.zxdmy.com/2022/202310152218838.png)

#### git commit命令与树对象、提交对象

数据对象中没有存储任何目录相关的信息。`树对象` 则解决了文件名保存问题，允许将多个文件组织到一起。

通过 `git commit` 命令可以生成树对象。

前文已经将 3 个文件添加至暂存区，接着执行 `git commit` 后，每个文件都被设置 `100644` 的文件模式 `mode` ，这表示普通文件，如下图所示：

![image-20231022163322544](https://img.zxdmy.com/2022/202310221634844.png)

再次对比 `objects` 目录发现，多了三个文件，如下图所示：

![image-20231022163403156](https://img.zxdmy.com/2022/202310221634373.png)

将 `7a4b9d` 解析后，内容如下：

![image-20231022163741688](https://img.zxdmy.com/2022/202310221637643.png)

这就是 **提交对象**，即`commit`提交的对象内容，代表着当前提交的快照，其内容包含本次提交对应的**树对象**为`ac86fc`，以及本次的提交者信息与提交时间等信息；

将 **树对象** `ac86fc`解析后，内容如下：

![image-20231022164106387](https://img.zxdmy.com/2022/202310221641556.png)

该树对象包含 2 条记录：

+ 第 1 条记录，表示该**树对象**指向**数据对象** `bc7774` 数据对象
+ 第 2 条记录，表示该**树对象**又指向了**树对象** `7f6fd1` （mode 为 040000）

接着继续往下解析**树对象** `7f6fd1` ，内容如下，有2个数据对象 `346272` 和 `c944eb`：

![image-20231022164354028](https://img.zxdmy.com/2022/202310221643652.png)

至此，通过对 **提交对象**`7a4b9d`的一层层解析，就能找到本次提交所有的数据对象，以及构建对应的目录结构关系，如下图所示。

![image-20231017224633500](https://img.zxdmy.com/2022/202310172246330.png)

### 2.2 分支操作命令

#### 分支创建与切换

上述示例中，我们进行了一次`commit`操作，**提交对象** 为 `7a4b9d`。

在这个过程中，Git 默认为我们创建了一个名为 `master` 的分支。

![image-20231017225625473](https://img.zxdmy.com/2022/202310172256161.png)

> 不一定是 master，具体安装 git 时，可配置默认分支名称。

可以将`master`理解为一个指针，指向当前版本的提交对象，而`HEAD`指针，则表示指向当前的活动分支。

修改暂存区文件内容，进行 commit，通过命令查看log如下图所示：

![image-20231017230043536](https://img.zxdmy.com/2022/202310172300863.png)

绘制为简单的链表图，可以描述为：

![image-20231022165934962](https://img.zxdmy.com/2022/202310221659684.png)



当执行创建分支命令 `git branch <branch_name>` 时，实际创建的是一个新的指针`branch_name`，指向当前版本的快照，如下图所示。

![image-20231017230524660](https://img.zxdmy.com/2022/202310172305733.png)

![image-20231022170326952](https://img.zxdmy.com/2022/202310221703133.png)

当执行切换分支命令：`git checkout <branch_name>` 时，`HEAD` 指针将指向被切出的活动分支，如下图所示。

![image-20231017230726307](https://img.zxdmy.com/2022/202310172334674.png)

![image-20231022170458518](https://img.zxdmy.com/2022/202310221704468.png)

在 `feature-01` 分支执行一次提交，此时提交日志目录：

![image-20231017231208974](https://img.zxdmy.com/2022/202310172312293.png)

绘制为链表图，可描述为：

![image-20231022170912179](https://img.zxdmy.com/2022/202310221709380.png)

继续进行如下操作：

1. 切回  master 分支
2. 创建 feature-02 分支，并切换至此分支
3. 修改内容，进行 2 次 commit
4. 再切回  feature-01 分支
5. 修改内容，进行 1 次 commit

![image-20231022170956704](https://img.zxdmy.com/2022/202310221709749.png)

之后，提交日志如下图所示。

![image-20231022171031497](https://img.zxdmy.com/2022/202310221710947.png)

这时，绘制为链表图，可描述为：

![image-20231022171950543](https://img.zxdmy.com/2022/202310221719460.png)

#### 分支合并

上述操作过程，切回 `master` 分支后，可以通过分支合并命令：`git merge <branch_name>` 将分支 `feature-01` 合并至 `master` 分支。

![image-20231017232850448](https://img.zxdmy.com/2022/202310172328575.png)

这个过程中，由于 `feature-01` 分支包含 `master` 的全部内容，所以，直接将 `master` 指向快照 `663db66`，如下图所示。

![image-20231022172009816](https://img.zxdmy.com/2022/202310221720980.png)

在 `feature-01` 、 `feature-02` 分支提交时，都修改的是同一个文件的同一行。

所以将 `feature-02` 分支合并至 `master` 时，会有冲突，如下图所示。

![image-20231017233411978](https://img.zxdmy.com/2022/202310172353305.png)

输出日志表明文件 `hello.txt` 有冲突，通过 `git status` 命令查看当前状态：

![image-20231017233751043](https://img.zxdmy.com/2022/202310172337070.png)

通过命令 `git ls-files -s` 查看到底是哪些文件发生了合并冲突：

![image-20231017233840227](https://img.zxdmy.com/2022/202310172338432.png)

其数值含义：

+ 0：对应的文件没有冲突，合并成功
+ 1：之前一个共同版本的对应文件内容（即提交对象`df6ffcc`中的文件内容）
+ 2：当前 `master` 分支对应的文件版本
+ 3：合并分支 `feature-02` 对应的文件版本

通过命令 `git show :n:filename`可以查看对应文件的对应版本的内容：

![image-20231017234216558](https://img.zxdmy.com/2022/202310172344680.png)

此时，冲突文件 `hello.txt` 的内容，已经发生变化：

![image-20231017234603690](https://img.zxdmy.com/2022/202310172346983.png)

Git 使用 `<<<<<<<`，`=======`，`>>>>>>>` 标记出不同分支的内容。

需要**手动解决冲突**、`commit` 后，才能进行后续的操作：

![image-20231017234801650](https://img.zxdmy.com/2022/202310172348007.png)

此时，其链表结构如下图所示。

![image-20231022172420081](https://img.zxdmy.com/2022/202310221724387.png)

### 2.3 回退与撤销命令

#### git reset 命令

`git reset` 命令的作用是修改`HEAD`的位置，即将HEAD指向的位置改变为之前存在的某个版本。

`git reset` 有如下几种使用模式：

+ `git reset --soft <目标版本号>` ：把版本库上的提交回退至**暂存区**，修改记录保留；
+ `git reset --mixed <目标版本号>` ：把版本库上的提交回退至**工作区**，修改记录保留；
+ `git reset --hard <目标版本号>` ：把版本库上的提交彻底回退，修改记录全部还原（清除）。

比如针对 `feature-02` 分支，执行N次commit后，其提交记录如下图所示。

![image-20231022174442928](https://img.zxdmy.com/2022/202310221744942.png)

使用 `--soft` 模式撤销提交后，如下图所示。

![image-20231022180421952](https://img.zxdmy.com/2022/202310221804060.png)

使用 `--hard` 模式撤销提交后，如下图所示。

![image-20231022180637176](https://img.zxdmy.com/2022/202310221824965.png)

可以看出，提交对象 `2edce35` 和 `d62ac7c` 均被清除。

#### git revert

与 `reset` 不同，`reset` 回退后，其后面的提交记录均被清除。

而 `git revert` 是通过反做的方式重新创建一个新的提交，可以理解为 **撤销/撤回/反提交** 的意思，只撤销 某次 commit，不会影响其之后的提交。

> 但是：如果后面的提交，与要恢复的提交，修改了同一个地方，`revert` 就会产生冲突，需要手动解决。

![image-20231022181632803](https://img.zxdmy.com/2022/202310221816525.png)

将提交对象`a3229d1` 撤销过程中，与后续提交对象发生冲突，需要手动解决。

![image-20231022181747654](https://img.zxdmy.com/2022/202310221817822.png)

提交对象`a3229d1` 虽然被撤销提交，但其commit log依旧存在，`revert`操作成功后，产生了新的commit记录。

#### reset 与 revert 的区别

|      区别点      |   reset    |        revert        |
| :--------------: | :--------: | :------------------: |
|   历史提交记录   |   被清除   | 不影响，极大概率冲突 |
| 产生新的提交记录 |   不产生   |         产生         |
|       恢复       | *无法恢复* | 历史记录存在，可恢复 |
|       HEAD       |    后移    |         前移         |



### 2.4 其他常用命令

#### stash

将所有未提交的修改（工作区和暂存区）保存至堆栈中：`git stash`

将堆栈中的内容应用到当前目录：`git stash apply`

更多如下：

```
# 保存当前未commit的代码
git stash

# 保存当前未commit的代码并添加备注
git stash save "备注的内容"

# 列出stash的所有记录
git stash list

# 删除stash的所有记录
git stash clear

# 应用最近一次的stash
git stash apply

# 应用最近一次的stash，随后删除该记录
git stash pop

# 删除最近的一次stash
git stash drop
```

#### reset

git reset --hard：回退已提交的 commit，修改内容不保存

git reset --soft：回退已提交的 commit，并将 commit 的修改内容放回到暂存区

```
# 恢复最近一次 commit
git reset --soft HEAD^
```

#### revert

撤回合并



参考：

https://blog.csdn.net/qq_38526623/article/details/117950702

https://blog.csdn.net/m0_62083249/article/details/126622251

Git 对象：https://blog.csdn.net/songyunzu/article/details/92023816