## 1、Redis Sentinel 简介

**主从复制** 存在一个问题：**没法自动完成故障转移**。

`Redis Sentinel`（`哨兵`），就是一种 **实现自动故障转移与恢复** 的方案。

![image-20220911204358443](https://img.zxdmy.com/2022/202209112043701.png)

`Redis Sentinel` 由 `哨兵节点` 和 `数据节点` 两部分组成：

+ **哨兵节点**： 哨兵系统由一个或多个哨兵节点组成，**哨兵节点是特殊的 Redis 节点，不存储数据，对数据节点进行监控**。
+ **数据节点**： **主节点**和**从节点**都是数据节点；

具体来说，**哨兵**主要有以下功能：

+ **监控**（Monitoring）： 哨兵会不断地检查主节点和从节点是否运作正常。
+ **自动故障转移**（Automatic failover）： 当 `主节点` 不能正常工作时，哨兵会开始 `自动故障转移操作`，它会将失效主节点的**其中一个从节点升级为新的主节点**，并**让其他从节点改为复制新的主节点**。
+ **配置提供者**（Configuration provider）： 客户端在`初始化`时，通过连接哨兵来获**得当前 Redis 服务的主节点地址**。
+ **通知**（Notification）： 哨兵可以将**故障转移的结果发送给客户端**。

其中：

+ `监控`和`自动故障转移`功能，使得哨兵可以**及时发现主节点故障并完成转移**。
+ 配置提供者和通知功能，需要在与客户端的交互中才能体现。

## 2、Redis Sentinel 实现原理

`哨兵模式`是通过`哨兵节点`完成对数据节点的`监控`、`下线`、`故障转移`。

#### 监控

`Redis Sentinel` 通过三个 `定时监控任务` 完成对各个节点发现和监控：

![image-20220911205250266](https://img.zxdmy.com/2022/202209112052377.png)

1. **主从信息获取**：每隔10秒，每个 `Sentinel节点` 会向主节点和从节点发送info命令获取最新的拓扑结构
2. **哨兵信息发布**：每隔2秒，每个 `Sentinel节点` 会向Redis `数据节点` 的 `sentinel:hello` 频道上发送该Sentinel节点对于`主节点`的判断以及当前的 `Sentinel节点信息`
3. **节点心跳检测**：每隔1秒，每个 `Sentinel节点` 会向 `主节点`、`从节点`、`其余Sentinel节点` 发送一条
   `ping` 命令做一次心跳检测，来确认这些节点当前是否可达

#### 下线

`数据节点下线` 分为 `主观下线`（任何节点） 和 `客观下线`（主节点）：

+ **主观下线**：哨兵节点认为`某个节点`有问题
+ **客观下线**：超过一定数量的哨兵节点认为`主节点`有问题

![image-20220911205856880](https://img.zxdmy.com/2022/202209112058901.png)

**主观下线**：

每个`Sentinel节点`会每隔1秒对主节点、从节点、其他Sentinel节点发送ping命令进行心跳检测，当这些节点超过 `down-after-milliseconds` 没有进行有效回复，`Sentinel节点`就会对该节点做失败判定，这个行为叫做主观下线。

**客观下线**：

当Sentinel主观下线的节点是`主节点`时，该Sentinel节点会通过`sentinel is-masterdown-by-addr`命令向`其他Sentinel节点`询问对主节点的判断，当超过 `<quorum>` 个数的 Sentinel节点认为主节点确实有问题，这时该Sentinel节点会做出客观下线的决定。

#### 领导者 Sentinel 节点选举

当出现主节点故障问题，`Sentinel节点` 之间会做一个**领导者选举**的工作，选出一个`Sentinel节点` 作为`领导者`进行`故障转移`的工作。

**Redis使用了`Raft算法`实现领导者选举**。

关于领导者节点的选举算法，详见第三节。

#### 故障转移

前面选出来的 `领导者Sentinel节点` ，将负责`故障转移`工作。

![image-20220911210449309](https://img.zxdmy.com/2022/202209112104580.png)

过程如下：

1. **领导者Sentinel节点** 在从节点列表中选出一个节点**作为新的主节点**；
2. **领导者Sentinel节点** 会对第一步选出来的从节点执行 `slaveof no one` 命令**让其成为主节点**；
3. **领导者Sentinel节点** 会向剩余的`从节点`发送命令，让它们**成为新主节点的从节点**；
4. **Sentinel节点集合** 会**将原来的主节点更新为从节点**，并保持着对其关注，**当其恢复后命令它去复制新的主节点**。

## 3、领导者Sentinel节点选举算法

Redis使用了 `Raft算法` 实现`领导者选举`。

![image-20220911210759771](https://img.zxdmy.com/2022/202209112108920.png)

大致流程如下：

1. 每个在线的Sentinel节点都有资格成为领导者。当它确认`主节点`**主观下线**时候，会向其他Sentinel节点发送`sentinel is-master-down-by-addr`命令， **要求将自己设置为领导者**。
2. 收到命令的Sentinel节点，如果没有同意过其他Sentinel节点的`sentinel is-master-down-by-addr`命令，将同意该请求，否则拒绝。
3. 如果该 `Sentinel节点` 发现自己的票数已经大于等于`max(quorum, num(sentinels)/2+1)`，那么它将成为领导者。
4. 如果此过程没有选举出领导者，将进入下一次选举。

## 4、新的主节点选择方案

选出新的主节点，大概分为这么几步：

![image-20220911212111355](https://img.zxdmy.com/2022/202209112121423.png)

1. 过滤 “不健康”（主观下线、断线）、5秒内没有回复过Sentinel节点`ping`响应、与主节点失联超过`down-after-milliseconds * 10`秒。
2. 选择 `slave-priority`（从节点优先级）最高的从节点列表，如果存在则返回，不存在则继续。
3. 选择 `复制偏移量` 最大的从节点（复制的最完整），如果存在则返 回，不存在则继续。
4. 选择`runid`最小的从节点。

