## 1、Redis 集群简介

Redis 的主从复制存在高可用和分布式问题，哨兵模式则解决了高可用问题。

**集群**是解决主从复制的终极方案，同时解决高可用和分布式问题。

![image-20220911213948910](https://img.zxdmy.com/2022/202209112139005.png)

+ **数据分区** 功能：数据分区 (或称数据分片) 是集群最核心的功能。集群将数据分散到多个节点，一方面 突破了 Redis 单机内存大小的限制， 存储容量大大增加；另一方面 每个主节点都可以对外提供读服务和写服务， 大大提高了集群的响应能力。
+ **高可用** 功能：集群支持主从复制和主节点的自动故障转移（与哨兵类似），当任一节点发生故障时，集群仍然可以对外提供服务。

## 2、集群数据分区规则

分布式的存储中，要**把数据集按照分区规则映射到多个节点**。

常见的三种**数据分区规则**：

+ **节点取余**分区
+ **一致性哈希**分区
+ **虚拟槽**分区

#### 节点 Hash 取余分区

节点取余分区，非常好理解，使用特定的数据，比如Redis的键，或者用户ID之类，对响应的 **hash值取余**：`hash(key) % N`，来确定数据映射到哪一个节点上。

![image-20220912145453855](https://img.zxdmy.com/2022/202209121454207.png)

不过该方案最大的问题是，**当节点数量变化时，如扩容或收缩节点，数据节点映射关系需要重新计算，会导致数据的重新迁移**。

#### 一致性哈希分区

将整个 **Hash值空间** 组织成一个**虚拟的圆环**，然后将缓存节点的 IP 地址或者主机名做 Hash 取值后，放置在这个圆环上。

**环形空间**：按照常用的 hash 算法来将对应的 key 哈希到一个具有 `2^32` 次方个桶的空间中，即 `0~(2^32)-1` 的数字空间中，现在我们可以将这些数字头尾相连，想象成一个闭合的环形；

**Key 散列 Hash 环**：将各个**对象**的通过 Hash 函数计算出相应的 `key` 值，散列至 Hash 环上；

**机器散列 Hash 环**：以顺时针方向，将对象存储在环上距离最近的节点`Node`中；

**删除节点**：比如将 `Node3` 删除，则 `key5` 的数据将被迁移至 `Node4`；

**添加节点**：比如`key3` 和 `key4` 之间添加一个节点 `Node5`，则 `key3` 的数据将被迁移至 `Node5` 上。

![image-20220912150256221](https://img.zxdmy.com/2022/202209121502338.png)

当我们需要确定某一个 Key 需要存取到哪个节点上的时候，先对这个 Key 做同样的 Hash 取值，确定在环上的位置，然后按照顺时针方向在环上“行走”，遇到的第一个缓存节点就是要访问的节点。

**一致性哈希** 相比 **节点取余** 的好处在于 **加入和删除节点只影响哈希环中相邻的节点**，对其他节点无影响。

但其仍存在一些问题：

+ 缓存节点在圆环上分布不平均，会造成部分缓存节点的压力较大；
+ 当某个节点故障时，这个节点所要承担的所有访问都会被顺移到另一个节点上，会对后面这个节点造成压力。

#### 虚拟槽分区（Redis采用）

> Redis 集群使用的是该方案。

**虚拟槽分区** 方案在 **一致性哈希分区** 的基础上，引入了 **虚拟节点** 的概念，**虚拟节点** 被称为 **槽**（`slot`）。

**槽** 是介于数据和实际节点之间的虚拟概念，**每个实际节点包含一定数量的槽**，**每个槽包含哈希值在一定范围内的数据**。

在使用了 **槽** 的一致性哈希分区中，槽是数据管理和迁移的基本单位。

槽解耦了数据和实际节点 之间的关系，增加或删除节点对系统的影响很小。

假设下图的集群系统中有 `4` 个实际节点，为其分配 `16` 个槽（编号 0-15），槽 `0-3` 位于 `Node1`，槽 `4-7` 位于 `Node2`……

![image-20220912110047336](https://img.zxdmy.com/2022/202209121100305.png)

如果此时删除 `Node2` ，只需要对槽 `4-7` 重新分配即可。

比如将槽`4-5` 分配给 `Node1` ，槽`6` 分配给 `Node3` ，槽`7` 分配给 `Node4` ，数据在其他节点的分布仍然较为均衡。

## 3、Redis 集群创建过程

> Redis集群 通过**数据分区**来实现数据的分布式存储，通过**自动故障转移**实现高可用。
>
> **数据分区**是在**集群创建**的时候完成的。

Redis 集群 创建 主要包含以下三个阶段：

1. 设置节点
2. 节点握手
3. 分配槽

#### 设置节点

Redis集群 一般由多个节点组成，节点数量至少为 6 个才能保证组成完整高可用的集群。

每个节点需要开启配置 `cluster-enabled yes`，**让 Redis 运行在集群模式**下。

![image-20220912111030903](https://img.zxdmy.com/2022/202209121110154.png)

#### 节点握手

**节点握手** 是指一批运行在集群模式下的节点通过 `Gossip`**协议** 彼此通信， 达到感知对方的过程。

节点握手是集群彼此通信的第一步，由客户端发起命令：`clustermeet {ip} {port}`。

完成节点握手之后，一个个的Redis节点就组成了一个多节点的集群。

#### 分配槽（slot）

Redis集群把所有的数据映射到 `16384` 个槽中。

**每个节点对应若干个槽，只有当节点分配了槽，才能响应和这些槽关联的键命令**。

通过 `cluster addslots` 命令为节点分配槽。

![image-20220912111353988](https://img.zxdmy.com/2022/202209121113027.png)

## 4、Redis 集群故障转移流程

Redis集群的故障转移和哨兵的故障转移类似，但是Redis集群中的**所有节点都要承担状态维护的任务**。

#### 故障发现

Redis集群内节点通过`ping/pong`消息实现节点通信，集群中每个节点都会定期向其他节点发送`ping`消息，接收节点回复`pong` 消息作为响应。

如果在 `cluster-node-timeout` 时间内通信一直失败，则 **发送节点** 会认为接收节点存在故障，**把接收节点标记为主观下线**（`pfail`）状态。

![image-20220912143347866](https://img.zxdmy.com/2022/202209130849324.png)

当某个节点判断另一个节点主观下线后，相应的节点状态，会通过`Gossip`消息在集群内传播，集群内的各个节点将不断收集到故障节点的下线报告。

当 **半数以上** 持有 **槽** 的 **主节点** 都标记某个节点是**主观下线**时，触发**客观下线**流程。

![image-20220912143549492](https://img.zxdmy.com/2022/202209121435711.png)

#### 故障恢复

**故障节点** 变为 **客观下线** 后，如果下线节点是 **持有槽的主节点** ，则需要在它的从节点中选出一个替换它，从而保证集群的高可用。

**故障恢复**包含以下几个流程：

1. **资格检查**：每个从节点都要检查最后与主节点断线时间，判断是否有资格替换故障的主节点；
2. **准备选举时间**：当从节点符合故障转移资格后，更新触发故障选举的时间，只有到达该时间后才能执行后续流程；
3. **发起选举**：当从节点定时任务检测到达**故障选举时间**（`failover_auth_time`）到达后，发起选举流程；
4. **选举投票**：持有槽的主节点处理故障选举消息。投票过程其实是一个**领导者选举**的过程。比如集群内有`N`个持有槽的**主节点**，则代表有`N`张**选票**。由于在每个配置纪元内持有槽的主节点只能投票给一个从节点，因此只能有一个从节点获得 `N/2 + 1` 的选票，保证能够找出唯一的从节点。
5. **替换主节点**：当从节点收集到足够的选票之后，触发替换主节点操作。

![image-20220912144522631](https://img.zxdmy.com/2022/202209121445187.png)

#### Redis 集群物理节点数设置

在投票选举的环节，**故障主节点** 也算在投票数内。

假设集群内节点规模是 **3主3从**，**其中有 2 个主节点部署在一台物理机**上，当这台物理机宕机时，将有两个主节点客观下线，所以从节点无法收集到 `3/2+1` 个主节点选票，将导致故障转移失败。

这个问题也适用于故障发现环节。

因此部署集群时 **所有主节点最少需要部署在 3 台物理机上才能避免单点问题**。

## 5、Redis 集群的伸缩性

**Redis集群** 提供了灵活的 **节点扩容** 和 **收缩** 方案，可以在不影响集群对外服务的情况下，为集群添加节点进行扩容，也可以下线部分节点进行缩容。

![image-20220912145124703](https://img.zxdmy.com/2022/202209121451769.png)

其实，集群**扩容**和**缩容**的关键点，就在于槽和节点的对应关系，扩容和缩容就是将一部分**槽**和**数据**迁移给新节点。

例如下面一个集群，每个节点对应若干个槽，每个槽对应一定的数据，如果希望加入1个节点希望实现集群扩容时，需要通过相关命令把一部分槽和内容迁移给新节点。

![image-20220912145221992](https://img.zxdmy.com/2022/202209121452207.png)

缩容也是类似，先把槽和数据迁移到其它节点，再把对应的节点下线。