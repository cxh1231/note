## 1、采用延时双删处理

- 先删除缓存；
- 再写数据库；
- 休眠500毫秒；
- 再次删除缓存。

缺点：

+ 休眠时间的估算准确性
+ 增加了写请求的耗时

## 2、异步消息处理

+ 先读 Redis
+ 然后写MySQL
+ 然后更新 Redis 集群服务器数据
+ 将更新数据发送到消息队列
+ Redis 服务器订阅更新数据
+ 然后同步更新

缺点：需要部署消费代码同步数据，有一定的开发量。

本方案的异步消息处理，一般**基于订阅binlog的同步机制**。

**技术整体思路**：

MySQL binlog 增量订阅消费+消息队列+增量数据更新到 Redis

- **读Redis**：热数据基本都在Redis
- **写MySQL**:增删改都是操作MySQL
- **更新Redis数据**：MySQ的数据操作binlog，来更新到Redis

**Redis更新**：

**1）数据操作主要分为两大块：**

- 一个是全量(将全部数据一次写入到redis)
- 一个是增量（实时更新）

这里说的是增量,指的是mysql的update、insert、delate变更数据。

**2）读取binlog后分析，利用消息队列，推送更新各台的 Redis 缓存数据。**

这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。

其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。

这里可以结合使用`canal`（阿里的一款开源框架），通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。

当然，这里的消息推送工具你也可以采用别的第三方：`kafka`、`RabbitMQ`等来实现推送更新Redis。

## 总结

没有哪种方案是完美的，都无法做到强一致性。

我们总要在性能和数据准确性之间做出妥协。