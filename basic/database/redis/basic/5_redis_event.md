`Redis` 服务器是一个`事件驱动程序`。

## 1、文件事件与单线程（6.0 之前）

**`Redis` 基于 `Reactor` 模式来设计开发了自己的一套高效的`事件处理模型`**，而这个**事件处理模型**对应于 Redis 中的 **文件事件处理器**（File Event Handler），由于**文件事件处理器** 是单线程运行的，所以认为 **Redis 是单线程模型**。

Redis 服务器需要通过 `套接字` 与 `客户端` 或其他服务器进行通信，**文件事件处理器** 就是Redis 对套接字操作的抽象。

**文件事件处理器**（file event handler）主要是包含 4 个部分：

- 多个 socket（客户端连接）
- IO 多路复用程序（支持多个客户端连接的关键）
- 文件事件分派器（将 socket 关联到相应的事件处理器）
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

![image-20220809102823524](https://img.zxdmy.com/2022/202208091028657.png)

Redis 使用 `I/O 多路复用程序` 来同时监听多个`套接字`，并将到达的**事件**传送给 `文件事件分派器`，分派器会根据`套接字`产生的事件类型调用相应的`事件处理器`。

> **I/O 多路复用技术** 的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗。

## 2、时间事件

服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。

`时间事件`又分为：

- 定时事件：是让一段程序在指定的时间之内执行一次；
- 周期性事件：是让一段程序每隔指定时间就执行一次。

Redis 将所有时间事件都放在一个`无序链表`中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。

## 3、事件的调度与执行

服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。

事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：

```c
def aeProcessEvents():
    # 获取到达时间离当前时间最接近的时间事件
    time_event = aeSearchNearestTimer()
    # 计算最接近的时间事件距离到达还有多少毫秒
    remaind_ms = time_event.when - unix_ts_now()
    # 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0
    if remaind_ms < 0:
        remaind_ms = 0
    # 根据 remaind_ms 的值，创建 timeval
    timeval = create_timeval_with_ms(remaind_ms)
    # 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定
    aeApiPoll(timeval)
    # 处理所有已产生的文件事件
    procesFileEvents()
    # 处理所有已到达的时间事件
    processTimeEvents()
```

将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：

```c
def main():
    # 初始化服务器
    init_server()
    # 一直处理事件，直到服务器关闭为止
    while server_is_not_shutdown():
        aeProcessEvents()
    # 服务器关闭，执行清理操作
    clean_server()
```

从事件处理的角度来看，服务器运行流程如下：

![image-20220826203731067](https://img.zxdmy.com/2022/202208262037169.png)

## 4、多线程（6.0之后）

**Redis 在 4.0 之后的版本中就已经加入了对多线程的支持**，主要是针对一些大键值对的 **删除** 操作的命令，使用其他线程进行异步处理。

大体上来说，**Redis 6.0 之前主要还是单线程处理。**

> 为什么不使用多线程？
>
> 1. 单线程编程容易并且更容易维护；
> 2. Redis 的性能瓶颈不在 CPU ，主要在内存和网络；
> 3. 多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。

**Redis6.0 引入多线程主要是为了提高网络 IO 读写性能**，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。

Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 `redis.conf` ：

```bash
io-threads-do-reads yes
```

开启多线程后，还需要设置线程数，否则是不生效的。同样需要修改 redis 配置文件 `redis.conf` :

```bash
io-threads 4 #官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程
```

> Redis6.0 执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。