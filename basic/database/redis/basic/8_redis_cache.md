## 1、缓存穿透

#### 简介

大量请求的 key 不存在于缓存中，导致请求直接到了数据库上，没有经过缓存这一层，并且 **请求的数据也不在数据库** 中。

一般 **缓存穿透** 发生于：

+ 数据原来存在，但由于某些原因（误删、主动清理等）在缓存和数据库均被清除；
+ 恶意攻击行为，利用不存在的Key或者恶意尝试导致产生大量不存在的业务数据请求。

#### 解决方案

**1、参数校验**

对一些不合法的参数请求，直接抛出异常信息返回给客户端。

比如查询的数据库 id 不能小于 0、传入的邮箱格式不对。

**2、缓存无效 key**

如果缓存和数据库都查不到某个 key 的数据，就写一个到 Redis 中，并设置过期时间。

> 这种方式可以解决请求的 key 变化不频繁的情况。
>
> 如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。

**3、布隆过滤器**

**布隆过滤器** 是一个数据结构，通过它可以非常方便地判断一个给定数据是否存在于海量数据中。

具体操作：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。

![image-20220809111136868](https://img.zxdmy.com/2022/202208091111471.png)

但可能会误判：

+ **布隆过滤器说某个元素存在，小概率会误判。**
+ **布隆过滤器说某个元素不在，那么这个元素一定不在。**

通过布隆过滤器的原理，可以得出原因：

+ 将元素加入布隆过滤器：
  1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）
  2. 根据得到的哈希值，在位数组中把对应下标的值置为 1
+ 判断是否存在于布隆过滤器：
  1. 对给定元素再次进行相同的哈希计算
  2. 得到值之后判断位数组中的每个元素是否都为 1。如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。

所以，一定会出现这样一种情况：**不同的字符串可能哈希出来的位置相同**。

> 可以适当增加位数组大小或者调整我们的哈希函数来降低概率。

## 2、缓存击穿

#### 简介

对于单个热点 key 来说，在不停的扛着大并发，在这个key失效的瞬间，持续的大并发请求就会击破缓存，直接请求到数据库，好像蛮力击穿一样。这种情况就是**缓存击穿**（Cache Breakdown）。

> 可以把缓存击穿看做缓存雪崩的子集。

#### 解决方案

+ **使用互斥锁**（Mutex Key）：只让一个线程构建缓存，其他线程等待构建缓存执行完毕，重新从缓存中获取数据。单机通过 synchronized 或 lock 来处理，分布式环境采用分布式锁。
+ **热点数据不设置过期时间**，后台异步更新缓存，适用于不严格要求缓存一致性的场景。
+ **提前使用互斥锁**（Mutex Key）：在value内部设置一个比缓存（Redis）过期时间短的过期时间标识，当异步线程发现该值快过期时，马上延长内置的这个时间，并重新从数据库加载数据，设置到缓存中去。

## 3、缓存雪崩

#### 简介

**缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。**

**有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。**

#### 解决方案

**针对 Redis 服务不可用的情况：**

1. 采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。
2. 限流，避免同时处理大量的请求。

**针对热点缓存失效的情况：**

1. 设置不同的失效时间比如随机设置缓存的失效时间。
2. 缓存永不失效。

## 小结

缓存穿透、缓存雪崩和缓存击穿这三种异常情况从根本上来说都是因为本应该访问缓存的，但是缓存不存在或服务异常，导致流量直接进入了数据库层面。

其中缓存雪崩和缓存击穿是因为数据不存在（或服务异常获取不到），导致大量请求访问数据库，从而导致数据库压力骤增，甚至崩溃。

而缓存穿透则是由于数据本身就不存在，导致缓存没有进行数据缓存，流量进入数据库层。

针对不同的缓存异常场景，可选择不同的方案来进行处理。

当然，除了上述方案，我们还可以**限流**、**降级**、**熔断**等**服务层**的措施，也可以考虑**数据库层是否可以进行横向扩展**，当缓存异常发生时，确保数据库能够抗住流量，不至于让整个系统崩溃。
