## 1、Redis 数据类型简介

`Redis` 主要有 5 种 **基础数据结构** 和 3 种 **特殊数据结构**：

|   数据类型   |        存储的值        |                         可进行的操作                         |
| :----------: | :--------------------: | :----------------------------------------------------------: |
|   `String`   |  字符串、整数或浮点数  |     字符串：整体或部分执行操作；整数和浮点数：自增、自减     |
|    `List`    |          列表          |           两端读写；N 个元素修剪；范围内的元素保留           |
|    `Hash`    | 包含键值对的无序散列表 |       增、删、查单个键值对；获取全部键值对；判断键存在       |
|    `Set`     |        无序集合        | 增、删、查单个元素；求交、并、差集；随机读元素；判断元素存在； |
|    `Zset`    |        有序集合        | 增、删、查单个元素；根据分值范围或者成员来获取元素；计算某个键的排名 |
|    Bitmap    |        地理位置        |                                                              |
| HyperLogLogs |        基数统计        |                                                              |
|  Geospatial  |         位存储         |                                                              |

> + Redis 的使用场景？在项目中用到了哪些？
> + Redis 的数据类型和底层数据结构？

## 2、String（字符串）

#### 简介

`String` 是 Redis 中最简单同时也是最常用的一个数据结构，是一种 **二进制安全的数据结构**，可以用来存储任何类型的数据，比如 **字符串**、**整数**、**浮点数**、**图片**（图片的 base64 编码或者解码或者图片的路径）、**序列化后的对象** 等等。

`String` 的示例，以 `hello` 为 `Key`，以 `world` 为 `Value`：

![image-20220809101317038](https://img.zxdmy.com/2022/202208091013460.png)

#### 应用场景

1、**需要存储常规数据的场景**

- 举例 ：缓存 session、token、图片地址、序列化后的对象（相比较于 Hash 存储更节省内存）。
- 相关命令 ： `SET`、`GET`。

2、**需要计数的场景**

- 举例 ：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。
- 相关命令 ：`SET`、`GET`、 `INCR`、`DECR` 。

```shell
> set hello world
OK
> get hello
"world"
> del hello
(integer) 1
> get hello
(nil)
```

## 3、List（列表）

#### 简介

`Redis` 中的 `List` 是 **链表** 数据结构的实现，是一个 **双向链表**，支持正向和反向的查找和遍历，方便操作，不过带来了部分额外的内存开销。

![image-20220809101051718](https://img.zxdmy.com/2022/202208091010047.png)

`List` 的示例，其 `value` 值可以重复：

![image-20220809101305554](https://img.zxdmy.com/2022/202208091013648.png)

#### 应用场景

1、**信息流展示**

- 举例 ：最新文章、最新动态。
- 相关命令 ： `Lpush`、`Lrange`。

```shell
# rpush：从队列右侧插入一个数据
> rpush list-key item
(integer) 1
> rpush list-key item2
(integer) 2
> rpush list-key item
(integer) 3

# 获取列表指定区间的元素，0 表示起始元素，-1 表示最后一个元素
> lrange list-key 0 -1
1) "item"
2) "item2"
3) "item"

# 通过索引值获取元素
> lindex list-key 1
"item2"

# 获取并移出第一个元素
> lpop list-key
"item"

> lrange list-key 0 -1
1) "item2"
2) "item"
```

2、**消息队列**

Redis List 数据结构可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。

相对来说，Redis 5.0 新增加的一个数据结构 `Stream` 更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。

## 4、Hash（哈希）

#### 简介

`Redis` 中的 `Hash` 是一个 **String 类型的 field-value（键值对） 的映射表**，特别适合用于存储对象，后续操作的时候，可以直接修改这个对象中的某些字段的值。

![image-20220809101241885](https://img.zxdmy.com/2022/202208091012270.png)

#### 应用场景

1、**对象数据存储场景**

- 举例 ：用户信息、商品信息、文章信息、购物车信息。
- 相关命令 ：`Hset` （设置单个字段的值）、`HMset`（设置多个字段的值）、`Hget`（获取单个字段的值）、`HMget`（获取多个字段的值）

```shell
> hset hash-key sub-key1 value1
(integer) 1
> hset hash-key sub-key2 value2
(integer) 1
> hset hash-key sub-key1 value1
(integer) 0

> hgetall hash-key
1) "sub-key1"
2) "value1"
3) "sub-key2"
4) "value2"

> hdel hash-key sub-key2
(integer) 1
> hdel hash-key sub-key2
(integer) 0

> hget hash-key sub-key1
"value1"

> hgetall hash-key
1) "sub-key1"
2) "value1"
```

## 5、Set（集合）

#### 简介

`Redis` 中的 `Set` 类型是一种无序集合，集合中的元素**没有先后顺序但都唯一**，有点类似于 Java 中的 `HashSet` 。

当需要存储一个列表数据，又不希望出现重复数据时，`Set` 是一个很好的选择，并且 `Set` 提供了判断某个元素是否在一个 `Set` 集合内的重要接口，这个也是 `List` 所不能提供的。

![image-20220809101428794](https://img.zxdmy.com/2022/202208091014953.png)

**基于 `Set` 可以轻易实现交集、并集、差集的操作**。

比如你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。

#### 应用场景

1、**需要存放的数据不能重复的场景**

- 举例：网站 `UV` 统计（数据量巨大的场景还是 `HyperLogLog` 更适合一些）、文章点赞、动态点赞等场景。
- 相关命令：`SCARD`（获取集合数量） 。

![img](https://img.zxdmy.com/2022/202208091015575.png)

2、**需要获取多个数据源交集、并集和差集的场景**

- 举例 ：共同好友（交集）、共同粉丝（交集）、共同关注（交集）、好友推荐（差集）、音乐推荐（差集） 、订阅号推荐（差集+交集） 等场景。
- 相关命令：`SINTER`（交集）、`SINTERSTORE` （交集）、`SUNION` （并集）、`SUNIONSTORE`（并集）、`SDIFF`（交集）、`SDIFFSTORE` （交集）。

![img](https://img.zxdmy.com/2022/202208091015971.png)

3、**需要随机获取数据源中的元素的场景**

- 举例 ：抽奖系统、随机。
- 相关命令：`SPOP`（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、`SRANDMEMBER`（随机获取集合中的元素，适合允许重复中奖的场景）。

## 6、Zset（Sorted Set，有序集合）

#### 简介

`Sorted Set` 类似于 Set，但和 Set 相比，`Sorted Set` 增加了一个 **权重参数** `score`，使得集合中的元素能够按 `score` 进行有序排列，还可以通过 `score` 的范围来获取元素的列表。有点像是 Java 中 `HashMap` 和 `TreeSet` 的结合体。

![image-20220809101547131](https://img.zxdmy.com/2022/202208091015570.png)

#### 应用场景

1、**需要随机获取数据源中的元素根据某个权重进行排序的场景**

- 举例 ：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。
- 相关命令 ：`ZRANGE` (从小到大排序) 、 `ZREVRANGE` （从大到小排序）、`ZREVRANK` (指定元素排名)。

## 7、Bitmap（位存储）

#### 简介

`Bitmap` 存储的是连续的**二进制数字**（0 和 1），通过 `Bitmap`, 只需要一个 bit 位来表示某个元素对应的值或者状态，`key` 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。

你可以将 `Bitmap` 看作是一个**存储二进制数字（0 和 1）的数组**，数组中每个元素的下标叫做 `offset`（偏移量）。

![image-20220809101645390](https://img.zxdmy.com/2022/202208091016697.png)

#### 应用场景

1、**需要保存状态信息（0/1 即可表示）的场景**

- 举例：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。
- 相关命令：`SETBIT`、`GETBIT`、`BITCOUNT`、`BITOP`。

## 8、HyperLogLog（基数统计）

#### 简介

`HyperLogLog` 是一种有名的**基数计数概率算法** ，基于 `LogLog Counting(LLC)` 优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。

Redis 提供的 `HyperLogLog` 占用空间非常非常小，只需要 12k 的空间就能存储接近`2^64`个不同元素。这是真的厉害，这就是数学的魅力么！并且，Redis 对 `HyperLogLog` 的存储结构做了优化，采用两种方式计数：

- **稀疏矩阵** ：计数较少的时候，占用空间很小。
- **稠密矩阵** ：计数达到某个阈值的时候，占用 12k 的空间。

#### 应用场景

1、**数量量巨大（百万、千万级别以上）的计数场景**

- 举例 ：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、
- 相关命令 ：`PFADD`、`PFCOUNT` 

## 9、Geospatial index（地理空间索引）

#### 简介

`Geospatial index`（地理空间索引，简称 `GEO`） 主要用于存储地理位置信息，基于 `Sorted Set` 实现。

通过 `GEO` 我们可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。

![image-20220809101829997](https://img.zxdmy.com/2022/202208091018211.png)

#### 应用场景

1、**需要管理使用地理空间数据的场景**

- 举例：附近的人。
- 相关命令: `GEOADD`、`GEORADIUS`、`GEORADIUSBYMEMBER` 