## 1、过期判断

`Redis` 通过一个 **过期字典**（可以看作是 `hash` 表）来保存数据过期的时间。

**过期字典** 的 **键** 指向 `Redis` 数据库中的某个 key（键），过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。

![image-20220809104357687](https://img.zxdmy.com/2022/202208091043071.png)

> 对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。

## 2、过期删除策略

Redis 常用的过期数据的删除策略有两个：

| 删除策略 |                  简介                   |                   优劣                   |
| :------: | :-------------------------------------: | :--------------------------------------: |
| 惰性删除 | 在取 key 时才进行过期检查，若过期则删除 | 对CPU友好，但可能造成大量过期 key 未删除 |
| 定期删除 |     间隔一段时间删除一批过期的 key      |  限制删除操作时长和频率减少对CPU的影响   |

定期删除对内存更加友好，惰性删除对 CPU 更加友好，两者各有千秋。

所以 `Redis` 采用的删除策略是 **定期删除+惰性/懒汉式删除** 。

## 3、数据淘汰机制

`Redis` 虽然采用了 **定期删除和惰性删除** 的策略，仍有可能漏掉很多过期 `key` 的情况，这就导致大量过期 `key` 堆积在内存里，发生 `Out of Memory` 错误。

可以使用 **Redis 内存淘汰机制** 解决此问题。

Redis 提供 6 种数据淘汰策略，同时在 `Redis 4.0` 增加了两种根据访问频率的删除策略：

|  数据淘汰策略   |                             简介                             |
| :-------------: | :----------------------------------------------------------: |
|  volatile-LRU   | 从 **已设置过期时间** 的数据集中挑选 **最近最少使用** （Least Recently Used）的数据淘汰 |
|  volatile-TTL   | 从 **已设置过期时间** 的数据集中挑选 **将要过期** 的数据淘汰 |
| volatile-random |    从 **已设置过期时间** 的数据集中 **任意** 选择数据淘汰    |
|   allkeys-LRU   |        从 **所有** 数据集中挑选最近最少使用的数据淘汰        |
| allkeys-random  |           从 **所有** 数据集中任意选择数据进行淘汰           |
|   noeviction    |                         禁止驱逐数据                         |
|                 |                      ↓  Redis 4.0新增 ↓                      |
|  volatile-LFU   | 从 **已设置过期时间** 的数据集中挑选 **最不经常使用** （Least Frequently Used）的数据淘汰 |
|   allkeys-LFU   |     从 **所有** 数据集中挑选 **最不经常使用** 的数据淘汰     |

作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。

使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。