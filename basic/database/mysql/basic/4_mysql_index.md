## 1、索引简介

索引是一种数据结构，是一种文件。

数据库索引，是数据库管理系统中一个排序的数据结构，是一种特殊的文件（InnoDB数据表上的索引是表空间的一个组成部分），它们包含着对数据表里所有记录的引用指针，以协助快速查询、更新数据库表中数据，并占用一定的物理存储空间。

更通俗的说，索引就相当于目录，为了方便查找书中的内容，通过对内容建立索引形成目录。

## 2、索引的优缺点

**优点** ：

- 使用索引可以大大 **加快数据的检索速度**（大大减少检索的数据量）, 这也是创建索引的 **主要原因**；
- 使用索引可以在查询过程中，**使用优化隐藏器**，提供系统性能；
- 通过创建**唯一性索引**，可以保证数据库表中每一行数据的**唯一性**。

**缺点** ：

- **时间方面：创建索引和维护索引需要耗时**。即：当对表中的数据进行增、删、改时，索引需要动态维护，会降低 SQL 的执行效率；
- **空间方面：索引需要占用物理文件存储**，也会耗费一定空间。

## 3、索引的底层数据结构

#### Hash 索引

基于哈希表实现，只有精确匹配索引所有列的查询才有效。

对于每一行数据，存储引擎都会对所有的索引列计算一个**哈希码**（hash code），并且Hash索引将所有的**哈希码**存储在索引中，同时在索引表中保存指向每个数据行的指针。

![image-20220819201418648](https://img.zxdmy.com/2022/202208192014972.png)

> **为什么MySQL 没有使用 Hash 作为索引的数据结构？**
>
> + **Hash 冲突问题**：哈希表存在哈希冲突问题；
> + 最大缺点：**Hash 索引不支持顺序和范围查询**，使得对表数据进行排序或范围查询时，索引不可用。

#### B 树索引

`B-Tree` 能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，**数据分布在各个节点之中**。

![image-20220819201836182](https://img.zxdmy.com/2022/202208192018448.png)

但 MySQL 并没有采用这种索引结构。

#### B\+ 树索引（实际应用）

**B\+ 树的数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址**。

![image-20220819201946478](https://img.zxdmy.com/2022/202208192019737.png)

相对于 `B-Tree` ，`B+Tree` 进行范围查找时，只需要查找两个节点，进行遍历即可。而 `B-Tree` 需要获取所有节点，相比之下 `B+Tree` 效率更高。

`B-Tree` 的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 `B+Tree` 的检索效率就很稳定了，**任何查找都是从根节点到叶子节点的过程**，叶子节点的顺序检索很明显。

**B+ 树的性质**：

- n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。
- 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
- 所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。
- B+ 树中，数据对象的插入和删除仅在叶节点上进行。
- B+ 树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。

#### 为什么索引结构默认使用B+Tree

**相比较于B-tree，B+Tree的优点**： 

- **B+树的磁盘读写代价更低**：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B(B-)树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对`IO读写次数就降低`了。
- 由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在`区间查询`的情况，所以通常B+树用于数据库索引。

**Hash的不足**：

- 虽然可以快速定位，但是没有顺序，IO复杂度高；

- 基于Hash表实现，只有Memory存储引擎显式支持哈希索引 ；
- 适合**等值查询**，如=、in()、<=>，不支持范围查询 ；
- 因为不是按照索引值顺序存储的，就不能像B+Tree索引一样利用索引完成[排序](https://www.javalearn.cn/#/) ；
- Hash索引在查询等值时非常快 ；
- 因为Hash索引始终索引的**所有列的全部内容**，所以不支持部分索引列的匹配查找 ；
- 如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题 。

**二叉树的不足**： 树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。

**红黑树的不足**： 树的高度随着数据量增加而增加，IO代价高。

## 4、索引的分类

|         分类角度         |                          索引名称                          |
| :----------------------: | :--------------------------------------------------------: |
|         存储结构         | `B-TREE 索引`、`Hash 索引`、`FULL TEXT索引`、`R-TREE 索引` |
|         应用层次         | `普通索引`、`唯一索引`、`联合索引`（复合索引）、`主键索引` |
|           键值           |             `主键索引`、`辅助索引`（二级索引）             |
| 键值的逻辑关系与存储关系 |     `聚集索引`（聚簇索引）、`非聚集索引`（非聚簇索引）     |

#### :one: 存储结构上的分类

`MySQL` 的索引在**存储结构**（存储时保存的形式）上主要分为 `B Tree 索引`（B-Tree或B+Tree索引）、`Hash 索引`、`全文索引`（Full-Text Search）、`R-Tree 索引` 四种类别。

前两种存储结构前文有讲述。

**全文索引**：

**全文索引**（`FULLTEXT`）是针对使用 `like '%xxx%'` 进行模糊查询时的优化。

全文索引（`Full-Text Search`）是将存储于数据库中的整本书或整篇文章中的任意信息查找出来的技术。它可以根据需要获得全文中有关章、节、段、句、词等信息，也可以进行各种统计和分析。

**全文索引** 一般是通过 **倒排索引** 实现的，在 `辅助表` 中存储了单词与单词自身在一个或多个文档中所在位置之间的映射，这通常利用关联数组实现，拥有两种表现形式：

+  inverted file index：{单词，单词所在文档的id}
+  full inverted index：{单词，（单词所在文档的id，再具体文档中的位置）}

#### :two: 应用层次上的分类

`MySQL` 的索引在 **应用层次** 上主要分为 `普通索引`、`唯一索引`、`主键索引`、`联合索引`（复合索引） 几类。

| 索引名称 |                           简介                           |    关键字    |
| :------: | :------------------------------------------------------: | :----------: |
| 普通索引 |  一个索引只包含单个列，一个表可以有多个单列索引，无限制  |    index     |
| 联合索引 | 多列值组成一个索引，专门用于组合搜索，其效率大于索引合并 |    index     |
| 唯一索引 |             索引列的值必须唯一，但允许有空值             | unique index |
| 主键索引 |    特殊的唯一索引，不允许有控制，添加主键约束即可实现    | primary key  |

**普通索引**：

```sql
create index <索引的名称> on tablename(字段名);
alter table <表名> add index [索引的名字]（字段名）;
create table 表名([...], index [索引的名字](字段名));
```

**唯一索引**：

 唯一索引是普通索引的升级版本，索引字段必须是唯一的，但允许有空值。

在创建或修改表时，追加唯一约束，就会自动创建对应的唯一索引。

```sql
create unique index 索引名 on 表名(字段名);
alter table 表名 add unique index 索引名(字段名);
create table 表名([...], unique 索引名(字段名));
```

**主键索引**：

主键索引是一种特殊的唯一索引，因为它不允许有空值。在创建和修改表的时候，追加主键约束即可，每一个表只能有一个主键。

```sql
create table 表名([...], primary key(字段名));
alter table 表名 add primary key(字段名);
```

**联合索引**：

联合索引可以代替多个普通索引，并且开销比多个普通索引更小。

联合索引又分 `宽索引`和`窄索引`：

+ **窄索引** 一般指的是作用在1~2列的索引，一般推荐使用窄索引。
+ **宽索引** 就是作用在2列以上的索引。

```sql
create index 索引名 on 表名(字段1，字段2，...);
alter table 表名 add index 索引名(字段1，字段2，...);
create table 表名 ([...], index 索引名(字段1， 字段2， ...));
```

MySQL 的 **联合索引** 有一个 **最左匹配（最左优先）原则**。

即：在 `where` 子句进行等值查找（如 `=` 和 `in`）时，MySQL 会根据索引，一直向右匹配，直至遇到范围查找（>、<、between、like 等）才停止匹配。

比如有索引`(a,b,c)`，有以下查询：

+ `where a = 1` ：只走了 `(a)` 索引；
+ `where a = 1 and c = 3` ：只走了 `(a)` 索引；
+ `where a = 1 and c = 3 and b = 2` ：走了索引`(a,b,c)`，等值查找的顺序任意，查询优化器会优化成索引可以识别的形式；
+ `where a = 1 and b > 2 and c = 3` ：只走了索引 `(a)`
+ `where a = 1 and c > 3 and b = 2` ：只走了索引 `(a,b)`

因此在建立联合索引时，应注意索引列的顺序。

一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。

#### :three: 键值的逻辑关系与存储关系上的分类

> 

`MySQL` 的索引在 **键值的逻辑关系与存储关系** 上主要分为 `聚集索引`（聚簇索引）和`非聚集索引`（非聚簇索引）两类，它们并非单独的索引类型，而是一种数据存储方式。

|   类别   |     `聚集索引`（聚簇索引，主键索引）      |    `非聚集索引`（非聚簇索引、二级索引）     |
| :------: | :---------------------------------------: | :-----------------------------------------: |
|   简介   | `B-Tree索引`  中保存了 `主键` 和 `数据行` | `B+Tree索引` 的叶子节点只存储了 `主键的值`  |
| 应用引擎 |            InnoDB（主键索引）             | InnoDB（二级索引）、MyISAM（主键+二级索引） |

> 主要区别就是：叶子节点存储的是表中的全部数据，还是对应的主键（行号）。

比如有如下的数据表（不止这三列，只是这三列有索引）：

<img src="https://img.zxdmy.com/2022/202208232002723.png" alt="image-20220823200253022" style="zoom:67%;" />

 `id` 为`主键索引` ；`name`和`age`为`普通索引`，也就是 `二级索引`，也就是`非聚集索引`。

所以对于 `id` 来说，其在磁盘中的存储结构是 `聚集索引`，如下图所示：

<img src="https://img.zxdmy.com/2022/202208232009762.png" alt="image-20220823200929100" style="zoom:67%;" />

对于 `name` 来说，其在磁盘中的存储结构是 `非聚集索引`，如下图所示：

<img src="https://img.zxdmy.com/2022/202208232009064.png" alt="image-20220823200956080" style="zoom:67%;" />

## 5、索引与回表

对于 `InnoDB` 来说，通过 `二级索引` 查询时，需要先根据 `聚集索引`（主键索引）查找到记录的 `聚集索引键`，再根据 `聚集索引` 查询 `数据行`。这个过程，称之为 **回表**。

第一次索引一般是**顺序IO**，回表的操作属于**随机IO**。需要回表的次数越多，即随机IO次数越多，我们就越倾向于使用全表扫描 。

通常情况下， 主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引、二级索引）需要回表查询多次。

但是：**非聚簇索不一定会回表查询**。如果查询语句需要查询的字段，全部命中了索引，则不需要进行回表查询。

> 一个索引包含（覆盖）所有需要查询字段的值，被称之为"覆盖索引"。

## 6、前缀索引

> https://blog.csdn.net/weixin_38192427/article/details/122884032

当需要根据一个`长字符串类型`进行查找时，比如身份证、邮箱，为了避免全表扫描，需要为该`字符串字段`添加索引。

通即：对文本的前几个字符建立索引（具体是几个字符在建立索引时指定），这样建立起来的索引更小，所以查询更快。

1、计算**完整列**的索引选择性：

**索引选择性**：指`不重复的索引值`和数据表的`记录总数`的`比值`，取值范围在 `[0,1]` 之间。

```sql
SELECT COUNT(DISTINCT column_name) / COUNT(*) FROM table_name;
```

索引的选择性越高，则查询效率越高，因为选择性高的索引可以让 `MySQL` 在查找时过滤掉更多的行。

但当`索引选择性` 达到 `1` 时，就成了 `唯一索引` ，浪费空间，不符合创建 前缀索引 的初衷。

2、计算**不同前缀长度**的索引选择性：

```sql
SELECT COUNT(DISTINCT LEFT(column_name, prefix_length)) / COUNT(*) FROM table_name;
```

多次运行此语句，通过设置合适的 `prefix_length`，直至计算结果**最接近于全列选择性的时候**，就是最佳结果。

3、创建前缀索引

```sql
alter table table_name add index index_name(column_name(best_prefix_length));
```

> 注意：`order by` 不支持前缀索引。

## 7、索引下推

`MySQL 5.6` 引入了 **索引下推优化**，在 InnoDB 中只针对二级索引有效。

索引下推是默认开启的，使用如下命令可以关闭：

```sql 
SET optimizer_switch = ‘index_condition_pushdown=off’;
```

有了索引下推优化，可以 **减少回表次数**。比如：

在 `people_table`中有一个二级索引`(zipcode，lastname，address)`，有如下查询：

```sql
SELECT
	* 
FROM
	people 
WHERE
	zipcode = '95054' 
	AND lastname LIKE '%etrunia%' 
	AND address LIKE '%Main Street%';
```

**没有使用索引下推技术**：

+ 首先 MySQL 通过 `zipcode='95054'` 从存储引擎中查询对应的数据，返回到MySQL服务端；
+ 然后 `MySQL 服务端` 基于 `lastname LIKE '%etrunia% and address LIKE '%Main Street%'` 来判断数据是否符合条件。

**使用索引下推技术**：

+ 首先 MYSQL 返回符合 `zipcode=’95054’` 的 `索引`；
+ 然后根据条件 `lastname LIKE '%etrunia% and address LIKE '%Main Street%'` 来判断索引是否符合：
  + 如果符合条件，则根据该索引来定位对应的数据；
  + 如果不符合，则直接reject掉。

## 8、索引失效

索引在以下情况会导致索引失效（不走索引）：

|                索引失效情况                 |                  示例                  |
| :-----------------------------------------: | :------------------------------------: |
|          使用不等于：`!=` 或 `<>`           |            WHERE age <> 18             |
|     索引列使用 `OR`（连接相同字段除外）     |      WHERE id = 1 OR name= "张三"      |
|         索引列类型不一致（字符串）          |           WHERE name = 2345            |
|               索引列使用函数                | WHERE DATE(create_time) = '2020-09-03' |
| 索引列 `LIKE` 查询以 `%` 开头（放后边才走） |         WHERE name LIKE "%三"          |
|       索引列参与计算（+，-，*，/，!）       |          WHERE age - 1 = 20;           |
|             NOT IN、NOT EXISTS              |                                        |

## 9、创建索引的注意事项

1. 选择合适的字段：
   1. 不为NULL的字段 , 如果需要 , 使用0 , 1 , true , false来代替，因为含有空值的列很难进行查询优化；
   2. 被频繁查询的字段；
   3. 被作为条件查询的字段；
   4. 频繁需要排序的字段；
   5. 频繁连接的字段；
2. 被频繁更新的字段应谨慎建立索引；
3. 满足最左前缀匹配原则；
4. 选择区分度高（字段不重复的比例）的列作为索引，扫描的记录数越少，唯一键的区分度是1；
5. 索引列不能参与计算，保持列“干净”；
6. 尽量扩展索引，不要新建索引。如表中已有索引 `(a)`，需要添加 b 列，则修改 `(a)` 为 `(a,b)`；也即：尽量考虑联合索引而非单列索引；
7. 尽量避免冗余索引：能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引
8. 索引字段越小越好：数据库的数据存储以页为单位，一页存储的数据越多，一次IO操作获取的数据越大效率越高。