### 1.1 删除语句 drop、delete、truncate 的区别

|          |       delete        |           truncate           |            drop            |
| :------: | :-----------------: | :--------------------------: | :------------------------: |
|   类型   | DML（数据操纵语言） |     DDL（数据定义语言）      |            DDL             |
|   回滚   |       可回滚        |           不可回滚           |          不可回滚          |
|   操纵   |      删除数据       |           清空数据           |          丢弃数据          |
| 删除内容 | 删除全部或部分数据  | 删除全部数据，自增主键初始化 | 删除整个表，以及索引和权限 |
| 删除速度 |    慢，逐行删除     |              快              |            最快            |

> delete 不加 where 子句，作用与 truncate 类似，但主键不初始化。

### 1.2 模糊查询 % 和 \* 通配符的区别

|          |      `*`       |     `%`      |     `_`     |
| :------: | :------------: | :----------: | :---------: |
|   作用   | 匹配所有结果集 | 替代多个字符 | 代替N个字符 |
|  优先级  |  高，优先执行  |      低      |     低      |
| 针对范围 |    所有字段    |   单个字段   |  单个字段   |

> 使用示例：
>
> `select * from user where name like '%三%' or id like '1_';`
>
> 则：`张三`、`张三丰` 等都可以被查询出来，`id` 是 `10`、`19` 的都可以被查询，而 `110` 等则不行。

### 1.3 varchar 和 char 的区别

|          |               char               |                         varchar                          |
| :------: | :------------------------------: | :------------------------------------------------------: |
|   长度   | **定长**，申请的长度即占用字符数 | **变长**，申请的长度是最大长度，实际占用`真实字符长度+1` |
|          |                                  |           最后一个字符存储的是实际占用空间长度           |
| 检索效率 |              效率高              |                                                          |

### 1.4 in 和 exists 的区别

|      |                   in                   |                     exists                     |
| :--: | :------------------------------------: | :--------------------------------------------: |
| 作用 |        把外表和内表作hash 连接         | 对外表作loop循环，每次loop循环再对内表进行查询 |
| 索引 | 内外表都进行全表扫描，**没有用到索引** |      not extsts 的子查询可以用到表的索引       |
| 效率 |                                        |                   一般比较高                   |

### 1.5 SQL 约束

- `NOT NULL`：用于控制字段的内容一定**不能为空**（NULL）。
- `UNIQUE`：控件**字段内容不能重复**，一个表**允许有多个 Unique 约束**。
- `PRIMARY KEY`：**主键**，也是用于控件**字段内容不能重复**，但它在一个表**只允许出现一个**。
- `FOREIGN KEY`：**外键**，用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。
- `CHECK`：用于**控制字段的值范围**。

### 1.6 连接查询

MySQL 的连接查询，通常指将来自多个表的记录行结合起来，然后基于这些表之间的公共字段进行数据拼接。

连接之前，通常确定一个主表作为结果集，然后将其他表的行有选择性的连接至选定的主结果集上。

下面以这两个表演示连接：

![image-20220826111615827](https://img.zxdmy.com/2022/202208261116281.png)

#### 内连接

两张或多张表中同时符合某种条件的数据记录的组合。

```sql
 select 字段 from 表1 inner join 表2 on 表1.字段=表2.字段
```

> 内连接是系统默认的表连接，可以省略 `from` 子句后的 `inner` 关键字。

```sql
SELECT
	* 
FROM
	student
	INNER JOIN college ON student.college_id = college.id
```

运行结果：

![image-20220826111707213](https://img.zxdmy.com/2022/202208261117359.png)

#### 左外连接（左连接）

以**左表**为主根据条件查询右表数据，如果根据条件查询右表数据不存在使用null值填充

```sql
SELECT
	* 
FROM
	student
	LEFT JOIN college ON student.college_id = college.id
```

运行结果：

![image-20220826111854225](https://img.zxdmy.com/2022/202208261118219.png)

#### 右外连接（右连接）

以右表为主根据条件查询左表数据，如果根据条件查询左表数据不存在使用null值填充

```sql
SELECT
	* 
FROM
	student
	RIGHT JOIN college ON student.college_id = college.id
```

执行结果：

![image-20220826112000320](https://img.zxdmy.com/2022/202208261120908.png)

#### 自连接

左表和右表是同一个表，根据连接查询条件查询两个表中的数据。

比如有表：

![image-20220826112642630](https://img.zxdmy.com/2022/202208261126658.png)

SQL：

```sql
SELECT
	* 
FROM
	areas AS c
	INNER JOIN areas AS p ON p.id = c.pid
```

执行结果：

![image-20220826112708585](https://img.zxdmy.com/2022/202208261127129.png)

## 2、存储过程

### 2.1 简介

> **`存储过程`（Stored Procedure）**是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，它存储在数据库中，**一次编译后永久有效，比单纯的SQL速度更快**，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。
>
> **`存储过程`**中可以包含 **逻辑控制语句** 和 **数据操纵语句** , 它可以接受参数 , 输出参数 , 返回单个或多个结果集以及返回值。

### 2.2 存储过程的优缺点

**存储过程的优点**：

1. 存储过程 将复杂的 SQL 语句进行封装，在复杂查询过程中提供了一个替换位置；
2. 存储过程 在创建时即编译并存储在数据库中，其**运行速度比单纯的 SQL 语句更快**；
3. 存储过程 的调用只需要提供存储过程名和必要的参数信息，可以**减少网络流量，减轻网络负担**；
4. 存储过程 可以用于应用程序代码的不同位置，**代码精简一致**；
5. 存储过程 的访问权限（不基于表）可以向不同用户**分别授权**，**数据访问的安全性高**；
6. 存储过程 的参数数据类型，可以通过 SQLParameter 类指定，提高防御；
7. 提高代码安全，方式 SQL 注入。（但未彻底解决 , 例如将数据操作语言 `DML` 附加到输入参数）
8. 存储过程 的更新，比应用程序的更改、测试、部署需要的时间和精力更少，**可维护性高**【有争议】；

**存储过程的缺点**：

1.  难以调试和拓展，更没有拓展性
2.  存储过程 将应用程序绑定到 Server，所以使用存储过程封装业务逻辑将**限制应用程序的可移植性**。

> 《阿里巴巴Java开发手册》中规定，禁止使用存储过程。
>
> 可能原因是，项目的生命周期比较短，人员流动相比于传统的项目更加频繁，在这样的情况下，存储过程的管理确实是没有那么方便，同时，复用性也没有写在服务层那么好。

### 2.3 存储过程的基本使用

**简单存储过程实现：**

创建

```sql
create procedure GetUsers()
begin 
	select * from user; 
end;
```

调用

```sql
call GetUsers();
```

删除

```
drop procedure if exists GetUsers;
```

**带参数的存储过程实现：**

MySql 支持 IN (传递给存储过程) , OUT (从存储过程传出) 和 INOUT (对存储过程传入和传出) 类型的参数 , 存储过程的代码位于 BEGIN 和 END 语句内 , 它们是一系列 SQL 语句 , 用来检索值 , 然后保存到相应的变量 (通过指定INTO关键字) ;

创建

```sql
create procedure GetNameByID(
	in userID int,
	out userName varchar(200)
)
begin
	select name from user
	where id = userID
	into userName;
end;
```

调用

```
call GetNameByID(1, @userName);
select @userName;
```

