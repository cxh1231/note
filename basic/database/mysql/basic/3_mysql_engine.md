## 1、InnoDB 与 MyISAM 的区别

> 在大多数的情况下，**直接选择使用 InnoDB 引擎都是最合适的**，InnoDB 也是 MySQL 的默认存储引擎。

|          |                            InnoDB                            |                            MyISAM                            |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   事务   |                             支持                             |                            不支持                            |
|   外键   |                             支持                             |                            不支持                            |
| 索引结构 |                            B+ 树                             |                            B+ 树                             |
| 索引数据 | **聚集索引**，数据文件和（主键）索引**绑定**，必须有主键索引，**叶子节点即为数据文件**，主键索引效率很高 | **非聚集索引**，数据文件与索引**分离**，索引保存指向数据文件的**指针** |
| 主键索引 |                            必须有                            |                             可无                             |
| 辅助索引 |      辅助索引需要两次查询，先查主键，再通过主键查询数据      |                  主键索引与辅助索引互相独立                  |
| 全文索引 |                            不支持                            |                 支持，查询效率上 MyISAM 要高                 |
|    锁    |                    支持表、行（默认）级锁                    |                          支持表级锁                          |
|  表行数  |                       不保存，全表扫描                       |                       通过一个变量保存                       |
|   压缩   |                                                              |                    表格可被压缩后进行查询                    |
| 存储文件 |                frm：表定义文件，ibd：数据文件                |        frm：表定义文件，myd：数据文件，myi：索引文件         |
| 应用场景 |            适合频繁修改以及涉及到安全性较高的应用            |                  适合查询以及插入为主的应用                  |

> 为什么 `InnoDB` 没有**行数**这个变量？
>
> 因为 InnoDB 的**事务特性**，在**同一时刻表中的行数对于不同的事务而言是不一样的**，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。

## 2、InnoDB 事务的 ACID 特性保证方式

+ **原子性**：使用 `undo log`（**回滚日志**）来保证；
+ **持久性**：使用 `redo log` （**重做日志**）来保证；
+ **隔离性**：通过 **锁机制**、**MVCC** 等手段来保证（ 默认支持的隔离级别是  `REPEATABLE-READ` ）；
+ **一致性**：保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。

## 3、锁机制与 InnoDB 锁算法

**表级锁和行级锁对比：**

- **表级锁：** MySQL 中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。
- **行级锁：** MySQL 中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

**InnoDB 存储引擎的锁的算法有三种：**

- `Record lock`：记录锁，单个行记录上的锁
- `Gap lock`：间隙锁，锁定一个范围，不包括记录本身
- `Next-key lock`：record+gap 临键锁，锁定一个范围，包含记录本身