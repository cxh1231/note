## 1、MVCC 的简介

`MVCC`（Multi-Version Concurrency Control，多版本并发控制）是一种并发控制的方法，一般**在数据库管理系统中实现对数据库的并发访问**，**在编程语言中实现事务内存**。

`MVCC` 在 InnoDB 引擎的 MySQL 数据库中的实现，主要是为了**提高数据库并发性能**，用更好的方式去处理读-写冲突，做到**即使有读写冲突时，也能做到不加锁，非阻塞并发读**。

大多数的 MySQL 事务型存储引擎（InnoDB）所采用的并非简单的行锁机制，而是与 MVCC 一起使用。

锁机制可以控制并发操作，但系统开销大。

而 MVCC 可以在多数情况下代替行级锁，能够降低系统开销。

## 2、MVCC 的相关概念

#### 当前读与快照读

|       |                   当前读（锁定读）                   |     快照读（一致性非锁定读）     |
| :---: | :--------------------------------------------------: | :------------------------------: |
| 简介  |             读取的是记录的 **最新版本**              |  读取的记录 **可能是历史版本**   |
|  锁   |     读取时加锁，保证其他并发事务不能修改当前记录     | 不加锁，基于 `MVCC` 实现并发控制 |
|       |                                                      |       隔离级别不能是串行化       |
| 示例1 |        select lock in share mode (`共享锁`),         |       不加锁的 select 操作       |
| 示例2 | select for update; update; insert; delete (`排他锁`) |                                  |

> **MVCC 就是为了实现 `读-写冲突不加锁`，而这个`读`指的就是`快照读`, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现**

但是：

+ MVCC 是一个抽象概念，即 **维持一个数据的多个版本，使得读写操作没有冲突**，并非具体实现；
+ **快照读就是 MySQL 实现 MVCC 理想模型的其中一个非阻塞读功能**；
+ MVCC 模型在 MySQL 中的具体实现则是由 **`3 个隐式字段`**，**`undo 日志`** ，**`Read View`** 等去完成的。

#### 数据库并发场景

- `读-读`：不存在任何问题，也不需要并发控制；
- `读-写`：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读；
- `写-写`：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失；

> + 第一类更新丢失：`事务A` 撤销时，把已经提交的 `事务B` 的更新数据覆盖了。
> + 第二类更新丢失：`事务A` 覆盖了 `事务B` 已经提交的数据，造成 `事务B` 所做的操作丢失。

## 3、MVCC 解决的问题

多版本并发控制（`MVCC`）是一种用来解决 `读-写冲突` 的 `无锁并发控制`，也就是为**事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照**。 

所以 MVCC 可以为数据库解决以下问题：

+ 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能
+ 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题

所以在实际应用中，通常采用下面的两种组合来处理`读-写冲突`和`写-写冲突`：

- `MVCC + 悲观锁`：MVCC 解决读写冲突，悲观锁解决写写冲突
- `MVCC + 乐观锁`：MVCC 解决读写冲突，乐观锁解决写写冲突

## 4、MVCC 的三个概念

`MVCC` 的实现依赖于：**隐藏字段、Read View、undo log** 。

在内部实现中，`InnoDB` 通过数据行的 `DB_TRX_ID` 和 `Read View` 来判断数据的可见性，如不可见，则通过数据行的 `DB_ROLL_PTR` 找到 `undo log` 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 `Read View` 之前已经提交的修改和该事务本身做的修改。

在 MVCC 的实现方式中，主要有3个概念：

#### 隐式字段

每行记录除了我们自定义的字段外，还有数据库隐式定义的 `DB_TRX_ID`, `DB_ROLL_PTR`, `DB_ROW_ID` 等

|         字段名         |      名称       |                         简介                         |
| :--------------------: | :-------------: | :--------------------------------------------------: |
|  `DB_TRX_ID`（6字节）  | 最近修改事务 ID |         记录 `创建/最后修改` 该记录的事务 ID         |
| `DB_ROLL_PTR`（7字节） |    回滚指针     |               指向这条记录的上一个版本               |
|  `DB_ROW_ID`（6字节）  |  隐含的自增 ID  | 未设置主键，InnoDB 会自动以 `DB_ROW_ID` 创建聚簇索引 |

 示例图：

![image-20220824161642974](https://img.zxdmy.com/2022/202208241700907.png)

#### undo log

`undo log` 的相关概念在 [事务章节](#undo log) 已经做了详细的介绍。

`undo log` 主要分为两种：

|      |            insert undo log            |          update undo log（MVCC 实际有用的）           |
| :--: | :-----------------------------------: | :---------------------------------------------------: |
| 简介 | 事务在 insert 新记录时产生的 undo log |     事务在进行 update 或 delete 时产生的 undo log     |
| 需要 |          只在事务回滚时需要           |               在事务回滚、快照读时需要                |
| 删除 |       事务提交后可以被立即丢弃        |                     不能随便删除                      |
|      |                                       | 当快速读或事务回滚不涉及该日志时，才被 purge 线程清除 |

#### Read View（读视图）

所谓 `Read View`，指的是 **事务进行快照读 (select * from) 操作时，生产的`读视图`**（Read View）。

即：

+ 当隔离级别是`RR`（可重复读）时，每开启一个事物，系统会给该事务分配一个 `事物ID`；
+ 当该事务执行 `SELECT` 语句时，会生成一个当前时间点的 `事务快照 ReadView`。

对于每个事务的快照读 ReadView，核心属性如下：

+ `m_ids` ：生成该 ReadView 时，当前系统中活跃读写事务（还未执行提交的事务）的`事务ID列表`；
+ `m_up_limit_id` ：生成该 ReadView 时，当前系统中活跃的读写事务中`最小的事务ID`（小于这个 ID 的数据版本均可见）；
+ `m_low_limit_id` ：生成该 ReadView 时，系统应该分配给`下一个事务的ID值`（目前出现过的最大的事务 ID+1）；
+ `m_creator_trx_id` ：生成该 ReadView 的 `事务ID`（创建该 ReadView 的事务ID）

ReadView 主要是用来做`可见性判断`，里面保存了 “当前对本事务不可见的其他活跃事务”

即当某个事务执行快照读的时候，对该记录创建一个`Read View 读视图`，把它比作条件用来**判断当前事务能够看到哪个版本的数据**，既可能是当前最新的数据，也有可能是该行记录的 `undo log` 里面的某个版本的数据。

## 5、MVCC 的实现原理：数据可见性算法

在 `InnoDB` 存储引擎中，创建一个新事务后，执行每个 `select` 语句前，都会创建一个快照（Read View），**快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号**。

其实简单的说保存的是系统中当前**不应该被本事务看到的其他事务 ID 列表**（即 `m_ids`）。

当用户在这个事务中要读取某个记录行的时候，`InnoDB` 会将该记录行的 `DB_TRX_ID` 与 `Read View` 中的一些变量及当前事务 ID 进行比较，**判断是否满足可见性条件**。

**具体的比较算法**：

![image-20220825170059881](https://img.zxdmy.com/2022/202208251701360.png)

**事务可见性示意图**：

![image-20220825165526503](https://img.zxdmy.com/2022/202208251655824.png)

**数据可见性算法流程**：

1. 如果记录 `DB_TRX_ID < m_up_limit_id` ，表明最新修改该行的事务（`DB_TRX_ID`）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的
2. 如果 `DB_TRX_ID >= m_low_limit_id`，那么表明最新修改该行的事务（`DB_TRX_ID`）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤 5
3. `m_ids` 为空，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的
4. 如果 `m_up_limit_id <= DB_TRX_ID < m_low_limit_id`，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 `m_ids` 进行查找（源码中是用的二分查找，因为是有序的）
   - 如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建快照前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建快照后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。跳到步骤 5
   - 在活跃事务列表中找不到，则表明“id 为 trx_id 的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见
5. 在该记录行的 DB_ROLL_PTR 指针所指向的 `undo log` 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空

## 6、不可重复读问题：MVCC 解决



![image-20220825173946489](https://img.zxdmy.com/2022/202208251739695.png)

## 7、幻读问题：MVCC + Next-key-Lock 解决

`InnoDB`存储引擎在 RR 级别下通过 `MVCC`和 `Next-key Lock` 来解决幻读问题。

**1、执行普通 `select`，此时会以 `MVCC` 快照读的方式读取数据**：

在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 `Read View` ，并使用至事务提交。所以在生成 `Read View` 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”

**2、执行 `select...for update/lock in share mode、insert、update、delete` 等当前读**：

在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！`InnoDB` 使用 `Next-key Lock` 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读。