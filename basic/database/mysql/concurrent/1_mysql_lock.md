## 1、锁的简介

当多个用户**并发**地存取数据时，在数据库中就会产生**多个事务同时存取同一数据**的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，**破坏数据库的一致性**。

MySQL 锁的作用：**在多用户环境下保证数据库完整性和一致性**。

MySQL 锁的作用范围：**行** 或 **表**。

## 2、锁的宏观分类

|    场景    |                     锁分类                     |
| :--------: | :--------------------------------------------: |
|   粒度上   |             行级锁、表级锁、页级锁             |
|   类别上   |         共享锁（读锁）、排他锁（写锁）         |
| 并发控制上 | 乐观锁（乐观并发控制）、悲观锁（悲观并发控制） |

#### 锁粒度：行级锁与表级锁

关系型数据库中，可以 **按照锁的粒度** 把数据库锁分为**行级锁**、**表级锁** 和 **页级锁**。

|          |       行级锁       |            表级锁            |         页级锁         |
| :------: | :----------------: | :--------------------------: | :--------------------: |
|   简介   | 只对当前操作行加锁 |     对当前操作的整表加锁     | 介于行级锁和表级锁中间 |
| 应用引擎 |       InnoDB       |        InnoDB、MyISAM        |          BDB           |
|   粒度   |        最小        |             最大             |           中           |
|   开销   |         大         |              小              |           中           |
| 加锁速度 |         慢         |              快              |           中           |
|  并发度  |  高，锁冲突概率低  |       低，锁冲突概率高       |   一般，冲突概率中等   |
|   死锁   |       会死锁       |           不会死锁           |         会死锁         |
|   细分   |   共享锁、排他锁   | 共享读锁、独占写锁（排他锁） |           —            |

#### 锁类别：共享锁与排他锁

从 **锁的类别** 上来讲，有 **共享锁** 和 **排他锁**：

|          |    共享锁（Shared Locks，S锁，读锁）    |    排他锁（Exclusive Locks，X锁，写锁、独占锁）     |
| :------: | :-------------------------------------: | :-------------------------------------------------: |
|   简介   |      加共享锁后，只能读，不能改删       |     加排他锁后，可以增、改、删，不允许加任何锁      |
| 应用场景 | 进行数据**读取**时，对数据加 **共享锁** |       进行数据**写入**时，对数据加 **排他锁**       |
| 加锁限制 |        可以同时加**多个 共享锁**        | 只能加**一个 排他锁**，与其他的 排他锁、共享锁 相斥 |

用上面的例子来说就是用户的行为有两种：

+ 一种是来看房，多个用户一起看房是可以接受的。 
+ 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。

#### 并发控制：乐观锁与悲观锁

**数据库管理系统**（DBMS）中的 **并发控制** 的任务是确保在多个事务同时存取数据库中同一数据时，不破坏**事务**的**隔离性**和**统一性**，以及**数据库**的**统一性**。

**乐观锁**（乐观并发控制）和**悲观锁**（悲观并发控制）是**并发控制主要采用的技术手段**。

|          |                            乐观锁                            |                            悲观锁                            |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   简介   | 假设不会发生并发冲突，只在提交操作时检查是否违法数据库的完整性 |    假设一定发生并发冲突，屏蔽一切可能违反数据完整性的操作    |
| 实现方法 |  在修改数据的时候把事务锁起来，通过version的方式来进行锁定   |        在查询完数据的时候就把事务锁起来，直到提交事务        |
| 实现方式 |                    版本号机制 或 CAS算法                     |                        数据库的锁机制                        |
| 应用场景 | **多读场景**：很少发生冲突，使用 **乐观锁** 省去锁的开销，加大系统吞吐量 | **多写场景**：经常发生冲突，导致上层应用不断重试，降低了性能，适合悲观锁 |

## 3、锁的微观分类

|           锁名            | 范围 |                             简介                             |
| :-----------------------: | :--: | :----------------------------------------------------------: |
| 意向锁（Intention Locks） | 表锁 |    表明“某个事务正在某些行持有了锁、或该事务准备去持有锁”    |
|  记录锁（Record Locks）   | 行锁 |                      锁住索引记录的一行                      |
|    间隙锁（Gap Locks）    | 行锁 |    锁住一个索引区间（开区间），保证索引区间不会被插入数据    |
| 临键锁（Next-Key Locks）  | 行锁 | Record Lock + Gap Lock，左开右闭区间，唯一属性退化为 Record Lock |
| 自增锁（AUTO-INC Locks）  | 表锁 | 特殊的表级锁，发生涉及AUTO_INCREMENT列的事务性插入操作时产生 |

对于如下的SQL语句：

```sql
update user set name=“hello” where name=“world” and sex="M";
update user set name=“hello” where name=“world”;
```

+ 如果更新条件**没有走索引**，则进行全表扫描，阻止其他任何更新操作，上升为`表锁`；
+ 如果更新条件为**索引字段**，但**并非唯一索引**（含主键索引），则要保证符合条件的记录加上排他锁，并锁定非唯一索引对应的主键索引的值，同时保证锁定区间不能插入新的数据，索引会使用 `临键锁`；
+ 如果更新条件为**索引字段**，并且是**唯一索引**，则降级为 `记录锁`。

## 4、死锁与解决方案

数据库的死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

**常见的死锁解决方法**：

+ 对于不同程序并发存取多个表的情况，约定**以相同的顺序访问表**，可以大大降低死锁机会；
+ 在同一个事务中，尽可能做到**一次锁定所需要的所有资源**，减少死锁产生概率；
+ 对于容易产生死锁的业务部分，可以尝试升级锁定颗粒度，通过**表级锁**来减少死锁产生的概率；
+ 如果业务处理不好，可以用 **分布式事务锁** 或者使用**乐观锁**。

## 5、锁的优化

- **隔离级别**：尽量使用**较低**的隔离级别；
- **设计索引**：尽量**使用索引去访问数据**，加锁更加精确，从而减少锁冲突；
- **事务大小**：选择合理的事务大小，给记录显示加锁时，最好**一次性请求足够级别的锁**。如修改数据的事务，最好申请排他锁，而不是先申请共享锁，修改时在申请排他锁，这样会导致死锁；
- **访问顺序**：不同的程序访问一组表的时候，应尽量**约定一个相同的顺序访问各表**，对于一个表而言，尽可能的**固定顺序的获取表中的行**。这样大大的减少死锁的机会；
- **查询条件**：尽量**使用相等条件访问数据**，这样可以避免间隙锁对并发插入的影响；
- **申请锁**：不要申请超过实际需要的锁级别；
- **使用锁**：数据查询时，非不要不加锁。MySQL 的 MVCC可以实现事务中的查询不用加锁；
- 优化事务性能：MVCC 只在 committed read（读提交）和 repeatable read （可重复读）两种隔离级别下工作；
- 对于特定的事务，可以使用表级锁来提高处理速度，或者减少死锁的可能。