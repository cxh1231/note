## 1、事务简介

**事务是一个不可分割的数据库操作序列**，也**是数据库并发控制的基本单位**，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的**一组操作**，要么都执行，要么都不执行。

转账是事务的典型例子：

假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。

## 2、事务的 ACID 特性

> **是逻辑上的一组操作，要么都执行，要么都不执行。**

1. **原子性**（`Atomicity`） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. **一致性**（`Consistency`）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
3. **隔离性**（`Isolation`）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4. **持久性**（`Durability`）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

## 3、并发事务的问题

- **脏读**（Dirty read）：即 `事务A` 正在**访问并修改数据**，在**修改提交至数据库之前**，`事务B` 访问了 `事务A` 修改后的数据。因为 `事务A` 修改的**数据未提交**，`事务B` 读取的数据就是 `脏数据`。如果 `事务A` 发生 **回滚** 操作，则 `事务B` 依据此 `脏数据` 所做的操作是错误的。
- **丢失修改**（Lost to modify）：即 `事务A` 读取了一个数据，`事务B` 也读取了此数据，然后 `事务A` 修改了此数据，之后 `事务B` 也对此数据进行修改，这就导致 `事务A` 的修改结果丢失。
- **不可重复读**（Unrepeatable read）：即 `事务A` 执行过程中，会有多次访问某个数据的过程。在 `事务A` 两次访问某个数据之间，`事务B` 对此数据进行修改，导致 `事务A` 两次读取前后的数据不一致。
- **幻读**（Phantom read）：幻读与不可重复读类似。即 `事务A` 先读取了几行数据，接着 `并发事务B` 插入了一些数据，然后 `事务A` 又进行了查询，会查询到一些原本不存在的记录，就像发生了幻觉一样，故成为幻读。

> 总结：
>
> 脏读是一个事物回滚影响另一个事务；
>
> 不可重复读侧重于修改；
>
> 幻读侧重于新增或删除。

## 4、事务的隔离级别与锁关系

#### 隔离级别

> 如何实现事务的隔离？
>
> https://haicoder.net/note/MySQL-interview/MySQL-interview-MySQL-trans-level.html

|      隔离级别（从低到高）      |                简介                | 脏读 | 不可重复读 | 幻读 |
| :----------------------------: | :--------------------------------: | :--: | :--------: | :--: |
| Read Uncommitted（读取未提交） |     允许读取尚未提交的更新数据     |  √   |     √      |  √   |
|  Read Committed（读取已提交）  |   允许读取并发事务已经提交的数据   |  ×   |     √      |  √   |
|  Repeatable Read（可重复读）   | 对同一字段的多次读取结果都是一致的 |  ×   |     ×      |  √   |
|    Serializable（可串行化）    |       所有的事务依次逐个执行       |  ×   |     ×      |  ×   |

详述：

+ `Read Uncommitted`（读取未提交内容）：在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。`读未提交` 隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。**读取未提交的数据，也被称之为脏读**（Dirty Read）。

- `Read Committed`（读取提交内容）：这是大多数数据库系统的默认隔离级别（如 Oracle ，但不是 MySQL）。它满足了隔离的简单定义：**一个事务只能看见已经提交事务所做的改变**。**读取已提交的内容，会发生不可重复读**（Nonrepeatable Read）问题，因为同一事务的其他实例在该实例处理其间可能会有新的 commit，所以同一 select 可能返回不同结果。

- `Repeatable Read`（可重复读）：这**是 MySQL 的默认事务隔离级别**，它确保**同一事务的多个实例在并发读取数据时，会看到同样的数据行**。不过理论上，这会导致另一个棘手的问题：**幻读** （Phantom Read）。

- `Serializable`（可串行化）：**通过强制事务排序，使之不可能相互冲突，从而解决幻读问题**。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

总结：

+ **事务隔离机制的实现基于锁机制和并发调度**。其中**并发调度**使用的是`MVVC`（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。
+ **隔离级别越低，事务请求的锁越少**。但 `MySQL` 的`InnoDB` 引擎默认的是 `可重复的` 隔离级别，相比较于 `读已提交` 隔离级别，并不会有任何性能的损失。
+ InnoDB 存储引擎在 `分布式事务` 的情况下一般会用到 **SERIALIZABLE(可串行化)** 隔离级别。

#### 隔离级别与锁关系

|     隔离级别     |                         锁关系                         |
| :--------------: | :----------------------------------------------------: |
| Read Uncommitted |   读取数据不加共享锁，因此与排他锁不冲突（导致脏读）   |
|  Read Committed  |       读取数据加共享锁，语句执行完成后释放共享锁       |
| Repeatable Read  | 读取操作加共享锁，事务提交前不释放，事务执行完毕后释放 |
|   Serializable   |      锁定整个范围的键，并一直持有锁，直至事务完成      |

## 5、事务日志与二进制日志

**InnoDB 数据库引擎** 的**事务日志**包含两种：`redo log` 和 `undo log`；还有一种是不属于事务日志的**二进制日志** `bin log`。

+ `undo log` ，指事务开始之前，操作任何数据之前，先将需操作前一个版本的数据备份到一个地方；
+ `redo log` ，指事务中操作的任何数据，将最新的数据备份到一个地方；
+ `bin log` ，记录数据库执行的写入性操作（不包括查询）信息，以二进制的形式保存在磁盘中。

> - 逻辑日志：可以简单理解为记录的就是 SQL 语句；
> - 物理日志：`mysql` 数据最终是保存在数据页中的，物理日志记录的就是数据页变更。

宏观比较：

|             |         undo log         |      redo log       |          bin log           |
| :---------: | :----------------------: | :-----------------: | :------------------------: |
|    定位     |         回滚日志         |      重做日志       |          归档日志          |
|    用途     | 保存事务上一个版本、MVCC | 提升更新性能（WAL） |         数据库重建         |
|  故障恢复   |    保证主库数据原子性    |  保证主库数据一致   |      保证从库数据一致      |
|  所在位置   |       InnoDB 引擎        |     InnoDB 引擎     |        MySQL Server        |
| 写 log 时机 |        事务开始前        |       事务中        |         提交事务时         |
|  log 内容   |         逻辑日志         |     物理页修改      |        原始修改逻辑        |
|  log 空间   |            —             |     持续追加写      |           循环写           |
|   可关闭    |           不可           |        不可         | 单机、无数据重建需求可关闭 |

+ 事务日志的目的：实例或者介质失败，事务日志文件保证提交的记录不丢失，并能继续处理，即 **保证即使数据库发生异常重启，之前提交的记录都不会丢失**。
+ 二进制日志的目的：作主从复制，时间点恢复使用。

#### undo log

`MySQL` 事务的 `原子性` ，底层就是通过 `undo log` 实现的。

`undo log` 主要记录了数据的逻辑变化，其实际是对应 增删改 操作的反操作，比如一条 `INSERT` 语句，对应一条`DELETE` 的 `undo log` ，对于每个 `UPDATE` 语句，对应一条相反的 `UPDATE` 的 `undo log` ，这样在发生错误时，就能回滚到事务之前的数据状态。同时， `undo log` 也是 `MVCC`(多版本并发控制)实现的关键。

**主要作用**

1. 保存了事务发生之前的数据的一个版本，可以用于回滚；
2. 同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。Undo 中的数据可作为数据旧版本快照供其他并发事务进行快照读。

**生命周期**

1. **事务开始之前**，将当前事务版本生成 undo log，undo log 也会产生 redo log 来保证 undo log 的可靠性。
2. 当**事务提交之后**，undo log 并不能立马被删除，而是**放入待清理的链表。**
3. 由 **purge 线程**判断是否有其它事务在使用 undo 段中表的上一个事务之前的版本信息，从而决定是否可以清理 undo log 的日志空间。

![image-20220819203837173](https://img.zxdmy.com/2022/202208192038621.png)

**存储内容**

undo log 存储的是逻辑格式的日志，保存了事务发生之前的上一个版本的数据，可以用于回滚。当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着 undo 链找到满足其可见性的记录。

**存储位置**

默认情况下，undo 文件是保存在共享表空间的，也即 ibdatafile 文件中，当数据库中发生一些大的事务性操作的时候，要生成大量的 undo log 信息，这些信息全部保存在共享表空间中，因此共享表空间可能会变得很大，默认情况下，也就是 undo log 使用共享表空间的时候，被“撑大”的共享表空间是不会、也不能自动收缩的。因此，MySQL5.7 之后的“独立 undo 表空间”的配置就显得很有必要了。

**详细示例**

下面是一个 `update undo log` 的一个示例：

1、初始时，某个事务对用户表插入一条记录，如下图所示；

![image-20220824165547017](https://img.zxdmy.com/2022/202208241700926.png)

2、`事务1` 将记录的 `name` 修改为 `Tom`：

+ 在 `事务1` 修改该行(记录)数据时，数据库会先对该行加 `排他锁`；
+ 然后把该行数据拷贝到 `undo log` 中，作为旧记录，即在 `undo log` 中有当前行的拷贝副本；
+ 拷贝完毕后，修改该行 `name` 为 `Tom`，并且修改隐藏字段的 `事务 ID` 为当前 `事务1` 的 `ID`, 我们默认从 1 开始，之后递增，回滚指针指向拷贝到 `undo log` 的副本记录，既表示我的上一个版本就是它；
+ 事务提交后，释放锁。

![image-20220824170047632](https://img.zxdmy.com/2022/202208241700124.png)

3、新的 `事务2` 将记录 `age` 修改为 `30` ：

+ 在 `事务2` 修改该行数据时，数据库也先为该行加锁
+ 然后把该行数据拷贝到 `undo log` 中，作为旧记录，发现该行记录已经有 `undo log` 了，那么最新的旧数据作为链表的表头，插在该行记录的 `undo log` 最前面
+ 修改该行 `age` 为 `30` 岁，并且修改隐藏字段的 `事务 ID` 为当前 `事务2` 的 ID, 那就是 2 ，回滚指针指向刚刚拷贝到 `undo log` 的副本记录
+ 事务提交，释放锁

![image-20220824170407364](https://img.zxdmy.com/2022/202208241704763.png)

通过以上流程可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的 `undo log` 成为一条记录版本线性表，既链表，**undo log 的链首就是最新的旧记录**，链尾就是最早的旧记录（当然就像之前说的该 `undo log` 的节点可能是会 purge 线程清除掉，向图中的第一条 `insert undo log`，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）

#### redo log

`redo log` 是物理日志，记录了每次操作在页上做了什么修改。

写 `redo log` 也是需要写磁盘的，但它的好处就是顺序IO，写入的速度很快（比随机IO快很多）。

在 **事务的执行过程中**，便开始写 `redo log`。

**原因**：

+ 传统的在事务提交过程中，将设计修改的数据全部刷新至磁盘的操作方式，存在性能问题；
+ `Innodb` 以 `页` 为单位进行磁盘交互，而一个事务很可能只修改一个数据页里面的几个字节，这种情况，将完整的数据页刷到磁盘的话，浪费资源；
+ 一个事务可能涉及修改多个数据页，并且这些数据页在物理上并不连续，使用随机IO写入性能太差

为了保证事务的一致性，以及数据的持久化，因此 `MySQL` 设计了 `redo log` ，只记录事务对数据页做了哪些修改，即可解决性能问题。

> 在 `InnoDB` 中，既有`redo log` 需要刷盘，还有 `数据页` 也需要刷盘， `redo log` 存在的意义主要就是降低对 `数据页` 刷盘的要求。

**日志记录形式**：

 `redo log` 采用了大小固定，循环写入的方式，当写到结尾时，会回到开头循环写日志。

<img src="https://img.zxdmy.com/2022/202208222128015.png" alt="image-20220822205124008" style="zoom:50%;" />

在上图中， `write pos` 表示 `redo log` 当前记录的 `LSN` (逻辑序列号)位置， `check point` 表示 数据页更改记录 刷盘后对应 `redo log` 所处的 `LSN`(逻辑序列号)位置。

`write pos` 到 `check point` 之间的部分是 `redo log` 空着的部分，用于记录新的记录；

`check point` 到 `write pos` 之间是 `redo log` 待落盘的数据页更改记录。

当 `write pos`追上`check point` 时，会先推动 `check point` 向前移动，空出位置再记录新的日志。

启动 `innodb` 的时候，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。

因为 `redo log`记录的是数据页的物理变化，因此恢复的时候速度比逻辑日志(如 `binlog` )要快很多。

重启`innodb` 时，首先会检查磁盘中数据页的 `LSN` ，如果数据页的`LSN` 小于日志中的 `LSN` ，则会从 `checkpoint` 开始恢复。

还有一种情况，在宕机前正处于`checkpoint` 的刷盘过程，且数据页的刷盘进度超过了日志页的刷盘进度，此时会出现数据页中记录的 `LSN` 大于日志中的 `LSN`，这时超出日志进度的部分将不会重做，因为这本身就表示已经做过的事情，无需再重做。 

**基本流程**：

`redo log` 包括两部分：

+ 内存中的日志缓冲( `redo log buffer` )，
+ 磁盘上的日志文件( `redo log file`)。

`mysql` 每执行一条 `DML` 语句，先将记录写入 `redo log buffer`，后续某个时间点再一次性将多个操作记录写到 `redo log file`。

这种 **先写日志，再写磁盘** 的技术就是 `MySQL`里经常说到的 `WAL(Write-Ahead Logging)` 技术。

在计算机操作系统中，用户空间( `user space` )下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间( `kernel space` )缓冲区( `OS Buffer` )。

因此， `redo log buffer` 写入 `redo logfile` 实际上是先写入 `OS Buffer` ，然后再通过系统调用 `fsync()` 将其刷到 `redo log file`中。

![image-20220822205508770](https://img.zxdmy.com/2022/202208222055119.png)

**具体的落盘策略可以进行配置** 。

`mysql` 支持三种将 `redo log buffer` 写入 `redo log file` 的时机，可以通过 `innodb_flush_log_at_trx_commit` 参数配置，各参数值含义如下：

![image-20220822205801981](https://img.zxdmy.com/2022/202208222058379.png)

- 0：延迟写。不会在事务提交时立即将redo log buffer写入到os buffer，而是每秒写入os buffer，然后立即写入到redo log file，也就是每秒刷盘；
- 1：实时写，实时刷。每次事务提交都会将redo log buffer写入os buffer，然后立即写入redo log file。数据能够及时入盘，但是每次事务提交都会刷盘，效率较低；
- 2：实时写，延时刷。每次事务提交都将redo log buffer写入os buffer，然后每秒将os buffer写入redo log file。

#### bin log

`bin log` 用于记录数据库执行的表结构变更（例如 CREATE、ALTER TABLE）以及表数据修改（INSERT、UPDATE、DELETE）等的写入性操作（不包括查询，如 SELECT 和 SHOW 等）信息，以二进制的形式保存在磁盘中，通过追加的方式进行写入。

`bin log` 是 `MySQL`的逻辑日志，并且由 `Server` 层进行记录，使用任何存储引擎的 `MySQL` 数据库都会记录 `bin log` 日志。可以简单的理解为它存储着每条变更的SQL语句。

MySQL `bin log` 以事件形式记录，还包含语句所执行的消耗的时间，MySQL 的二进制日志是事务安全型的。`bin log` 的主要目的是复制和恢复。

**刷盘时机**：

`mysql` 通过 `sync_binlog` 参数控制 `biglog` 的刷盘时机，取值范围是 `0-N`：

- 0：不去强制要求，由系统自行判断何时写入磁盘；
- 1：每次 `commit` 的时候都要将 `binlog` 写入磁盘（默认）；
- N：每N个事务，才会将 `binlog` 写入磁盘。

**三种模式**

binlog 有三种格式，各有优缺点：

- **statement：** 基于 SQL 语句的模式，某些语句和函数如 UUID, LOAD DATA INFILE 等在复制过程可能导致数据不一致甚至出错。
- **row：** 基于行的模式，记录的是行的变化，很安全。但是 binlog 会比其他两种模式大很多，在一些大表中清除大量数据时在 binlog 中会生成很多条语句，可能导致从库延迟变大。
- **mixed：** 混合模式，根据语句来选用是 statement 还是 row 模式。

## 6、事务的实现原理

事务是基于 **重做日志文件**(redo log)和 **回滚日志**(undo log)实现的。

+ 每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。

+ 每当有修改事务时，还会产生 `undo log`，如果需要回滚，则根据 undo log 的反向语句进行逻辑操作，比如 insert 一条记录就 delete 一条记录。undo log 主要实现数据库的一致性。