## 1、垃圾回收（GC）概述

> 如果没有特殊说明，都是针对的是 HotSpot 虚拟机。

当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。

Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 **堆** 内存中对象的分配与回收。

**Java 堆是垃圾收集器管理的主要区域**，因此也被称作 **GC 堆（Garbage Collected Heap）**。

从垃圾回收的角度来说，由于现在收集器基本都采用**分代垃圾收集算法**，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。

在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：

1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永久代(Permanent Generation)

**下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于`新生代`，中间一层属于`老年代`，最下面一层属于`永久代`。**

![image-20220731165419362](https://img.zxdmy.com/2022/202208010958045.png)

## 2、内存的分配与回收

> 问：什么时候发生 GC？

#### 对象优先在 Eden 区分配

大多数情况下，对象在**新生代**中 Eden 区分配。

`当 Eden 区没有足够空间进行分配时`，虚拟机将发起一次 **Minor GC（新生代垃圾回收）**。

#### 大对象直接进入老年代

**大对象** 就是需要大量连续内存空间的对象（比如：字符串、数组）。

大对象直接进入老年代主要是为了避免为大对象分配内存时由于**分配担保机制**带来的复制而降低效率。

> **空间分配担保** 是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。

#### 长期存活的对象将进入老年代

由于 Java 虚拟机采用分代收集的思想来管理内存，为了内存回收时识别哪些对象放在新生代，哪些对象放在老年代，虚拟机给每个对象一个**对象年龄计数器**（Age）。

1. 大多数情况下，对象首先被分配在 `Eden` 区域；
2. `Eden` 出生的对象，经过一次 `Minor GC` 后仍存活，并且能被 `Survivor` 容纳：将被移动到 `Survivor` 空间（`s0` 或者 `s1`）中，并将对象年龄设为 `1`
3. 对象在 `Survivor` 中每熬过一次 `MinorGC`,年龄就增加 `1` 岁
4. 当该对象年龄增加到一定程度（默认为 15 岁，但有出入，详见下文），就会被晋升到`老年代`中。

> 对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

> `Hotspot` 遍历所有对象时，按照**年龄从小到大**对其所占用的大小进行累积，当累积的某个年龄大小超过了 `survivor` 区的 `50%` 时（默认值是 `50%`，可以通过参数 `-XX:TargetSurvivorRatio=percent` 来设置），取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值。

#### GC 分类

**部分收集 (Partial GC)：**

- **新生代收集（Minor GC / Young GC）**：只对新生代进行垃圾收集；
- **老年代收集（Major GC / Old GC）**：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- **混合收集（Mixed GC）**：对整个新生代和部分老年代进行垃圾收集。

**整堆收集 (Full GC)：**收集整个 Java 堆和方法区。

## 3、死亡对象的判断

**堆** 中几乎放着所有的**对象实例**，对 **堆** 垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）

#### 引用计数法

给对象中添加一个引用计数器：

- 每当有一个地方引用它，计数器就加 1；
- 当引用失效，计数器就减 1；
- 任何时候计数器为 0 的对象就是不可能再被使用的。

> **这个方法实现简单，效率高，但是目前主流的虚拟机中`并没有`选择这个算法来管理内存，其最主要的原因是它很难解决对象之间`相互循环引用`的问题。**

相互引用示例：

```java
public class ReferenceCountingGc {
    Object instance = null;
    public static void main(String[] args) {
        ReferenceCountingGc objA = new ReferenceCountingGc();
        ReferenceCountingGc objB = new ReferenceCountingGc();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
    }
}
```

除了对象 `objA` 和 `objB` 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 `0`，无法被回收。

#### 可达性分析法

即通过一系列被称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为**引用链**，当一个对象到 **GC Roots** 没有任何**引用链**相连的话，则证明此对象是不可用的，需要被回收。

下图中的 `Object 6 ~ Object 10` 之间虽有引用关系，但它们到 **GC Roots** 不可达，因此需要被回收的对象。

![image-20220801095635336](https://img.zxdmy.com/2022/202208010956419.png)

**可以作为 GC Roots 的对象**

- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象

## 4、类型引用

> 无论是通过 **引用计数法** 判断对象引用数量，还是通过 **可达性分析法** 判断对象的引用链是否可达，**判定对象的存活都与“引用”有关。**

JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为**强引用**、**软引用**、**弱引用**、**虚引用**四种（引用强度逐渐减弱）。

#### 强引用

**强引用** 是使用最普遍的引用，我们使用的大部分引用都属于强引用。

**如果一个对象具有强引用，那该对象必不可少，垃圾回收器 绝不会回收它。**

当内存不足时，也不会回收，而是抛出  OutOfMemoryError 错误使程序异常终止。

#### 软引用

具有 **软引用** 的对象可有可无。

内存足够时，垃圾回收器 不会回收它，内存不足时，垃圾回收器 会回收这些对象的内存。

**软引用** 可用来实现内存敏感的高速缓存。

> **软引用** 可以和一个**引用队列**（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。

#### 弱引用

具有 **弱引用** 的对象可有可无。

**弱引用** 的对象拥有更短暂的生命周期，垃圾回收器线程一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。（垃圾回收器 是一个优先级很低的线程， 不一定会很快发现那些只具有弱引用的对象。）

> **弱引用** 可以和一个**引用队列**（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

#### 虚引用

如果一个对象仅持有**虚引用**，那么它就和**没有任何引用**一样，在任何时候都可能被垃圾回收。

## 5、废弃常量与无用类

#### 废弃常量

> **运行时常量池** 主要回收的是**废弃常量**。

假如在字符串常量池中存在字符串 "abc"，如果当前**没有任何 String 对象引用该字符串常量**的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。

#### 无用类

> **方法区**主要回收的是**无用的类**。但不是必然回收！

**无用类** 满足以下 3 个条件：

- 该类所有的实例都已经被回收，也就是 Java 堆中**不存在该类的任何实例**。
- **加载该类的 `ClassLoader` 已经被回收。**
- 该类对应的 `java.lang.Class` 对象**没有在任何地方被引用**，无法在任何地方通过反射访问该类的方法。

## 6、垃圾收集算法

> 常用的 GC 算法（方式）。

#### 标记-清除 算法

该算法包含 **标记** 和 **清除** 两个阶段。

1. 标记 所有不需要回收的对象；
2. 统一回收所有 未被标记 的对象。

该算法存在两个问题：

+ 效率问题
+ 空间问题：标记清除后会产生大量不连续的空间碎片。

> 这是最基础的收集算法，后续算法均对其不足进行改进。

#### 标记-复制 算法

为了**解决 效率问题**，该算法出现。

1. 首先将内存分为大小相同的两块，每次使用其中的一块；
2. 当一块内存使用完后，将存活的对象复制到另一块；
3. 清理掉使用完成的内存块。

#### 标记-整理 算法

根据**老年代**的特点提出的一种标记算法，标记过程与“标记-清除”算法一致。

但是：**不直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。**

#### 分代收集算法

> 当前虚拟机的垃圾收集都采用分代收集算法。
>
> 其实就是根据对象存活周期的不同，将内存分为几块。

一般将 java 堆分为**新生代**和**老年代**，这样我们就可以**根据各个年代的特点选择合适的垃圾收集算法**。

+ **新生代**：每次收集，都将有大量的对象死去，故可选择 **标记-复制 算法**。
+ **老年代**：对象存活几率较高，没有额外的空间对其进行分配担保，故选择 “**标记-清除**”或“**标记-整理**”算法进行垃圾收集。

> **这也是为什么要分 新生代 和 老年代 的原因之一。**

## 7、垃圾收集器

#### Serial 收集器

**Serial 收集器**（串行收集器）是最基本、历史最悠久的垃圾收集器。

**优点：**

+ 简单高效（与其他收集器的单线程相比）

**缺点：**

+ **这是一个 单线程收集器，在进行垃圾收集工作时，必须暂停其他所有的工作线程，直至收集结束。**

![image-20220801105010498](https://img.zxdmy.com/2022/202208011050864.png)

+ 新生代采用 标记-复制 算法
+ 老年代采用 标记-整理 算法

#### ParNew 收集器

**ParNew 收集器** 是 Serial 收集器的**多线程**版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。

![image-20220801105221618](https://img.zxdmy.com/2022/202208011052557.png)

+ 新生代采用 标记-复制 算法
+ 老年代采用 标记-整理 算法

> 除了 `Serial 收集器`，只有`ParNew 收集器` 能与 `CMS 收集器`（真正意义上的并发收集器）配合工作。

#### Parallel Scavenge 收集器

**Parallel Scavenge 收集器** 与 **ParNew 收集器** 几乎一样。

**Parallel Scavenge 收集器 关注点是吞吐量（高效率的利用 CPU）**：提供很多参数供用户找到最合适的停顿时间或最大吞吐量。

![image-20220801110846918](https://img.zxdmy.com/2022/202208011108941.png)

+ 新生代采用标记-复制算法
+ 老年代采用标记-整理算法

> **JDK1.8** 默认使用的是 **Parallel Scavenge** + **Parallel Old**。
>
> 如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能

#### Serial Old 收集器

**Serial 收集器的老年代版本**，是一个单线程收集器。主要有两大用途：

1. 在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用
2. 作为 CMS 收集器的后备方案

#### Parallel Old 收集器

**Parallel Scavenge 收集器的老年代版本**，使用多线程和“标记-整理”算法。

在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。

#### CMS 收集器

**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。**它非常符合在注重用户体验的应用上使用。

**CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**

**CMS 收集器** 使用 **“标记-清除”算法** 实现。

**CMS 收集器** 运作流程：

- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

![image-20220801143558892](https://img.zxdmy.com/2022/202208011436695.png)

**优点：**

+ 并发收集、低停顿

**缺点：**

- 对 CPU 资源敏感；
- 无法处理浮动垃圾；
- 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。

#### G1 收集器

**G1 (Garbage-First)** 是一款**面向服务器**的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器，以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征。

被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征，它具备以下特点：

- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- **空间整合**：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

G1 收集器的运作大致分为以下几个步骤：

- **初始标记**
- **并发标记**
- **最终标记**
- **筛选回收**

**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）

#### ZGC 收集器

与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。
