## 1、线程安全与线程死锁

### 1.1 线程安全

当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。——《Java并发编程实战》

> 什么是线程安全的？线程不安全会造成什么结果？
>
> Java 实现线程安全的方式，每一种方式的特点？

### 1.2 线程死锁

**线程死锁**：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

![image-20220801154134903](https://img.zxdmy.com/2022/202208011541635.png)

**产生死锁的四个必要条件：**

1. **互斥**条件：该资源任意一个时刻只由一个线程占用。
2. **请求与保持**条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
3. **不剥夺**条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. **循环等待**条件：若干线程之间形成一种头尾相接的循环等待资源关系。

### 1.3 线程死锁的预防和避免

**预防： 破坏死锁的产生的必要条件即可**

1. **破坏请求与保持条件** ：一次性申请所有的资源。
2. **破坏不剥夺条件** ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
3. **破坏循环等待条件** ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

**避免：借助算法对资源分配进行评估使其进入`安全状态`**

+ 比如：银行家算法

> **安全状态** 指的是系统能够按照某种线程推进顺序（P1、P2、P3.....Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称<P1、P2、P3.....Pn>序列为安全序列。

### 1.4 Java 中线程死锁问题排查

可以使用`jdk`自带的命令行工具排查：

1. 使用`jps`查找运行的`Java`进程：`jps -l`
2. 使用`jstack`查看线程堆栈信息：`jstack -l 进程id`

基本就可以看到死锁的信息。

还可以利用图形化工具，比如`JConsole`。

出现线程死锁以后，点击 `JConsole` 线程面板的检测到死锁按钮，将会看到线程的死锁信息。

## 2、多线程并发问题的根源

CPU、内存、I/O设备三者速度差异一直是 **核心矛盾** 。

据**木桶理论**，程序整体性能取决于最慢的操作-读写I/O设备，可见单方面提高CPU性能是无效的。

为了合理利用CPU的高性能，平衡三者的速度差异，计算机体系结构、操作系统、编译程序都做了努力：

- CPU增加了**缓存**，以均衡与内存的速度差异
- 操作系统增加了进程、**线程**，以及**分时复用CPU**，进而**均衡CPU与I/O设备的速度差异**
- 编译程序**优化指令执行次序**，使得缓存能够得到更加合理的利用

正是因为这三个问题，带来了多线程并发的数据一致性问题：

+ CPU 的**多级缓存**，引发 数据**可见性**（一致性）问题；
+ CPU 的**时间片轮转**，引发 数据**原子性** 问题；
+ CPU 的**指令重排**，引发 **有序性**问题。

> **多线程** 环境下的**共享变量**存在**一致性**问题。
>
> **一致性** 主要包含三大特性：**原子性**、**可见性**、**有序性**。

### 2.1 CPU 多级缓存和可见性问题

`CPU` **多级缓存**，是解决CPU和内存速度不匹配问题的方案。

随着现代半导体工艺的发展， `CPU` 已经发展到 `L1`、`L2`、`L3`级缓存，比如 **多核CPU** 的`CPU cache`结构如下图所示：

![img](https://img.zxdmy.com/2022/202209181838134.png)

其中 `L3` 缓存是**所有核心共享**的。

在**多核CPU**中，内存中的数据会在**多个核心**中存在**数据副本**，某一核心发生修改操作时，就会产生**数据不一致**的问题。

当然，**操作系统** 会采用诸如 `MESI` 等协议保证**缓存数据**的**一致性**。

### 2.2 CPU 时间片轮转和原子性问题

**原子性**指的是一个操作不可中断，即使是在**多线程** 环境下，一个操作一旦开始就不会被其他线程影响。

比如 `x=10` ，这个语句就是**原子性**的，其只有一个操作：将数字 `10` 赋值给变量 `x`。

而 `count += 1` ，就不是**原子性**的，其包含三个操作：

1. 把变量 `count` 从内存加载到 `CPU` 的寄存器；
2. 在寄存器中执行 `+1` 操作；
3. 将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。

但，`CPU` 能保证的**原子操作**，是在 CPU **指令级别**，而非 **高级语言** 的**操作符**。

所以，上面的共享变量 count，在 2 个线程同时并发执行 `count += 1` 语句时，会发生下面这种情况：

![img](https://img.zxdmy.com/2022/202209181909067.png)

即**线程A**执行了一半，CPU 时间片切换至**线程B**，完成**线程B**，又切换回**线程A**，导致最终累加的结果不正确（正确的应该是2）

### 2.3 CPU 指令重排和有序性问题

**有序性** 指的是程序按照代码的**先后顺序执行**。

而 **指令重排**，指的是 指令的执行顺序和代码的顺序不一致，但程序最终的结果与代码顺序化执行的结果相等。

从源代码到最终的执行序列，会有各种指令重排优化：

![img](https://img.zxdmy.com/2022/202209181911637.png)

在**高级语言**层面，**编译器**（`JVM`）会根据处理器特性，适当对 **机器指令进行重排序**，使机器指令能更符合CPU的执行特性，大限度的发挥机器性能。

> **指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致** 。

## 3、Java 内存模型

**Java 内存模型**（Java Memory Model， `JMM`）是在底层处理器内存模型的基础上，定义自己的**多线程语义**，是一种抽象的模型，被定义出来，屏蔽各种硬件和操作系统的内存访问差异。

`Java` 是最早尝试提供**内存模型**的编程语言。

一般来说，编程语言也可以**直接复用操作系统层面的内存模型**。但是，`Java` 语言是**跨平台**的，它**需要自己提供一套内存模型以屏蔽系统差异**。

**Java 内存模型** 抽象了**线程**和**主内存**之间的关系，就比如说 **线程之间的共享变量必须存储在主内存中**。

当前的 Java 内存模型下，线程可以把变量保存 **本地内存** （比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。

**Java 内存模型** 的抽象示意图如下：

![image-20220810111518532](https://img.zxdmy.com/2022/202208101115126.png)

> 注：**Java 内存区域 和 内存模型是完全不一样的两个东西** 。
>
> + **JVM 内存结构** 和 Java 虚拟机的运行时区域相关，比如**堆**主要用于存放对象实例；
> + **Java 内存模型** 和 Java 的**并发编程**相关，抽象了线程和主内存之间的关系，简化多线程编程，增强程序可移植性的。

**Java 内存模型** 和 **处理器内存模型**，对于**指令重排**的处理方式并不同：

+ **处理器** 通过插入内存屏障（内存栅栏）的方式来禁止特定类型的处理器重排序；
+ **编译器** 通过禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。

`JMM` 明确 **指定了一组排序规则，来保证线程间的可见性**。这一组规则被称为 `Happens-Before`。

## 4、指令重排的限制规则

### 4.1 happen-before

`happens-before` 语义的意思是：

1. 一个操作 `happens-before` 另一个操作，那第一个操作的结果将对第二个操作可见，而且第一个操作执行顺序优先于第二个操作。
2. 但是，两个操作之间存在`happens-before`关系，**并不**意味着Java平台的具体实现必须要按照`happens-before`关系指定的顺序来执行。如果重排序之后的执行结果，与按`happens-before`关系来执行的结果一致，那么这种重排序并不非法。

上述 `1` 是 `JMM` 对程序员的承诺，`2` 是`JMM` 对**编译器**和**处理器**重排序的约束原则。

`happens-before` 的规则有 `8` 条，重点的 几 条如下：

1. **单线程顺序规则** ：一个线程内，按照代码顺序，书写在前面的操作 `happens-before` 于书写在后面的操作；
2. **解锁规则** ：解锁 `happens-before` 于加锁；
3. **volatile 变量规则** ：对一个 `volatile` 变量的写操作 `happens-before` 于后面对这个 `volatile` 变量的读操作。说白了就是对 volatile 变量的写操作的结果对于发生于其后的任何操作都是可见的；
4. **传递规则** ：如果 A `happens-before` B，且 B `happens-before` C，那么 A `happens-before` C；
5. **线程启动规则** ：`Thread` 对象的 `start()` 方法 `happens-before` 于此线程的每一个动作；
6. **线程 join 规则**：一个线程内的所有动作 `happens-before` 任意其他线程在该线程 `join()` 成功返回之前。

如果两个操作不满足上述任意一个 `happens-before` 规则，那么这两个操作就没有顺序的保障，JVM 可以对这两个操作进行重排序。

### 4.2 happens-before 与 JMM 的关系

![happens-before 与 JMM 的关系](https://img.zxdmy.com/2022/202209182031660.png)

### 4.3 as-if-serial

> 在计算机中，`runtime`、**处理器**、**编译器** 都必须遵循这个规则。
>
> 这是补充的内容，主要指**单线程**。

`as-if-serial` 语义的意思是，不管编译器和处理器怎么重排序指令，**单线程程序**的执行结果不能被改变。

比如有三个 **高级语言** 层面的操作：

```java
double pi  = 3.14;    		//A
double r   = 1.0;     		//B
double area = pi * r * r; 	//C
```

A 和 C 之间、B 和 C 之间存在直接的数据依赖关系，所以在指令重排中，C 不能被 重排序 到 A、B 前面，而A 和 B 之间没有数据依赖关系，可以重排序 A 和 B 的执行顺序。如下图所示：

![img](https://img.zxdmy.com/2022/202209181944056.png)

`as-if-serial` 语义把**单线程**程序保护了起来，遵守`as-if-serial`语义的**编译器**，`runtime` 和**处理器**共同为编写单线程程序的程序员创建了一个幻觉：**单线程程序是按程序的顺序来执行的**。

`as-if-serial` 语义使单线程程序员无需担心重排序会干扰他们，也 **无需担心内存可见性问题**。

## 5、并发三特性与高级语言结构

| 一致性特性 |                      高级语言结构的实现                      |
| :--------: | :----------------------------------------------------------: |
|   原子性   | `synchronized` 、各种 `Lock` 以及各种 **原子类** 可以实现原子性 |
|   可见性   |  `synchronized` 、`volatile` 以及各种 `Lock` 可以实现可见性  |
|   有序性   |         `volatile` 关键字可以禁止指令进行重排序优化          |

反过来看：

- **volatile** ： 保证**可见性**和**有序性**（禁止代码重排）
- **synchronized** ： 保证**可见性**和**有序性**；通过**管程（Monitor）**保证一组动作的**原子性**（不保证禁止代码重排）
- **final** ： 通过禁止 **在构造函数初始化** 和 **给 final 字段赋值** 这两个动作的重排序，保证 **可见性**（如果 **this 引用逃逸** 就不好说可见性了）

> **编译器**在遇到这些关键字时，会插入相应的**内存屏障**，保证语义的正确性。

### 5.1 原子性

一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。

在 Java 中，可以借助以下方案实现原子类：

+ `synchronized`
+ 各种 `Lock`
+ `AtomicInteger` 等**原子类**

`synchronized` 和各种 `Lock` 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。

各种原子类是利用 `CAS` (compare and swap) 操作（可能也会用到 `volatile`或者`final`关键字）来保证原子操作。

### 5.2 可见性

当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。

在 Java 中，可以借助`synchronized` 、`volatile` 以及各种 `Lock` 实现可见性。

如果我们将变量声明为 `volatile` ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

### 5.3 有序性

由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。

我们上面讲重排序的时候也提到过：

> **指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致** ，所以在多线程下，指令重排序可能会导致一些问题。

在 Java 中，`volatile` 关键字可以禁止指令进行重排序优化。

### 总结

**Java 内存模型** 描述的是**多线程对共享内存修改后彼此之间的可见性**，另外，还**确保正确同步的 Java 代码可以在不同体系结构的处理器上正确运行**。

可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了**简化多线程编程，增强程序可移植性**的。

## 6、CAS

### 6.1 CAS 简介

CAS叫做CompareAndSwap，⽐较并交换，主要是通过处理器的指令来保证操作的原⼦性的。

CAS 指令包含 3 个参数：共享变量的内存地址 A、预期的值 B 和共享变量的新值C。

只有当内存中地址 A 处的值等于 B 时，才能将内存中地址 A 处的值更新为新值C。作为一条 CPU 指令，CAS 指令本身是能够保证原子性的 。

### 6.2 CAS 三大问题

CAS的经典三大问题：

+ ABA问题
+ 循环性能开销
+ 只能保证一个变量的原子操作

#### ABA 问题

并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况。此时A已经非彼A，数据即使成功修改，也可能有问题。

**解决方案**：**加版本号**

每次修改变量，都在这个变量的版本号上加1，这样，刚刚A->B->A，虽然A的值没变，但是它的版本号已经变了，再判断版本号就会发现此时的A已经被改过了。

参考乐观锁的版本号，这种做法可以给数据带上了一种实效性的检验。

Java提供了AtomicStampReference类，它的compareAndSet方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳（Stamp）标志是否等于预期标志，如果全部相等，则以原子方式将引用值和印戳标志的值更新为给定的更新值。

#### 循环性能开销

自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销。

**解决方案：添加自旋次数限制，超过指定次数停止自旋**

#### 只能保证一个变量的原子操作

CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。

**解决方案**：

+ 可以考虑改用**锁**来保证操作的原子性
+ 可以考虑**合并多个变量**，将多个变量**封装成一个对象**，通过`AtomicReference`来保证原子性。