## 1、CPU 缓存模型

**CPU Cache 缓存 的内存数据用于解决 CPU 处理速度和内存不匹配的问题**，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。

![image-20220805152854756](https://img.zxdmy.com/2022/202208051528133.png)

**CPU Cache 工作方式**：

1. 复制一份数据到 CPU Cache 中
2. 直接从 CPU Cache 中读取数据
3. 当运算完成后，将运算得到的数据写回 Main Memory 中。

> 上述工作方式存在**内存缓存不一致性的问题**：**通过制定缓存一致协议或者其他手段来解决**

## 2、Java 内存模型（JMM）

**Java 内存模型** 抽象了线程和主内存之间的关系，就比如说 **线程之间的共享变量必须存储在主内存** 中。

![image-20220805153304337](https://img.zxdmy.com/2022/202208051533910.png)

> - **主内存** ：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)
> - **本地内存** ：每个线程都有一个私有的本地内存来存储共享变量的副本，并且，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是 JMM 抽象出来的一个概念，存储了主内存中的共享变量副本。

**Java 内存区域和内存模型的区别**：

- **Java 内存区域** 定义了JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。
- **Java 内存模型** 抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中，其目的是为了屏蔽系统和硬件的差异，避免一套代码在不同的平台下产生的效果不一致。

## 3、volatile：保证变量可见性

**`volatile` 关键字可以保证变量的可见性**，如果我们将变量声明为 **`volatile`** ，这就指示 JVM，这个**变量是共享且不稳定的，每次使用它都到主存中进行读取**。

![image-20220805153458705](https://img.zxdmy.com/2022/202208051535091.png)

## 4、volatile：防止 JVM 指令重排

为了提升执行速度/性能，**计算机在执行程序代码的时候，会对指令就行重排序**，即系统在执行代码的时候并不一定是按照所写代码的顺序依次执行。

**指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致**。

**`volatile` 关键字可以防止 JVM 的指令重排序。**

即：将变量声明为 **`volatile`** ，在对这个变量进行读写操作的时候，编译器会通过 **内存屏障** 来禁止指令重排序。

> `volatile` 不能保证原子性！

> volatile 关键字，在单例模式里有什么作用