## 1、Java 对象头

> 关于 **Java 对象头** 的详细内容，请见 **JVM 篇** 的 **JVM 对象创建机制** 章节。

`synchronized` 用的锁存在`Java对象头`里。

+ 如果对象是数组类型，虚拟机用**三个字宽**来存储对象头
+ 如果对象时非数组类型，虚拟机用**两个字宽**存储对象头。

`对象头` 主要有以下三类信息：

|          内容          | 长度     | 说明                                 |
| :--------------------: | -------- | ------------------------------------ |
|       Mark Word        | 32/64bit | 存储对象的 `hashCode` 或 `锁信息` 等 |
| Class Metadata Address | 32/64bit | 存储到对象类型数据的指针             |
|      Array length      | 32/32bit | 数组的长度（如果当前对象是数组）     |

`对象头` 里的 `Mark Word` 里默认存储对象的`HashCode`、`分代年龄`和`锁标位`。

比如`32`位JVM的`Mark Word`的默认存储结构如下表：

|  锁状态  |     25bit      |      4bit      | 1bit是否是偏向锁 | 2bit锁标志位 |
| :------: | :------------: | :------------: | :--------------: | :----------: |
| 无锁状态 | 对象的hashCode | 对象的分代年龄 |        0         |      01      |

在运行期间，`Mark Word`里存储的数据会随着锁标志位的变化而变化。

`Mark Word` 可能变化为存储以下四种数据：

![image-20220905142934320](https://img.zxdmy.com/2022/202209051429822.png)

在 `64` 位虚拟机下，`Mark Word` 是 `64bit` 大小的，其存储结构为：

![image-20220905143058600](https://img.zxdmy.com/2022/202209051430795.png)

详细示意图如下：

![image-20221007194602142](https://img.zxdmy.com/2022/202210071946507.png)

将上面两个表整合一下：

![image-20220905143112072](https://img.zxdmy.com/2022/202209051431162.png)

我们可以提取一下最后3个bit代表的数值

| 二进制数值 | 十进制数值 |  锁状态  |         其余部分储存信息         |
| :--------: | :--------: | :------: | :------------------------------: |
|     10     |     2      | 重量级锁 |        指向重量级锁的指针        |
|     00     |     0      | 轻量级锁 |      指向Lock Record的指针       |
|   `1`01    |     5      |  偏向锁  | 线程ID，偏向时间戳，对象分代年龄 |
|   `0`01    |     1      |   无锁   |                无                |
|     11     |     3      |  GC标记  |                无                |

## 2、锁的种类

### 2.1 锁的种类

![image-20220905114453053](https://img.zxdmy.com/2022/202209051144485.png)

`Java SE1.6` 为了减少`获得锁`和`释放锁`带来的性能消耗，引入了“**偏向锁**”和“**轻量级锁**”。

在Java SE1.6中，锁一共有 `4` 种状态，**级别从低到高**依次是：

+ 无锁状态
+ 偏向锁状态
+ 轻量级锁状态
+ 重量级锁状态

这几个状态会随着竞争情况逐渐升级。

**锁可以升级但不能降级**，意味着偏向锁升级为轻量级锁之后不能降级为偏向锁。

这种**锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率**。

|    锁    |                             优点                             |                      缺点                      |              适用场景              |
| :------: | :----------------------------------------------------------: | :--------------------------------------------: | :--------------------------------: |
|  偏向锁  | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 |  适用于只有一个线程访问同步块场景  |
| 轻量级锁 |           竞争的线程不会阻塞，提高了程序的响应速度           | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU  | 追求响应时间，同步块执行速度非常快 |
| 重量级锁 |               线程竞争不使用自旋，不会消耗CPU                |             线程阻塞，响应时间缓慢             |   追求吞吐量，同步块执行速度较长   |

### 2.2 偏向锁状态

> 在无竞争的情况下，只是在Mark Word里存储当前线程指针，CAS操作都不做。

大多数情况下，锁不仅**不存在多线程竞争**，而且**总是由同一个线程多次获得**，为了让线程获得锁的代价更低而引入了**偏向锁**。

当一个线程访问同步块并获取锁时，会在**对象头**和**栈帧中的锁记录**里**存储偏向的线程ID**，以后该线程在进入和退出同步块时**不需要**进行`CAS`操作来加锁和解锁，只要简单地测试一下对象头的`Mark Word`里是否存储着指向当前线程的偏向锁：

+ 测试成功：表示线程已经获得了锁；
+ 测试失败：则需要再测试一下Mark Word中偏向锁的标识是否设置为1（标识当前是偏向锁）
  + 没有设置：使用CAS竞争锁，
  + 设置了：尝试使用CAS将对象头的偏向锁指向当前线程。

#### 偏向锁的获取

1. 判断**是否为可偏向状态**：`MarkWord`中**锁标志**是否为`01`，**偏向锁**是否为 `1`
2. 如果是**可偏向状态**，则查看线程ID是否为当前线程：
  1. 是当前线程，则进入步骤 `5`
  2. 不是当前线程，进入步骤 `3`
3. 通过`CAS`操作竞争锁：
  1. 竞争成功，则将`MarkWord` 中 **线程ID** 设置为 **当前线程ID**，然后执行 `5`；
  2. 竞争失败，则执行 `4`
4. `CAS`获取偏向锁失败表示有竞争：当达到`safepoint`时**获得偏向锁的线程被挂起**，**偏向锁升级为轻量级锁**，然后被阻塞在安全点的线程继续往下执行同步代码块。
5. 执行同步代码。

> safepoint：安全点，即某一个时间点上没有正在执行的字节码。

#### 偏向锁的撤销

**偏向锁**使用了一种**等到竞争出现才释放锁**的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。

偏向锁的撤销，需要等待**全局安全点**，也就是某一个时间点上没有正在执行的字节码。

持有偏向锁的线程 `T` 撤销锁有两种情况：

1. 撤销：持有偏向锁的线程 `T` 已经退出同步代码块，或该线程不处于活动状态，则直接撤销偏向锁，将对象头设置为无锁状态（该状态达到阈值20则执行批量重偏向）
2. 升级：持有偏向锁的线程 `T` 还存活，并且还在同步代码块中，则将线程 `T` 的**偏向锁**，**升级**为 **轻量级锁**，当前线程执行轻量级锁状态下的锁获取步骤。（该状态达到阈值40则执行批量撤销）

#### 偏向锁的线程ID和HashCode的冲突问题

当对象进入偏向锁状态的时候，Mark Word大部分的空间（23个比特）都用于存储持有锁的线程ID了，这部分空间占用了原来存储对象哈希码的位置。

在Java语言里面一个对象如果计算过哈希码，那就应该保持该值不变（强烈推荐但不强制，因为用户可以重载HashCode()方法按自己的意愿返回哈希码），否则很多依赖对象哈希码的API都可能存在出错风险。而且作为绝大多数对象哈希码来源的Object::hashCode()方法，返回的是对象的一致性哈希码（Identity Hash Code），这个值能强制保持不变的，它通过在对象头中存储计算结果来保证第一次计算后，再次调用该方法渠道的哈希码值永远不会再发生改变。因此，当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了，而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁的视线中，对象头指向了重量级的位置，代表重量级锁的ObjectMonitor类里面有字段可以记录非加锁状态（标志位为“01”）下的Mark Work，其中自然可以存储原来的哈希码。

### 2.3 轻量级锁状态

轻量级锁是JDK6时加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就被称之为“重量级”锁。

不过，需要强调一点，轻量级锁并不是用来代替重量级锁的，它设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

如果没有竞争，**轻量级锁便通过`CAS`操作成功避免了使用互斥量的开销**；

但如果**存在锁竞争**，除了**互斥量**的本身的开销外，还额外发生了`CAS`操作的开销。

因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。

#### 轻量级锁的获取

轻量级锁的获取，主要有以下几步：

1. 进行加锁操作时，`jvm`会判断是否已经是**重量级锁**：
  1. 如果不是，则会在当前线程栈帧中划出一块空间，作为该锁的锁记录，并且将锁对象`MarkWord`复制到该锁记录中
2. 复制成功之后，`jvm`使用`CAS`操作将**对象头**`MarkWord`**更新**为**指向锁记录的指针**，并将锁记录里的`owner`指针指向对象头的`MarkWord`：
  1. 更新成功：则当前线程持有该对象锁，并且对象MarkWord锁标志设置为‘00’，即表示此对象处于轻量级锁状态
  2. 更新失败：`jvm`先检查对象`MarkWord`**是否**指向当前线程栈帧中的锁记录：
    1. 如果是，表示**锁重入**；然后当前线程栈帧中增加一个锁记录第一部分（Displaced Mark
       Word）为null，并指向`Mark Word`的锁对象，起到一个重入计数器的作用。
    2. 否则，表示该锁对象已经被其他线程抢占，则进行**自旋等待**（默认10次），等待次数达到阈值仍未获取到锁，则升级为 **重量级锁**

### 2.4 锁升级完整过程

大体的升级过程：

![image-20221007201032177](https://img.zxdmy.com/2022/202210072010364.png)

完整的升级过程：

![image-20221007201839026](https://img.zxdmy.com/2022/202210072018227.png)

## 3、锁的优化

高效并发是从`JDK5`到`JDK6`后一项重要的改进项，HotSpot虚拟机开发团队在这个版本上花费了大量的资源去实现各种锁优化技术，比如增加了前文的`轻量级锁`（Lightweight Locking）、`偏向锁`（Biased Locking），以及采用`适应性自旋`（Adaptive Spining）、`锁消除`（Lock Elimination）、`锁膨胀`（Lock Coarsening）等优化策略，更高效地共享数据以及解决竞争问题，从而提高程序的执行效率。

#### 自旋锁和自适应自旋

> 在 **轻量级锁** 升级为 **重量级锁** 时，就使用了 **自旋加锁** 的方式.

在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。并且当前的物理机通常有多个处理器或处理核心，能够让多个线程并发执行。

当有新的线程请求锁时，可以在**不放弃处理器执行时间的同时，让线程通过执行一个忙循环（自旋）进行等待，以观察是否当前持有锁的线程很快释放锁**。

这种技术就是所谓的 **自旋锁**。

自旋等待，并非线程的阻塞，自旋过程是需要占用CPU时间的，其目的是 **为了避免线程切换的开销**。

当锁被长时间占用时，为了避免请求锁的线程长时间自旋，需要对自旋等待时间进行限制，即如果超过限定次数仍没有获取到锁，则应通过传统方式去挂起线程。

自旋的次数默认值为10次，用户也可以使用参数`-XX:PreBlockSpin`来自行更改。

JDK6 对 **自旋锁** 进一步优化，引入了 **自适应自旋**。

自适应自旋的自旋等待时间不是固定的，而是由前一次在同一个锁上的自选时间以及锁的拥有者的状态来决定的：

+ 如果在同一个加锁的对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的使时间。
+ 如果对于某个锁，自旋很少成功获得锁，那在以后要获取这个锁时，将有可能直接省略掉自旋过程，以避免浪费处理器资源。

#### 锁消除

**锁消除**是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到**不可能存在共享数据竞争的锁进行消除**。

锁消除的主要判断依据来源于逃逸分析的数据支持，如果判断到一段代码中，在**堆上的所有数据都不会逃逸出去被其他线程访问**到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。

比如：

```java
public String concatString(String s1, String s2, String s3){
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}
```

每个 `StringBuffer.append()` 方法中都有一个同步块，锁就是sb对象，虚拟机观察变量sb，经过逃逸分析后会发现它的 **动态作用域** 被限制在 `concatString()` 方法内部。也就是 **sb的所有引用都永远不会逃逸到concatString()方法之外，其他线程无法访问到它，所有这里虽然有锁，但是可以被安全得消除掉**，在解释执行时这里仍然会加锁，但是经过服务器端编译器的即时编译之后，这段代码就会忽略所有的同步措施而直接执行。

#### 锁粗化

**原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小** ——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁

大多数情况下，上面的原则都是正确的，但是 **如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗**。

如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部.

上面的代码所示连续的 `append()` 方法就属于这类情况，扩展到第一个append()操作之前直至最后一个append()操作之后，这样只需要加锁一次就可以了。

#### 锁膨胀

**锁膨胀** 也称为 **锁升级**，并不同于锁粗化。

锁粗化是指锁同步范围的扩大，而 **锁膨胀是指锁类型升级为更加重量级的锁**。

Java中的锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁、重量级锁。

这几个状态会随着竞争情况逐渐升级，锁可以升级但不能降级，意味着偏向锁升级为轻量级锁后不能降级为偏向锁。**这种锁升级却不能降级的策略，目的是提高获得锁和释放锁的效率**。

锁升级过程可以简单理解为，**每个对象起始状态都是最低级，但随着线程竞争的发生，这个对象的锁等级会一步一步提高，最终到达重量级锁**。因为JDK6以后默认开启偏向锁，所以可以认为每个对象的初始状态都是偏向锁。

![image-20220905114440565](https://img.zxdmy.com/2022/202209051144004.png)

