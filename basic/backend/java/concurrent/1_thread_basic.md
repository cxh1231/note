## 1、并发与并行

**并发**（`Concurrent`）：在操作系统中，指的是一个时间段内，有多个程序都处于已启动运行到运行完毕之间的状态，且这几个程序都是在同一个处理机上运行。

在单CPU的计算机中，**并发** 是通过 **CPU时间片** 技术实现的。由于计算机的处理速度很快，时间片间隔适当，中间的停顿，用户察觉不出来。

> 详细的**时间片轮转**技术，请见**操作系统**部分。

**并行**（`Parallel`）：当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行（Parallel）。

![image-20220905101412957](https://img.zxdmy.com/2022/202209051014777.png)

`并发`是两个队伍交替使用一台咖啡机。`并行`是两个队伍同时使用两台咖啡机。

映射到计算机系统中，上图中的咖啡机就是`CPU`，两个队伍指的就是两个`进程`。

## 2、线程与进程

> **进程是资源分配的基本单元，线程是执行的基本单元，同一个进程的多个线程之间共享资源**。

#### 进程

**进程** 是程序的一次执行过程，是系统运行程序的基本单位，进程是动态的。

系统运行一个程序即是一个进程从创建，运行到消亡的过程。

在 Java 中，当我们启动 `main 函数`时其实就是启动了一个 `JVM 的进程`，而 `main 函数所在的线程`就是这个进程中的一个线程，也称`主线程`。

#### 线程

线程与进程相似，但**线程**是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。

与进程不同的是，同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**。

所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

> **一个 Java 程序是 main 线程和多个其他线程同时运行。**

> 问：从 JVM 角度说进程和线程之间的关系（详见JVM部分）

#### 线程的特点

> 详细内容见 操作系统 章节。

线程主要有以下特点：

+ 轻型实体
+ 独立调度和分配的基本单位
+ 可并发执行
+ 共享进程资源

## 3、线程的底层实现

主流的 **操作系统** 都提供了线程实现，实现线程主要有`3`种方式：

+ 使用**内核线程**实现（1:1 实现）（JDK 1.3及之后版本采用的方案）
+ 使用**用户线程**实现（1:N 实现）
+ 使用 **用户线程加轻量级进程** 混合实现（N:M 实现）

> 关于这三种实现方式的详解，请见**操作系统**章节。

`Java` **线程** 在`JDK 1.2` 及之前，是基于称为“绿色线程”（Green Threads）的 **用户线程** 实现的

在JDK 1.3 及之后，**大部分** 的Java 线程模型替换为 **基于操作系统原生线程模型** （即内核线程）来实现。

> 通俗来说，`JVM` 中的一个 **线程**，对应于一个 **操作系统内核线程**，1:1 实现。

`Java` 中，执行 `java.lang.Thread` 类的实例的 `start()` 方法即 **创建一个线程**，采用这种方式提供了在不同硬件和操作系统平台下对线程操作的统一处理。

此外，`Thread`类与大部分的Java API有显著的差别，它的所有 **关键方法** 都声明为`Native` 。

一个`Native`方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现（当然也可能是为了执行效率而使用`Native`方法，不过，通常最高效率的手段也就是平台相关的手段）。

---

补充知识：

因此，在目前的JDK版本中，操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射的，这点在不同的平台上没有办法达成一致，虚拟机规范中也并未限定Java线程需要使用哪种线程模型来实现。线程模型只对线程的并发规模和操作成本产生影响，对Java程序的编码和运行过程来说，这些差异都是透明的。

对于Sun JDK来说，它的Windows版与Linux版都是使用一对一的线程模型实现的，一条Java线程就映射到一条轻量级进程之中，因为Windows和Linux系统提供的线程模型就是一对一的。

而在Solaris平台中，由于操作系统的线程特性可以同时支持一对一（通过Bound Threads或Alternate Libthread实现）及多对多（通过LWP/Thread Based Synchronization实现）的线程模型，因此在Solaris版的JDK中也对应提供了两个平台专有的虚拟机参数：-XX：+UseLWPSynchronization（默认值）和-XX：+UseBoundThreads来明确指定虚拟机使用哪种线程模型。

(参考：深入理解Java虚拟机）

## 4、线程状态与生命周期

> java 程序中止了之后，线程还会继续运行吗？

### 4.1 线程 6 种状态

**线程在给定的时间点只能处于一种状态**。这些状态是虚拟机状态，不反映任何操作系统线程状态。

Java 线程在运行的生命周期中的指定时刻只可能处于下面 **6 种不同状态**的其中一个状态：

1. `NEW`：新建但是尚未启动的线程处于此状态，没有调用 start() 方法。
2. `RUNNABLE`：包含就绪（READY）和运行中（RUNNING）两种状态。线程调用 start() 方法会会进入就绪（READY）状态，等待获取 CPU 时间片。如果成功获取到 CPU 时间片，则会进入运行中（RUNNING）状态。
3. `BLOCKED`：线程在进入同步方法/同步块（synchronized）时被阻塞，等待同步锁的线程处于此状态。
4. `WAITING`：无限期等待另一个线程执行特定操作的线程处于此状态，需要被显示的唤醒，否则会一直等待下去。例如对于 Object.wait()，需要等待另一个线程执行 Object.notify() 或 Object.notifyAll()；对于 Thread.join()，则需要等待指定的线程终止。
5. `TIMED_WAITING`：在指定的时间内等待另一个线程执行某项操作的线程处于此状态。跟 WAITING 类似，区别在于该状态有超时时间参数，在超时时间到了后会自动唤醒，避免了无期限的等待。
6. `TERMINATED`：执行完毕已经退出的线程处于此状态。

![image-20220727203523157](https://img.zxdmy.com/2022/202207272035303.png)

### 4.2 线程生命周期

**线程在生命周期**是**随着代码的执行在不同状态之间切换**。

Java 线程状态变迁如下图所示：

![image-20220727203711300](https://img.zxdmy.com/2022/202207272037213.png)

### 4.3 上下文切换

**线程在执行过程中会有自己的运行条件和状态（也称上下文）。**

当出现如下情况的时候，线程会从占用 CPU 状态中退出：

- **主动让出 CPU**，比如调用了 `sleep()`, `wait()` 等。
- **时间片用完**，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。
- 调用了阻塞类型的**系统中断**，比如请求 IO，线程被阻塞。
- **被终止或结束**运行

> 前三种都会发生**线程切换**，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候**恢复现场**，并加载下一个将要占用 CPU 的**线程上下文**。

### 4.4 线程终止（死亡）的 3 种方式

1. **正常结束**：`run()` 或者 `call()` 方法执行完成后，线程正常结束；
2. **异常结束**：线程抛出一个未捕获的 `Exception` 或 `Error`，导致线程异常结束；
3. **调用 stop()**：直接调用线程的 `stop()` 方法来结束该线程，但是一般不推荐使用该种方式，**因为该方法通常容易导致死锁**。

## 5、线程调度模型与线程优先级

### 5.1 Java 线程调度模型

在Java的多线程程序中，为**保证所有线程能按照一定的规则执行**，JVM实现了一个线程调度器，它定义了**线程调度模型**，对于CPU运算的分配都进行了规定，按照这些特定的机制为多个线程分配CPU的使用权。

主要有两种调度模型：**协同式线程调度** 和 **抢占式调度模型**。

#### 协同式线程调度

> 下一个执行的线程，由当前线程主动通知。

**协同式调度**的多线程系统，**线程的执行时间由线程本身来控制**，线程把自己的工作执行完了之后，要**主动通知系统切换到另外一个线程上**。

协同式多线程的最大好处是实现**简单**，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以**没有线程同步的问题**。

#### 抢占式调度模型

> 下一个线程的执行，系统根据优先级选择。（JVM 采用这种方式）

**抢占式调度**的多线程系统，那么每个线程将**由系统来分配执行时间**，线程的切换不由线程本身来决定。

在这种实现线程调度的方式下，**线程的执行时间是系统可控的**，也不会有一个线程导致整个进程阻塞的问题。

系统会让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。

处于运行状态的线程会一直运行，直至它不得不放弃CPU。

**Java 虚拟机采用抢占式调度模型。**

虽然Java线程调度是系统自动完成的，但是我们还是可以“建议”系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点——这项操作可以通过设置线程优先级来完成。

Java语言一共设置了10个级别的线程优先级（`Thread.MIN_PRIORITY`至`Thread.MAX_PRIORITY`），在两个线程同时处于`Ready`状态时，优先级越高的线程越容易被系统选择执行。

不过，线程优先级并不是太靠谱，原因是Java的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统，虽然现在很多操作系统都提供线程优先级的概念，但是并不见得能与Java线程的优先级一一对应。

### 5.2 线程优先级

Java语言一共设置了`10`个级别的**线程优先级**（`Thread.MIN_PRIORITY`至`Thread.MAX_PRIORITY`），在两个线程同时处于`Ready`状态时，**优先级越高的线程越容易被系统选择执行**。

Java 线程优先级使用 `1 ~ 10` 的整数表示。**默认的优先级是5**。

```java
最低优先级 1：Thread.MIN_PRIORITY
普通优先级 5：Thread.NORM_PRIORITY
最高优先级 10：Thread.MAX_PRIORITY
```

在Java中，可以使用 `Thread` 类的`setPriority()`方法 **为线程设置新的优先级**。

`getPriority()`方法返回线程的当前优先级。

当创建一个线程时，其默认优先级是创建该线程的线程的优先级。

```java
public class Main {

    public static void main(String[] args) {
        Thread t = Thread.currentThread();
        System.out.println("Main Thread  Priority:" + t.getPriority());
        // Main Thread  Priority:5

        Thread t1 = new Thread();
        System.out.println("Thread(t1) Priority:" + t1.getPriority());
        // Thread(t1) Priority:5

        t1.setPriority(Thread.MAX_PRIORITY - 1);
        System.out.println("Thread(t1) Priority:" + t1.getPriority());
        // Thread(t1) Priority:9
    }
}
```

## 6、守护线程

在 `Java` 中有两类线程：`User Thread`（用户线程）、`Daemon Thread`（守护线程）：

+ **用户线程** 一般用户执行用户级任务，
+ **守护线程** 也就是“后台线程”，一般用来执行后台任务，守护线程最典型的应用就是`GC`(垃圾回收器)。

**Java虚拟机** 在所有“**用户线程**”都结束后就会退出。

可以使用`setDaemon()` 方法通过传递 `true` 作为参数，使线程成为一个**守护线程**。

必须在启动线程之**前**调用一个线程的 `setDaemon()`方法，否则会抛出异常`java.lang.IllegalThreadStateException`。

**守护线程** 是运行在后台的一种特殊进程，其独立于控制终端，并且周期性地执行某种任务或等待处理某些发生的事件。

在 Java 中 **垃圾回收线程** 就是特殊的**守护线程**。

## 7、Java 中的线程通信方式

1. `volatile` 和 `synchronized` 关键字
2. 等待/通知机制：Java内置的等待/通知机制（`wait()/notify()`）实现线程间的感知
3. 管道输入/输出流：`PipedOutputStream`、`PipedInputStream`、 `PipedReader`和`PipedWriter`，前两种面向字节，而后两种面向字符。
4. 使用`Thread.join()`
5. 使用线程变量 `ThreadLocal`