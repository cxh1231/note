## 1、Java 集合类概述

Java **集合** 相关的类和接口，都在 `java.util` 包中，主要由 `Collection` 和 `Map` 两大**接口**派生而来。

这两大接口派生的各个接口和实现类，如下图所示。

![image-20220725101728777](https://img.zxdmy.com/2022/202207251017896.png)

![image-20220727155557946](https://img.zxdmy.com/2022/202207271556212.png)

`Collection` 表示**集合**（类似数组），主要用于存放单一元素，其实现类主要有：

+ `List`  表示**列表**（顺序），其存储的元素有序、可重复；
+ `Queue` 表示**队列**（排队），其存储的元素有序、可重复；
    + Deque 表示 双端队列
+ `Set`  表示**集合**（独一无二），其存储的元素无序、不可重复；
    + Sorted 有序集合

`Map` 表示**映射**，主要用于存放键值对，其实现类主要有：

+ `Map` 的 key 是无序、不可重复的，value 是无序、可重复的， key 与value 一一对应。

## 2、List 系列

`List` 接口 实现自 `Collection` 接口，实现类主要有以下四个：

|       类       |     简介     |   线程   | null | 底层数据结构（实现）                               |
| :------------: | :----------: | :------: | :--: | -------------------------------------------------- |
|     Vector     |   动态数组   | **安全** |  Y   | `Object[]` 数组，很少使用                          |
|     Stack      | 栈，先进后出 | **安全** |  Y   | `Object[]` 数组 + 游标计数器，继承自`Vector`       |
| **ArrayList**  |   动态数组   |  不安全  |  Y   | `Object[]` 数组                                    |
| **LinkedList** |   双向链表   |  不安全  |  Y   | **双向链表**（JDK1.6 为循环链表，JDK1.7 取消循环） |

其中重要的主要是 `ArrayList` 和 `LinkedList`。

### 2.1 ArrayList vs. LinkedList

`ArrayList` 与 `LinkedList` 的异同如下表所示。

|          |                    ArrayList                    |                 LinkedList                 |
| :------: | :---------------------------------------------: | :----------------------------------------: |
| 数据结构 |                    基于数组                     |                基于双向链表                |
|   查找   |     **支持快速随机访问**，基于下标，`O(1)`      |         遍历链表才能查找， `O(n)`          |
|   增删   | **增删** 受元素位置影响，需**移动**元素，`O(n)` | 方便增删（平均步长），无需移动元素，`O(n)` |
| 随机访问 |                      支持                       |                   不支持                   |
| 内存占用 |      数组，**内存空间连续**，末尾预留数组       | **内存空间不连续**，前驱和后继占用额外消耗 |

### 2.2 ArrayList 扩容机制

首先 `ArrayList` 具有如下一些性质（ >JDK6）：

+ 使用**无参数构造方法**创建 `ArrayList` 时，初始化赋值为一个 **空数组**；
+ 向数组中添加第一个元素时，才分配容量，即容量扩为 **初始默认容量** `10`；
+ 默认最大容量为 `MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8`；
+ 最大容量为 `Integer.MAX_VALUE`

`ArrayList`是基于数组的集合，数组的容量是在定义的时候确定的，如果数组满了，再插入，会溢出。

其 **扩容机制** 如下：

1. 新添加元素前，调用 `ensureCapacityInternal()` 方法，进行判断是否需要扩容；
2. 将新容量 `new` 扩充为原来的 `1.5` 倍，即 `new = old + (old >> 1)`；
3. 如果新容量 `new` 小于 最小需要容量 `min`，则 `new = min`；
4. 如果新容量 `new` 大于 `MAX_ARRAY_SIZE` ，则 `new = Integer.MAX_VALUE`。

### 2.3 ArrayList 序列化



### 2.4 ArrayList 线程安全

保证`ArrayList`的线程安全可以采用如下解决方案：

+ 使用 Vector 代替 ArrayList。（不推荐，Vector是一个历史遗留类）
+ 使用 `Collections.synchronizedList` 包装 `ArrayList`，然后操作包装后的 list。
+ 使用 `CopyOnWriteArrayList` 代替 `ArrayList`。
+ 在使用 `ArrayList` 时，应用程序通过**同步机制**去控制 ArrayList 的读写。

### 2.5 CopyOnWriteArrayList

`CopyOnWriteArrayList` 是 **线程安全** 版本的 `ArrayList`，其名字 **写时复制** 就明示了其原理。

`CopyOnWriteArrayList` 采用 **读写分离** 的并发策略：

+ **读** 操作：无锁，性能较高；
+ **写** 操作：首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。

![image-20220914153943751](https://img.zxdmy.com/2022/202209141539747.png)

## 3、Map 系列

实现 `Map` 接口的**实现类**，主要有以下几个：

|      类       |     简介     |   线程   | null  | 实现                                                         |
| :-----------: | :----------: | :------: | :---: | ------------------------------------------------------------ |
|    HashMap    |   无序映射   |  不安全  |   Y   | 长度 < 8：数组 + 链表（链表散列）<br/>长度 >= 8 ：数组 + 链表 \| 红黑树 |
| LinkedHashMap | **有序**映射 |  不安全  |   Y   | 数组 + 链表 \| 红黑树；双向链表                              |
|   Hashtable   |   无序映射   | **安全** | **N** | 数组 + 链表                                                  |
|    TreeMap    | **有序**映射 |  不安全  | **N** | 红黑树（自平衡的排序二叉树）                                 |

其中最重要的是 `HashMap`，其用处很广，比如 HashSet 底层的一些方法，也是直接调用 HashMap 的。

### 3.1 HashMap 的数据结构

`JDK1.7` 的数据结构是 **数组** + **链表**，

`JDK1.8` 的数据结构是 **数组** + **链表**+ **红黑树**。

其中，**数组** 用来 **存储数据元素**，**链表** 用来 **解决冲突**，**红黑树** 用来 **提高查询效率**。

结构示意图如下：

![image-20220914115848832](https://img.zxdmy.com/2022/202209141158932.png)

对于 `HashMap`，有几个关键点如下：

+ 数据元素通过映射关系，也就是散列函数，映射到**桶数组**对应索引的位置；
+ 如果发生冲突，从冲突的位置拉一个**链表**，插入冲突的元素；
+ 如果**链表长度**`>8`，并且**数组大小**`>=64`，**链表**将转为**红黑树**；
+ 如果**红黑树**节点个数 `<6` ，转为**链表**。

![image-20220727142139825](https://img.zxdmy.com/2022/202207271421976.png)

> **问：链表转红黑树的阈值，为什么是 `8`** ？
>
> 其实源码的注释部分已经给出答案了。
>
> 如果 `hashCode` 的分布离散良好的话，那么 **红黑树** 是很少会被用到的，因为各个值都均匀分布，很少出现链表很长的情况。
>
> 将链表的阈值设置为 8 ，与统计学有关，即链表长度 **泊松分布**，各个长度的命中率依次递减，比如节点`0`的命中率为`0.606`，而节点`8`的命中率为`0.00000006`，这么小的概率，几乎不会发生链表转红黑树的情况。
>
> 当然，这是理想情况，实际情况可能用户重写了`hashCode`，导致很多的**哈希冲突**，进而链表很长，这就需要转换为红黑树。

> **问：链表转红黑树的阈值，为什么是 `64`**？
>
> 源码中给出的大小，至少应为 `32`（即`4*8`），以避免**调整数组大小**和 **树化链表** 的**阈值**之间的冲突。

> **问：红黑树转链表的阈值，为什么是 `6`** ？
>
> 如果这个阈值也设置成 `8`，假如发生碰撞，节点增减刚好在 `8` 附近，会发生链表和红黑树的不断转换，导致资源浪费。

### 3.2 HashMap 引入红黑树的原因

**红黑树**本质上是一种**二叉查找树**，为了保持平衡，它又在二叉查找树的基础上增加了一些**规则**：

+ 每个节点要么是红色，要么是黑色；
+ 根节点永远是黑色的；
+ 所有的叶子节点都是是黑色的（注意这里说叶子节点其实是图中的 NULL 节点）；
+ 每个红色节点的两个子节点一定都是黑色；
+ 从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。

红黑树为了保持上面的这些规则，通常采用 **修改颜色**（颜色反转）和 **旋转节点**（左旋转、右旋转）来保持平衡。

![image-20220914154543099](https://img.zxdmy.com/2022/202209141545185.png)

#### 不使用二叉树，因为：

**红黑树**是一种 **平衡的二叉树**，插入、删除、查找的最坏时间复杂度都为 `O(logn)`，避免了**二叉树**最坏情况下的`O(n)`时间复杂度。

#### 不使用平衡二叉树，因为：

**平衡二叉树**是比**红黑树**更严格的平衡树，为了保持保持平衡，**需要旋转的次数更多**，也就是说平衡二叉树保持平衡的效率更低，所以**平衡二叉树插入和删除的效率比红黑树要低**。

### 3.2 HashMap 的哈希值计算

在 `java.util` 包的 `HashMap` 类中，根据 `key` 计算 `hash` 值方法如下：

```java
static final int hash(Object key) {
    int h;
    // 采用【扰动方法】计算 hash（ ^ ：按位异或；>>>：无符号右移）
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

然后在 `put` 方法中，根据此 `hash` 值，与 **数组长度-1** `n-1` 取模，计算下标

![image-20220914165743779](https://img.zxdmy.com/2022/202209141657058.png)

具体流程如下：

1. 调用 `key` 的 `hashCode()` 方法，获取其 `hashcode`；
2. 调用 `HashMap` 的 `hash()` 方法，对 `hashcode` 进行扰动计算 `hash` 值（以减少哈希碰撞）；
3. 通过 `取模` 计算下标。

上述计算过程中的 `取模计算` 方法如下：

```java
// 取模计算（注意，这里使用的是 与 的形式，等同于 hash % length）
hash & (length - 1)
```

下图详细描述了数组长度为 `16` 的 `HashMap` ，使用 **扰动函数** 计算**数组下标** 的过程：

![image-20220727143911762](https://img.zxdmy.com/2022/202207271439277.png)

采用**扰动函数**的主要目的是：将原始`hashCode` 的**高半区**和**低半区**做**异或**，混合原始`hashCode`的高位和低位，进而**加大低位的随机性，同时变相保留高位的信息**。

> **问：为什么 hash 值要与 length-1 `相与`，而不是`取模`？**
>
> 答：一方面模运算没有**位运算快**，另一方面 **数组长度** 总是 `2` 的幂次方，`hash & (length-1)` 运算等价于 `hash % length`，但是 `&` 比 `%` 具有更高的效率。

> **问：JDK1.8 为什么要 `hashcode` 异或其右移十六位的值？**
>
> 答：因为在JDK 1.7 中扰动了 4 次，计算 hash 值的性能会稍差一点点。 从速度、功效、质量来考虑，JDK1.8 优化了高位运算的算法。这么做可以在数组 table 的 length 比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。

> **问：一般用什么作为 HashMap 的 key？**
>
> 答：一般用`Integer`、`String` 这种不可变类作为 `key`，而 `String` 最为常用，详细原因如下：
>
> + 因为字符串是不可变的，所以在它创建的时候 `hashcode` 就被缓存了，不需要重新计算。
> + 因为获取对象的时候要用到 `equals()` 和 `hashCode()` 方法，这些类已经很规范的重写了 `hashCode()` 以及 `equals()` 方法。

> **问：用可变类当 HashMap 的 key 有什么问题？**
>
> 答：可变类的 hashcode 可能发生改变，导致 put 进去的值，无法 get 出。

### 3.3 HashMap 的初始化

`HashMap` 的数组长度，始终是 `2` 的倍数。

其容量初始化方法如下：

![image-20220915170357358](https://img.zxdmy.com/2022/202209151703498.png)

如果**传入的值**，不是 `2` 的倍数，则会向上取值，选择**距离传入值最近的 2 的倍数的值**。

比如传入的是 `17` ，则其容量确定过程为：

![image-20220915170432546](https://img.zxdmy.com/2022/202209151704065.png)

> **问：HashMap 数组的长度为什么是 2 的幂次方？**
>
> 答：这样做效果上等同于取模，在速度、效率上比直接取模要快得多。除此之外，2 的 N 次幂有助于减少碰撞的几率。

### 3.4 HashMap 的 put 流程

流程图如下：

![image-20220914162647898](https://img.zxdmy.com/2022/202209141626030.png)

流程概述：

1. 首先根据 `key` 的值计算 `hash` 值，找到该元素在数组中存储的`下标（索引值）`；
2. 如果数组是空的，则调用 `resize` 进行初始化；
3. 如果没有哈希冲突直接放在对应的数组下标里；
4. 如果冲突了，且 `key` 已经存在，就覆盖掉 `value`；
5. 如果冲突后，发现该节点是**红黑树**，就将这个节点挂在树上；
6. 如果冲突后是**链表**，判断该链表是否大于 `8` ，如果大于 `8` 并且数组容量小于 `64`，就进行扩容；如果链表节点大于 `8` 并且数组的容量大于 `64`，则将这个结构转换为**红黑树**；否则，链表插入键值对，若 `key` 存在，就覆盖掉 `value`。

> **问：JDK1.7 和 1.8 的 put 方法区别是什么？**
>
> 答：解决哈希冲突时，JDK1.7 只使用链表，JDK1.8 使用链表+红黑树，当满足一定条件，链表会转换为红黑树。
>
> 链表插入元素时，JDK1.7 使用头插法插入元素，在多线程的环境下有可能导致环形链表的出现，扩容的时候会导致死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了，但JDK1.8 的 HashMap 仍然是线程不安全的。

### 3.5 HashMap 的 get 流程

流程图如下：

![image-20220914170523565](https://img.zxdmy.com/2022/202209141705984.png)

流程概述：

1. 根据传入的 `key` ，通过**扰动函数**计算 `hash`，并求**索引值**；
2. 如果：数组为空 | 数组长度为 0 | 当前索引位置的第一个元素为 `null`，则返回 `null`，结束。
3. 否则：
    1. 如果：数组节点 的 `hash` 值和 `key` 均为所求，则返回该数组节点上的 `value`，结束。
    2. 如果：数组节点 不是所求，则 判断该节点的 下一个结点（`next`）
        1. 如果是红黑树：则遍历红黑树，找到 `hash` 和 `key` 都相同的节点，返回 `value`；
        2. 否则就是链表，直接遍历链表，找到 `hash` 和 `key` 都相同的节点，返回 `value`。

### 3.6 HashMap 的扩容

#### 加载因子

为了减少 **哈希冲突** 发生的概率，当 `HashMap` 的元素个数达到一个**临界值**时，会触发 **扩容机制**，即把所有元素进行 `reHash` 之后，再放入扩容后的容器中。这个过程相当**耗时**。

比如在 `java.util.HashMap#putVal()` 方法中，就有相关的判断：

![image-20220914172144291](https://img.zxdmy.com/2022/202209141721463.png)

上图代码中的 `threshold` 即为**临界值**，是由 **当前容量** 和 **加载因子** 共同确定的：

![image-20220914172517963](https://img.zxdmy.com/2022/202209141725077.png)

> 临界值（`threshold` ）= 默认容量（`DEFAULT_INITIAL_CAPACITY`） * 默认扩容因子（`DEFAULT_LOAD_FACTOR`）

其中的**默认容量**就是前文中提到的 `2` 的倍数，而 **加载因子** 默认值为 `0.75`。

采用 `0.75` 的原因是对 **空间** 成本和 **时间** 成本平衡的考虑，假如加载因子较小，会导致空位较多时就扩容的情况，加载因子较小，会导致哈希冲突概率增加，查找时间成本增加。

#### 扩容机制

HashMap是基于数组+链表和红黑树实现的，但用于存放key值的桶数组的长度是固定的，由初始化参数确定。
那么，随着数据的插入数量增加以及负载因子的作用下，就需要扩容来存放更多的数据。

而扩容中有一个非常重要的点，就是 `JDK 1.8` 中的优化操作：**可以不需要再重新计算每一个元素的哈希值**。

因为`HashMap`的**初始容量**是`2`的次幂，**扩容之后的长度是原来的二倍**，新的容量也是`2`的次幂，所以，**元素要么在原位置，要么在原位置再移动2的次幂**。

具体如下图所示：

![image-20220915165429749](https://img.zxdmy.com/2022/202209151654939.png)

+ 图 `a` 的 `n` 表示**扩容前**的表长度，左侧 `key1` 和 `key2` 表示两种类型的 `hash`，右侧为确定**索引**的位置示意
+ 图 `b` 的 `n` 表示**扩容后**的表长度，右侧为 **扩容后** 的 **索引** 位置确定示意。

元素在重新计算`hash`之后，因为`n`变为`2`倍，那么`n-1`的`mask`范围在**高位**多 `1bit` （红色），因此新的`index` 就会发生这样的变化：

![image-20220915165922034](https://img.zxdmy.com/2022/202209151659074.png)

所以在扩容时，只需要看**原来**的`hash`值**新增的那一位**是`0`还是`1`就行了，是`0`的话**索引没变**，是`1`的化变成 `old_index + old_CAPACITY`，即 **原索引 + 原容量** 。

比如：

![image-20220915170146163](https://img.zxdmy.com/2022/202209151701419.png)

### 3.7 HashMap 的线程安全问题

#### 线程安全问题：

`HashMap` 不是线程安全的，可能会发生如下问题：

+ **多线程下扩容死循环**。`JDK1.7` 中的 `HashMap` 使用 **头插法** 插入元素，在多线程的环境下，扩容的时候有可能 **导致环形链表** 的出现，形成 **死循环**。因此，`JDK1.8` 使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。
+ **多线程的 `put` 可能导致元素的丢失**。**多线程**同时执行 `put` 操作，如果计算出来的索引位置是相同的，那会造成前一个 `key` 被后一个 `key` 覆盖，从而导致元素的丢失。此问题在 JDK 1.7 和 JDK 1.8 中都存在。
+ **`put` 和 `get` 并发时，可能导致 `get` 为 `null`**。线程 `1` 执行 `put` 时，因为元素个数超出 `threshold` 而导致 `rehash`，线程 `2` 此时执行 `get`，有可能导致这个问题。这个问题在 `JDK 1.7` 和 `JDK 1.8` 中都存在。

#### 线程安全解决方案：

`Java` 中有 `Hashtable`、`Collections.synchronizedMap`、以及 `ConcurrentHashMap` 可以实现线程安全的 `Map`。

+ `Hashtable` 是直接在操作方法上加 `synchronized` 关键字，**锁住整个`table`数组**，粒度比较大；
+ `Collections.synchronizedMap` 是使用 `Collections` 集合工具的内部类，通过传入`Map` 封装出一个 `SynchronizedMap` 对象，内部定义了一个对象锁，方法内**通过对象锁**实现；
+ `ConcurrentHashMap` 在 `jdk1.7` 中使用 **分段锁**，在 `jdk1.8` 中使用 `CAS + synchronized`。

### 3.8 ConcurrentHashMap 保证线程安全

#### JDK 1.7：分段锁

`JDK 1.7` 版本的 `ConcurrentHashMap` 采用 **分段锁** 机制，里面包含一个`Segment` 数组，`Segment`继承于`ReentrantLock`，`Segment`则包含`HashEntry`的数组，`HashEntry`本身就是一个**链表**的结构，具有保存`key`、`value`的能力，能指向下一个节点的**指针**。

实际上就是相当于每个`Segment`都是一个`HashMap`，默认的`Segment`长度是**16**，也就是支持**16**个线程的并发写，`Segment`之间相互不会受到影响。

![image-20220915213936187](https://img.zxdmy.com/2022/202209152139400.png)

**put 流程**：

整个流程和HashMap非常类似，只不过是先定位到具体的`Segment`，然后通过`ReentrantLock`去操作而已，后面的流程，就和HashMap基本上是一样的。

1. 计算`hash`，定位到`segment`，`segment`如果是空就先初始化；
2. 使用`ReentrantLock`加锁，如果获取锁失败则尝试**自旋**，自旋超过次数就**阻塞**获取，保证一定获取锁成功；
3. 遍历`HashEntry`，就是和`HashMap`一样，数组中`key`和`hash`一样就直接**替换**，**不存在就再插入链表**，链表同样操作。

**get 流程**：

首先通过 `key` 的 `hash` 定位到 `segment`，再**遍历链表**定位到具体的元素上。

需要注意的是`value`是`volatile`的，所以`get`是**不需要加锁**的。

#### JDK 1.8：CAS + synchronized

`JDK 1.8` 实现 **线程安全** 不是在数据结构上下功夫，它的数据结构和`HashMap`是一样的，**数组+链表+红黑树**。它实现 **线程安全的关键点在于`put`流程**。

**put 流程**：

1. 首先计算`hash`，遍历`node`数组，如果`node`是空的话，就通过 `CAS+自旋` 的方式**初始化**
2. 如果当前 **数组位置是空** 则直接通过`CAS`自旋写入数据
3. 如果 `hash==MOVED`，说明需要 **扩容**，执行扩容
4. 如果都不满足，就使用 `synchronized` 写入数据，写入数据同样判断链表、红黑树，链表写入和`HashMap` 的方式一样，key 和 hash一样就覆盖，反之就尾插法，链表长度超过8就转换成红黑树

![image-20220915214703522](https://img.zxdmy.com/2022/202209152147112.png)

**get 查询**：

get很简单，和HashMap基本相同，通过key计算位置，table该位置key相同就返回，如果是红黑树按照红黑树获取，否则就遍历链表获取

### 3.9 有序 Map

`HashMap`是无序的，根据 `hash` 值随机插入。如果想使用有序的 `Map`，可以使用 `LinkedHashMap` 或者 `TreeMap`

#### LinkedHashMap

`LinkedHashMap`维护了一个双向链表，有**头尾节点**，同时 LinkedHashMap 节点 Entry 内部除了继承 HashMap 的 Node 属性，还有 before 和 after 用于标识前置节点和后置节点。

![image-20220915215011775](https://img.zxdmy.com/2022/202209152150048.png)

可以实现按插入的顺序或访问顺序排序。

![image-20220915215027111](https://img.zxdmy.com/2022/202209152150299.png)

#### TreeMap

`TreeMap` 是按照 `Key` 的 **自然顺序** 或者 `Comprator` 的顺序进行排序，内部是通过**红黑树**来实现。

所以要么 key 所属的类实现 `Comparable` 接口，或者自定义一个实现了`Comparator` 接口的比较器，传给 TreeMap 用于 key 的比较。

![image-20220915215121209](https://img.zxdmy.com/2022/202209152151325.png)

### 总结：HashMap 的优化

jdk1.8 的HashMap主要有五点优化：

1. 数据结构：数组 + 链表改成了数组 + 链表或红黑树；
   原因：发生 hash 冲突，元素会存入链表，链表过长转为红黑树，将时间复杂度由O(n) 降为O(logn)
2. 链表插入方式：链表的插入方式从头插法改成了尾插法简单说就是插入时，如果数组位置上已经有元素，1.7 将新元素放到数组中，原始节点作为新节点的后继节点，1.8 遍历链表，将元素放置到链表的最后。
   原因：因为 1.7 头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环。
3. 扩容rehash：扩容的时候 1.7 需要对原数组中的元素进行重新 hash 定位在新数组的位置，1.8 采用更简单的判断逻辑，不需要重新通过哈希函数计算位置，新的位置不变或索引 + 旧的数组容量大小。
   原因： 提高扩容的效率，更快地扩容。
4. 扩容时机：在插入时，1.7 先判断是否需要扩容，再插入，1.8 先进行插入，插入完成再判断是否需要扩容；
5. 散列函数：1.7 做了四次移位和四次异或，jdk1.8只做一次。
   原因：做 4 次的话，边际效用也不大，改为一次，提升效率。

### 扩展：常见哈希构造方法与冲突解决方案

#### 哈希构造方法：

|    方法    | 简介                                                         |
| :--------: | ------------------------------------------------------------ |
| 除留取余法 | `H（key)=key%p（p<=N）`                                      |
| 直接定址法 | 直接根据key 来映射到对应的数组位置，例如1232放到下标1232的位置 |
| 数字分析法 | 取key 的某些数字（例如十位和百位）作为映射的位置             |
| 平方取中法 | 取`key` 平方的中间几位作为映射的位置                         |
|   折叠法   | 将key 分割成位数相同的几段，然后把它们的叠加和作为映射的位置 |

![image-20220915215415909](https://img.zxdmy.com/2022/202209152154893.png)

#### 哈希冲突解决方法

| 方法           | 简介                                           |
| -------------- | ---------------------------------------------- |
| 链地址法       | 在冲突的位置拉一个链表，把冲突的元素放进去。   |
| 开放定址法     | 从冲突的位置再接着往下找，给冲突元素找个空位。 |
| 再哈希法       | 换种哈希函数，重新计算冲突元素的地址。         |
| 建立公共溢出区 | 再建一个数组，把冲突的元素放进去               |





## 4、Set 系列详解

|      类       |     简介     |  线程  | 实现                       |
| :-----------: | :----------: | :----: | -------------------------- |
|    HashSet    |   无序集合   | 不安全 | 基于 `HashMap` 实现        |
| LinkedHashSet |   无序集合   | 不安全 | 通过 `LinkedHashMap` 实现  |
|    TreeSet    | **有序**集合 | 不安全 | 红黑树(自平衡的排序二叉树) |

- `HashSet`、`LinkedHashSet` 和 `TreeSet` 都是 `Set` 接口的实现类，都能保证元素唯一，并且都不是线程安全的。
- `HashSet`、`LinkedHashSet` 和 `TreeSet` 的主要区别在于底层数据结构不同。`HashSet` 的底层数据结构是哈希表（基于 `HashMap` 实现）。`LinkedHashSet` 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。`TreeSet` 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。
- 底层数据结构不同又导致这三者的应用场景不同。`HashSet` 用于不需要保证元素插入和取出顺序的场景，`LinkedHashSet` 用于保证元素的插入和取出顺序满足 FIFO 的场景，`TreeSet` 用于支持对元素自定义排序规则的场景。















---



## 3、Queue 队列 实现类详解

|      类       |   简介   |  线程  | null  | 实现                                  |
| :-----------: | :------: | :----: | :---: | :------------------------------------ |
| PriorityQueue | 有序队列 | 不安全 | **N** | `Object[]` 数组来实现的二叉**小顶堆** |
|  ArrayDeque   | 双端队列 | 不安全 | **N** | `Object[]` 数组 + 双指针              |

### 3.1 PriorityQueue

#### 自动扩容

默认容量 `11`，当队列长度小于 `64` 扩容`2`倍，否则扩容 `1.5` 倍，扩容后超出 `int` 范围赋值为 `Integer.Max_VALUE`，最小需要容量小于0，说明超出`int`范围，则抛出`OOM`异常。

#### 线程问题

非线程安全，不支持并发访问和修改。但是Java提供了`PriorityBlockingQueue`（实现 BlockingQueue 接口，使用 ReentrantLock 加锁保护）用于Java多线程环境。

### 3.2 ArrayDeque

#### 自动扩容

最小容量 `8`，默认容量 `16` ，二者不一的原因是其使用`allocateElements`方法扩容，对 8 进行特定计算后得二进制 10000，故默认容量为 16。容量必须是 2^n^ ，即每次扩容两倍。

线程问题：非线程安全，不支持并发访问和修改。多线程环境需要自行处理。

可克隆，可序列化，可迭代遍历。



## 5、Map 映射 实现类详解











#### 性能影响分析

HashMap的性能受两个参数的影响：“初始容量” 和 “加载因子”

+ `加载因子` 是哈希表在其容量自动增加之前可以达到多满的一种尺度
+ 默认加载因子是 `0.75` ，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表**进行 rehash 操作（即重建内部数据结构）**，从而哈希表将具有大约两倍的桶数（即容量）。

### 5.2 ConcurrentHashMap

> 后续详解基于 JDK 1.8

#### 存储结构

**ConcurrentHashMap** 的存储结构采用  **Node 数组 + 链表 / 红黑树** 的形式，当冲突链表达到一定长度时，链表会转换成红黑树。

ConcurrentHashMap ⽀持⾼并发的访问和更新，线程安全，检索操作不⽤加锁，get⽅法是⾮阻塞的。

存储结构如下图所示。

![image-20220727153631929](https://img.zxdmy.com/2022/202207271536319.png)



> 问：为什么有了 `Hashtable` 线程安全类还要 `ConcurrentHashMap`？
>
> 答：`Hashtable` 是在每个⽅法上都加上 `Synchronized` 完成同步（相当于锁住整个hash表），效率低下。而 `ConcurrentHashMap` 通过 **部分加锁** 和 **利⽤CAS算法 + Syn** 来实现同步。

#### 初始化

ConcurrentHashMap 的初始化是通过**自旋和 CAS** 操作完成。变量 `sizeCtl` ，它的值决定着当前的初始化状态：

+ -1 说明正在初始化
+ -N 说明有N-1个线程正在进行扩容
+ 表示 table 初始化大小，如果 table 没有初始化
+ 表示 table 容量，如果 table　已经初始化。

#### put 方法的详细流程

1. 根据 key 计算出 hashcode 。
2. 判断是否需要进行初始化。
3. 为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。
4. 如果当前位置的 `hashcode == MOVED == -1`,则需要进行扩容。
5. 如果都不满足，则利用 `synchronized` 锁写入数据。
6. 如果数量大于 `TREEIFY_THRESHOLD` 则要执行树化方法，在treeifyBin中会首先判断当前数组长度≥64时才会将链表转换为红黑树。

#### get 方法的详细流程

1. 根据 hash 值计算位置。
2. 查找到指定位置，如果头节点就是要找的，直接返回它的 value.
3. 如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。
4. 如果是链表，遍历查找之。

### 5.3 LinkedHashMap

+ **简介**：是HashMap的子类，其内部还有一个`双向链表`维护键值对的顺序，每个键值对既位于哈希表中，也位于双向链表中。
+ **有序**：
    + 插入顺序：先添加的在前面，后添加的在后面。修改操作不影响顺序；
    + 访问顺序：每次`get/put`所访问的元素，将被移动至链表末尾（故末尾是最近访问的，是最久没有被访问的）

+ 访问速度比较慢

### 5.4 Hashtable

+ 哈希值计算：直接采用 key 的 hashCode()
+ 扩容机制：
    + 初始容量为 11，负载因子默认 0.75 ；
    + 当 `已用容量 > 总容量 * 负载因子` 时，扩容：`newsize = olesize*2 + 1`；

+ Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。

### 5.5 TreeMap

适用于按自然顺序或自定义顺序遍历键(key)。

+ TreeMap 的结构是红黑树
+ TreeMap 实现了 SortedMap 接口，具有对集合中的元素根据键排序的能力。默认是按 key 的字典序升序排序，不过也可以指定排序的比较器。

## 6、并发容器



## 7、常见面试题

ArrayList 和 LinkedList 的区别

Java 里有哪些队列容器，哪些是线程安全的

HashMap、HashTable、ConcurrentHashMap

ConcurrentHashMap 的 size 和 get 是线程安全的吗

HashMap的Get流程？线程安全？如何选择线程安全的容器？

ArrayList 的扩容？

ArrayList 在 JVM 里怎么存的？







