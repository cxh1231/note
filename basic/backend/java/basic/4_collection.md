> https://javaguide.cn/java/collection/java-collection-questions-01.html

## 1、Java容器概述

**Java容器** 主要由 `Collection` 和 `Map` 两大接口派生而来。

这两大接口派生的各个接口和实现类，如下图所示。

![image-20220725101728777](https://img.zxdmy.com/2022/202207251017896.png)

![image-20220727155557946](https://img.zxdmy.com/2022/202207271556212.png)

+ `Collection` 表示**集合**（类似数组），主要用于存放单一元素；
  + `List`  表示**列表**（顺序），其存储的元素有序、可重复；
  + `Queue` 表示**队列**（排队），其存储的元素有序、可重复；
    + Deque 表示 双端队列
  + `Set`  表示**集合**（独一无二），其存储的元素无序、不可重复；
    + Sorted 有序集合
+ `Map` 表示**映射**，主要用于存放键值对；
  + `Map` 的 key 是无序、不可重复的，value 是无序、可重复的， key 与value 一一对应。

## 2、List 列表 实现类详解

|     类     |   简介   |   线程   | null | 底层数据结构（实现）                           |
| :--------: | :------: | :------: | :--: | ---------------------------------------------- |
|   Vector   | 动态数组 | **安全** |  Y   | `Object[]` 数组                                |
|   Stack    |    栈    | **安全** |  Y   |                                                |
| ArrayList  | 动态数组 |  不安全  |  Y   | `Object[]` 数组                                |
| LinkedList | 双向链表 |  不安全  |  Y   | 双向链表（JDK1.6 为循环链表，JDK1.7 取消循环） |

### 2.1 Vector

是 List 的古老实现类。

### 2.2 Stack

栈，先进后出。

### 2.3 ArrayList

#### 自动扩容

默认初始容量 `10`，默认最大 `MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8`；

+ 新添加元素前，调用 `ensureCapacityInternal()` 方法，进行判断是否需要扩容；
+ 将新容量 `new` 扩充为原来的 `1.5` 倍，即 `new = old + (old >> 1)`；
+ 如果新容量 `new` 小于 最小需要容量 `min`，则 `new = min`；
+ 如果新容量 `new` 大于 `MAX_ARRAY_SIZE` ，则 `new = Integer.MAX_VALUE`。

**增删元素复杂度**：由于采用数组存储，**插入和删除受元素位置的影响**。

+ 直接添加元素时，追加在末尾，复杂度 `O(1)`；
+ 指定位置添加或删除元素，需要将后续的`(n-i)`个元素向前/后移动，复杂度为 `O(n-i)`。

**快速随机访问**：支持，可以通过元素序号快速获取元素对象；

**内存空间占用**：列表末尾会预留预定义的数组空间；

构造（不指 ≤ JDK6）：

+ 无参数构造方法创建 `ArrayList` 时，初始化赋值为一个空数组；
+ 当向数组中添加第一个元素时，才分配容量，即容量扩为 默认值 10。

### 2.4 LinkedList

**增删元素复杂度**：由于采用链表存储，

+ 直接添加/删除元素时，**不受元素位置影响**，复杂度 `O(1)`；
+ 指定位置添加或删除元素，**需要先移动至指定位置再进行操作**，复杂度为  `O(n)`。

**快速随机访问**：不支持高效的随机元素访问；

**内存空间占用**：每个元素需要多消耗前驱、后继数据。

## 3、Queue 队列 实现类详解

|      类       |   简介   |  线程  | null  | 实现                                  |
| :-----------: | :------: | :----: | :---: | :------------------------------------ |
| PriorityQueue | 有序队列 | 不安全 | **N** | `Object[]` 数组来实现的二叉**小顶堆** |
|  ArrayDeque   | 双端队列 | 不安全 | **N** | `Object[]` 数组 + 双指针              |

### 3.1 PriorityQueue

#### 自动扩容

默认容量 `11`，当队列长度小于 `64` 扩容`2`倍，否则扩容 `1.5` 倍，扩容后超出 `int` 范围赋值为 `Integer.Max_VALUE`，最小需要容量小于0，说明超出`int`范围，则抛出`OOM`异常。

#### 线程问题

非线程安全，不支持并发访问和修改。但是Java提供了`PriorityBlockingQueue`（实现 BlockingQueue 接口，使用 ReentrantLock 加锁保护）用于Java多线程环境。

### 3.2 ArrayDeque

#### 自动扩容

最小容量 `8`，默认容量 `16` ，二者不一的原因是其使用`allocateElements`方法扩容，对 8 进行特定计算后得二进制 10000，故默认容量为 16。容量必须是 2^n^ ，即每次扩容两倍。

线程问题：非线程安全，不支持并发访问和修改。多线程环境需要自行处理。

可克隆，可序列化，可迭代遍历。

## 4、Set 集合 实现类详解

|      类       |     简介     |  线程  | 实现                       |
| :-----------: | :----------: | :----: | -------------------------- |
|    HashSet    |   无序集合   | 不安全 | 基于 `HashMap` 实现        |
| LinkedHashSet |   无序集合   | 不安全 | 通过 `LinkedHashMap` 实现  |
|    TreeSet    | **有序**集合 | 不安全 | 红黑树(自平衡的排序二叉树) |

- `HashSet`、`LinkedHashSet` 和 `TreeSet` 都是 `Set` 接口的实现类，都能保证元素唯一，并且都不是线程安全的。
- `HashSet`、`LinkedHashSet` 和 `TreeSet` 的主要区别在于底层数据结构不同。`HashSet` 的底层数据结构是哈希表（基于 `HashMap` 实现）。`LinkedHashSet` 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。`TreeSet` 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。
- 底层数据结构不同又导致这三者的应用场景不同。`HashSet` 用于不需要保证元素插入和取出顺序的场景，`LinkedHashSet` 用于保证元素的插入和取出顺序满足 FIFO 的场景，`TreeSet` 用于支持对元素自定义排序规则的场景。

## 5、Map 映射 实现类详解

|      类       |     简介     |   线程   | null  | 实现                                                         |
| :-----------: | :----------: | :------: | :---: | ------------------------------------------------------------ |
|    HashMap    |   无序映射   |  不安全  |   Y   | 长度 < 8：数组 + 链表（链表散列）<br/>长度 >= 8 ：数组 + 链表 \| 红黑树 |
| LinkedHashMap | **有序**映射 |  不安全  |   Y   | 数组 + 链表 \| 红黑树；双向链表                              |
|   Hashtable   |   无序映射   | **安全** | **N** | 数组 + 链表                                                  |
|    TreeMap    | **有序**映射 |  不安全  | **N** | 红黑树（自平衡的排序二叉树）                                 |

### 5.1 HashMap

> HashMap 用来存放键值对，基于哈希表的 Map 接口实现。

#### 存储结构

+ 在JDK1.8 之前使用 `数组+链表` ，其中数组是主体，链表的作用是解决哈希冲突（“拉链法”解决冲突），即当元素出现哈希冲突时，会存储在该位置的单链表中。
+ JDK1.8 及之后，使用 `数组 + 链表 | 红黑树` ，即长链表在下面的情况下，会转化为红黑树。

#### 哈希值计算流程

1. 调用 `key` 的 `hashCode()` 方法，获取其 `hashcode`；
2. 调用 `HashMap` 的 `hash()` 方法，对 `hashcode` 进行扰动计算 `hash` 值（以减少哈希碰撞）；
3. 通过 `取模` 计算下标

上述计算过程中的 `扰动方法` 和 `取模计算` 方法如下：

```java
// 扰动计算 hash（ ^ ：按位异或；>>>：无符号右移）
hash = (h = key.hashCode()) ^ (h >>> 16);

// 取模计算（注意，这里使用的是 与 的形式，等同于 hash % length）
hash & (length - 1)
```

下图详细描述了 HashMap 数组下标的计算过程。

![image-20220727143911762](https://img.zxdmy.com/2022/202207271439277.png)

> **问：为什么 hash 值要与 length-1 `相与`，而不是`取模`？**
>
> 答：一方面模运算没有位运算快，另一方面数组长度总是2的幂次方，`hash & (length-1)` 运算等价于 `hash % length`，但是 & 比 % 具有更高的效率。

> **问：JDK1.8 为什么要 `hashcode` 异或其右移十六位的值？**
>
> 答：因为在JDK 1.7 中扰动了 4 次，计算 hash 值的性能会稍差一点点。 从速度、功效、质量来考虑，JDK1.8 优化了高位运算的算法。这么做可以在数组 table 的 length 比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。

#### 自动扩容（基于JDK1.8）

+ 哈希表（数组）的默认初始大小为 `16`，每次扩容为原来 `2` 倍。
  + 当 `已用容量 > 总容量 * 负载因子` 时进行扩容。

+ 某个单链表元素超过 `8` 个，但是数组总长度不超过 `64`：扩容；
+ 某个单链表元素超过 `8` 个，并且数组总长度超过 `64`：该节点的链表转化为红黑树；

![image-20220727142139825](https://img.zxdmy.com/2022/202207271421976.png)

由于删除或调整操作，某个红黑树的节点 `≤6` 个时，将恢复链表形态。

> **问：HashMap 数组的长度为什么是 2 的幂次方？**
>
> 答：这样做效果上等同于取模，在速度、效率上比直接取模要快得多。除此之外，2 的 N 次幂有助于减少碰撞的几率。

#### put 方法的详细流程

1. 首先根据 `key` 的值计算 `hash` 值，找到该元素在数组中存储的`下标（索引值）`；
2. 如果数组是空的，则调用 `resize` 进行初始化；
3. 如果没有哈希冲突直接放在对应的数组下标里；
4. 如果冲突了，且 key 已经存在，就覆盖掉 value；
5. 如果冲突后，发现该节点是红黑树，就将这个节点挂在树上；
6. 如果冲突后是链表，判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；否则，链表插入键值对，若 key 存在，就覆盖掉 value。

详细流程如下图所示：

**![image-20220727100923304](https://img.zxdmy.com/2022/202207271009092.png)**

![image-20220727145836432](https://img.zxdmy.com/2022/202207271500301.png)

> **问：JDK1.7 和 1.8 的 put 方法区别是什么？**
>
> 答：解决哈希冲突时，JDK1.7 只使用链表，JDK1.8 使用链表+红黑树，当满足一定条件，链表会转换为红黑树。
>
> 链表插入元素时，JDK1.7 使用头插法插入元素，在多线程的环境下有可能导致环形链表的出现，扩容的时候会导致死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了，但JDK1.8 的 HashMap 仍然是线程不安全的。

> **问：一般用什么作为 HashMap 的 key？**
>
> 答：一般用`Integer`、`String` 这种不可变类作为 `key`，而 `String` 最为常用，详细原因如下：
>
> + 因为字符串是不可变的，所以在它创建的时候 `hashcode` 就被缓存了，不需要重新计算。
> + 因为获取对象的时候要用到 `equals()` 和 `hashCode()` 方法，这些类已经很规范的重写了 `hashCode()` 以及 `equals()` 方法。

> **问：用可变类当 HashMap 的 key 有什么问题？**
>
> 答：可变类的 hashcode 可能发生改变，导致 put 进去的值，无法 get 出。

#### get 方法的详细流程

1. 计算传入的 `key` 值的 `hash`，并求`索引值`；
2. 如果：数组为空 | 数组长度为 0 | 当前索引位置的第一个元素为 `null`，则返回 `null`，结束。
3. 否则：
   1. 如果：数组节点 的 `hash` 值和 `key` 均为所求，则返回该数组节点上的 `value`，结束。
   2. 如果：数组节点 不是所求，则 判断该节点的 下一个结点（next）
      1. 如果是红黑树：则遍历红黑树，找到 `hash` 和 `key` 都相同的节点，返回 `value`；
      2. 否则就是链表，直接遍历链表，找到 `hash` 和 `key` 都相同的节点，返回 `value`。

#### 性能影响分析

HashMap的性能受两个参数的影响：“初始容量” 和 “加载因子”

+ `加载因子` 是哈希表在其容量自动增加之前可以达到多满的一种尺度
+ 默认加载因子是 `0.75` ，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表**进行 rehash 操作（即重建内部数据结构）**，从而哈希表将具有大约两倍的桶数（即容量）。

### 5.2 ConcurrentHashMap

> 后续详解基于 JDK 1.8

#### 存储结构

**ConcurrentHashMap** 的存储结构采用  **Node 数组 + 链表 / 红黑树** 的形式，当冲突链表达到一定长度时，链表会转换成红黑树。

ConcurrentHashMap ⽀持⾼并发的访问和更新，线程安全，检索操作不⽤加锁，get⽅法是⾮阻塞的。

存储结构如下图所示。

![image-20220727153631929](https://img.zxdmy.com/2022/202207271536319.png)



> 问：为什么有了 `Hashtable` 线程安全类还要 `ConcurrentHashMap`？
>
> 答：`Hashtable` 是在每个⽅法上都加上 `Synchronized` 完成同步（相当于锁住整个hash表），效率低下。而 `ConcurrentHashMap` 通过 **部分加锁** 和 **利⽤CAS算法 + Syn** 来实现同步。

#### 初始化

ConcurrentHashMap 的初始化是通过**自旋和 CAS** 操作完成。变量 `sizeCtl` ，它的值决定着当前的初始化状态：

+ -1 说明正在初始化
+ -N 说明有N-1个线程正在进行扩容
+ 表示 table 初始化大小，如果 table 没有初始化
+ 表示 table 容量，如果 table　已经初始化。

#### put 方法的详细流程

1. 根据 key 计算出 hashcode 。
2. 判断是否需要进行初始化。
3. 为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。
4. 如果当前位置的 `hashcode == MOVED == -1`,则需要进行扩容。
5. 如果都不满足，则利用 `synchronized` 锁写入数据。
6. 如果数量大于 `TREEIFY_THRESHOLD` 则要执行树化方法，在treeifyBin中会首先判断当前数组长度≥64时才会将链表转换为红黑树。

#### get 方法的详细流程

1. 根据 hash 值计算位置。
2. 查找到指定位置，如果头节点就是要找的，直接返回它的 value.
3. 如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。
4. 如果是链表，遍历查找之。

### 5.3 LinkedHashMap

+ **简介**：是HashMap的子类，其内部还有一个`双向链表`维护键值对的顺序，每个键值对既位于哈希表中，也位于双向链表中。
+ **有序**：
  + 插入顺序：先添加的在前面，后添加的在后面。修改操作不影响顺序；
  + 访问顺序：每次`get/put`所访问的元素，将被移动至链表末尾（故末尾是最近访问的，是最久没有被访问的）

+ 访问速度比较慢

### 5.4 Hashtable

+ 哈希值计算：直接采用 key 的 hashCode()
+ 扩容机制：
  + 初始容量为 11，负载因子默认 0.75 ；
  + 当 `已用容量 > 总容量 * 负载因子` 时，扩容：`newsize = olesize*2 + 1`；

+ Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。

### 5.5 TreeMap

适用于按自然顺序或自定义顺序遍历键(key)。

+ TreeMap 的结构是红黑树
+ TreeMap 实现了 SortedMap 接口，具有对集合中的元素根据键排序的能力。默认是按 key 的字典序升序排序，不过也可以指定排序的比较器。

## 6、并发容器



## 7、常见面试题

ArrayList 和 LinkedList 的区别

Java 里有哪些队列容器，哪些是线程安全的

HashMap、HashTable、ConcurrentHashMap

ConcurrentHashMap 的 size 和 get 是线程安全的吗

HashMap的Get流程？线程安全？如何选择线程安全的容器？

ArrayList 的扩容？

ArrayList 在 JVM 里怎么存的？







