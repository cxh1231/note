## 1、Java 简介

### 1.1 Java 语言特点

面向对象（封装，继承，多态）；

平台无关性（一次编写，到处运行）；

支持多线程；可靠性；安全性；支持网络编程并且很方便；编译与解释并存。

### 1.2 JDK  &  JVM  &  JRE 的区别

- **JVM（Java 虚拟机）**是`运行 Java 字节码的虚拟机`。JVM 有针对不同系统的特定实现，目的是使用相同的字节码，它们都会给出相同的结果。

- **JDK（Java Development Kit）** ，是`功能齐全的 Java SDK`。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。

- **JRE** 是 `Java 运行时环境`。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。

![image-20220809144931268](https://img.zxdmy.com/2022/202208091449793.png)

> 如果只是为了运行一下 Java 程序的话，那只需要安装 JRE 就可。如果需要进行一些 Java 编程方面的工作，那就需要安装 JDK 。但不绝对！

### 1.3 字节码

在 Java 中，`JVM` **可以理解的代码就叫做字节码**（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。

之所以被称之为字节码，是因为**字节码文件由十六进制值组成**，而JVM以两个十六进制值为一组，即以字节为单位进行读取。

Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。

>  **Java 是编译与解释共存的语言** 。

### 1.4 编译与解释

- **编译型** ：`编译型语言 会通过编译器将源代码一次性翻译成可被该平台执行的机器码。`一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。
- **解释型** ：`解释型语言 一句一句的将代码解释（interpret）为机器代码后再执行。`解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。

Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（`.class` 文件），这种字节码必须由 Java 解释器来解释执行。

一个 `.java` 文件从编译到运行的过程，如下图所示。

![image-20220809145137249](https://img.zxdmy.com/2022/202208091451707.png)

### 1.5 Java 与 C++ 异同点

Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是：

- `Java` **不提供指针**来直接访问内存，程序内存更加安全
- `Java` 的**类是单继承**的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
- `Java` 有**自动内存管理垃圾回收机制**(GC)，不需要程序员手动释放无用内存。
- C ++同时支持方法重载和操作符重载，但是 `Java` **只支持方法重载**（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。
- `Java` **不支持操作符重载**；C++支持；
- `Java` **不支持缺省参数函数**；C++支持；
- `Java` **不支持 C++ 中的自动强制类型转换**，如果需要，必须由程序显式进行强制类型转换。

### 1.6  Oracle JDK 与 OpenJDK

+ `OpenJDK` 是一个参考模型并且是`完全开源`的，而 `Oracle JDK` 是 OpenJDK 的一个实现，并`不是完全开源`的；
+ `Oracle JDK` 比 OpenJDK `更稳定`（Oracle 内部团队进行单独研发）；
+ `Oracle JDK` 与 OpenJDK 相比提供了`更好的性能`；
+ Oracle JDK 使用 BCL/OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。

## 2、面向对象

### 2.1 面向对象与面向过程

- `面向过程` 把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。比如单片机、嵌入式开发一般采用面向过程开发，性能比较高。
- `面向对象` 会先抽象出对象，然后用对象执行方法的方式解决问题。有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。易维护、易复用、易扩展。但性能比面向过程低。

### 2.2 面向对象三大特征

#### 封装

**封装** : 把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。

+ 比如`实体类`。

#### 继承

**继承** : 不同类型的对象，相互之间经常有一定数量的共同点。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。

+ 子类拥有父类对象所有的属性和方法，但无法访问，子类的对象可以访问。
+ 子类可以拥有自己属性和方法；
+ 子类可以用自己的方式实现父类的方法。

示例：

```java
// 父类
public class Animal { 
    private String name;  
    private int id; 
    // 构造方法
    public Animal(String myName, int myid) { 
        name = myName; 
        id = myid;
    } 
    public void eat(){ 
        System.out.println(name+"正在吃"); 
    }
    public void sleep() {
		System.out.println(name + "正在睡觉");
	}
}
// 子类
public class Mouse extends Animal { 
    // 继承父类的构造方法
    public Mouse(String myName, int myid) { 
        super(myName, myid); 
    }
}
// 使用
public static void main(String[] args) {
	Animal mouse = new Mouse("张三", 0);
    // 或：Mouse mouse = new Mouse("张三", 0);
	mouse.eat();
    mouse.sleep();
}
// 结果
张三正在吃
张三正在睡觉
```

#### 多态

**多态** : 表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。

+ `多态是方法的多态`，属性没有多态；
+ `方法可重写`，不能实现重写的也就没有多态可言；
+ 父类引用指向子类对象：`Parent p = new Child();`

> 即三个必要条件：继承、重写和向上转型

示例：

```java
//父类
class Shape {
	void draw() {
	}
}
//继承
class Circle extends Shape {
	// 多态：重写父类方法
	void draw() {
		System.out.println("Circle.draw()");
	}
}
//继承
class Square extends Shape {
	// 多态：重写父类方法
	void draw() {
		System.out.println("Square.draw()");
	}
}
// 使用
Shape shape = new Circle();
shape.draw(); // 输出：Circle.draw()
Shape shape2 = new Square();
shape2.draw(); // 输出：Square.draw()
Circle circle = new Circle();
circle.draw(); // 输出：Circle.draw()
```

多态又分为 **编译时多态（又称静态多态）** 和 **运行时多态（又称动态多态）**。

**重载（overload）就是编译时多态**的一个例子，编译时多态在编译时就已经确定，运行的时候调用的是确定的方法。

**通常所说的多态指的都是运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定。**

## 3、对象

#### 简介

**对象**是类的一个实例，有状态和行为。

> 对象实例在堆内存中，对象引用存放在栈内存中。

一个对象引用可以指向 0 个或 1 个对象，一个对象可以有 n 个引用指向它。

- **对象相等** 一般比较的是内存中存放的`内容`是否相等。
- **引用相等** 一般比较的是他们指向的`内存地址`是否相等。

如表达式 `A a1 = new A();` ：

+ `A` 是类；
+ `a1` 是对象引用，a1不是对象；
+ `new A()` 是对象，a1引用 指向 new A() 这个对象。

> 一个类的实例从new 开始的过程？TODO

#### 创建

java中提供了以下四种创建对象的方式:

- `new` 创建新对象：创建`对象实例`，`对象引用` 指向对象实例。
- 通过`反射`机制
- 采用 `clone` 机制
- 通过 `序列化` 机制

#### 不可变对象

**不可变对象** 指对象一旦被创建，状态就不能再改变，任何修改都会创建一个新的对象。

如 `String`、`Integer`及其它包装类就是不可变对象。

**不可变对象最大的好处是线程安全**。

> 可以创建一个包含可变对象的不可变对象。
>
> 比如`final Person[] persons = new Persion[]{}`，`persons`是不可变对象的引用，但其数组中的Person实例却是可变的。
>
> 这种情况下需要特别谨慎，不要共享可变对象的引用。
>
> 这种情况下，如果数据需要变化时，就返回原对象的一个拷贝。

## 4、构造方法

**构造方法** 是一种特殊的方法，主要作用是 **完成对象的初始化工作**。

- 名字与类名相同。
- 没有返回值，但不能用 void 声明构造函数。
- 生成类的对象时自动执行，无需调用。

如果类不写构造方法，则Java默认有一个`无参构造方法`。如果写了构造方法，则Java不再默认添加无参构造方法。

**构造方法不能被 override（重写），但是可以 overload（重载）**。

> 推荐：如果重载了有参的构造方法，要把无参的构造方法也写出来。

## 5、接口和抽象类

**共同点** ：

- 都不能被实例化。
- 都可以包含抽象方法。
- 都可以有默认实现的方法（Java 8 可以用 `default` 关键字在接口中定义默认方法）。

**区别** ：

- 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系（比如说我们抽象了一个发送短信的抽象类，）。
- 一个类只能继承一个类，但是可以实现多个接口。
- 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。

## 6、引用拷贝、深拷贝与浅拷贝

- **引用拷贝**：引用拷贝就是两个不同的引用指向同一个对象。
- **浅拷贝**：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说`拷贝对象和原对象共用同一个内部对象`。
- **深拷贝** ：深拷贝会`完全复制`整个对象，包括这个对象所包含的内部对象。

![image-20220729110217967](https://img.zxdmy.com/2022/202207291102912.png)

## 7、方法调用的值传递与引用传递

+ **值传递**：指的是在方法调用时，**传递的参数是按值的拷贝传递**，传递的是值的拷贝，也就是说传递后就互不相关了。
+ **引用传递**：指的是在方法调用时，传递的参数是按引用进行传递，其实**传递的是引用的地址**，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。

**Java 中只有值传递**。

基本类型作为参数被传递时肯定是值传递；

引用类型作为参数被传递时也是值传递，只不过“值”为对应的引用，并不是对象本身。