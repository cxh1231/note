## 0、引言

`JVM`，即 **Java虚拟机**，它是Java实现**平台无关性**的基石。

`Java` 程序运行的时候，编译器将 Java 文件编译成平台无关的 Java **字节码** 文件（`.class`），然后对应平台的 `JVM` 对 **字节码** 文件进行解释，翻译成对应平台匹配的**机器指令**并运行。

![image-20220920203626906](https://img.zxdmy.com/2022/202209202036172.png)

同时，`JVM` 也是一个**跨语言的平台**，和语言无关，只和`class`的文件格式关联，任何语言，只要能翻译成符合规范的**字节码**文件，都能被 `JVM` 运行。

![image-20220920203712132](https://img.zxdmy.com/2022/202209202037306.png)

## 1、内存结构概述

> 基于JDK 1.8，`HotSpot`

在 Java 虚拟机的 **自动内存管理** 机制下，无需手动 `delete/free` 操作，不容易出现**内存泄露**和**内存溢出**问题，全权交给虚拟机管理。

但一旦出现内存泄露和溢出等问题，需要了解虚拟机的 **内存管理机制**。

![image-20220810110842624](https://img.zxdmy.com/2022/202208101108950.png)

**Java 虚拟机** 在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域，如下图所示。

![image-20220729151844436](https://img.zxdmy.com/2022/202207291602860.png)

> **问：从 JVM 角度说进程和线程之间的关系（详见JVM部分）**
>
> 答：通过上图可以看出，一个`JVM进程`中有多个`线程`，多个线程共享进程的`堆`和`方法区`（`元空间`）的资源，但是每个`线程`有自己的`虚拟机栈`、`本地方法栈`和`程序计数器`。
>
> 即： **线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。**

下面详细讲述各个内存区域。先从**线程私有区域**开始：

> **线程私有内存区域** 的 **生命周期和线程相同**，随着线程的创建而创建，随着线程的死亡而死亡。

![image-20220905170605412](https://img.zxdmy.com/2022/202209051706903.png)

## 2、虚拟机栈

**Java 虚拟机栈** （`Java Virtual Machine Stack`）是**线程**私有的，其**生命周期**与**线程**相同。

**Java 虚拟机栈** 是 JVM 运行时数据区域的一个核心，描述的是 Java 方法执行的线程内存模型，除了一些 `Native` 方法调用是通过**本地方法栈** 实现的，**其他所有的 Java 方法调用都是通过虚拟机栈来实现的**（也需要和其他运行时数据区域比如程序计数器配合）。

**方法调用** 的数据需要通过**栈**进行传递，每一次方法调用都会有一个对应的 **栈帧** 被压入栈中，每一个方法调用结束后，都会有一个 **栈帧** 被弹出。

**虚拟机栈** 由一个个**栈帧**组成，而每个栈帧中都拥有：`局部变量表`、`操作数栈`、`动态链接`、`方法返回地址`。

+ **局部变量表**：存放编译期可知的**各种数据类型**（如`8`种**基本数据类型**）、**对象引用**（如指向对象起始地址的引用指针、指向一个代表对象的句柄或其他与此对象相关的位置）。
+ **操作数栈**：作为**方法调用**的中转站使用，用于存放方法执行过程中产生的中间计算结果，以及计算过程中产生的临时变量。
+ **动态链接**：服务一个**方法**需要**调用**其他方法的场景。

> 关于**动态链接**：Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为 `符号引用` 保存在 Class 文件的`常量池`里。当一个方法要调用其他方法，需要将`常量池`中指向方法的`符号引用`转化为其在内存地址中的`直接引用`。**动态链接的作用就是为了将符号引用转换为调用方法的直接引用**。
>
> ![image-20220729153941829](https://img.zxdmy.com/2022/202207291539415.png)

**虚拟机栈** 和数据结构上的栈类似，也是 **先进后出** 的数据结构，只支持**出栈**和**入栈**两种操作。

![image-20220729153145253](https://img.zxdmy.com/2022/202207291531704.png)

程序运行中，**虚拟机栈** 可能会出现两种错误：

- `StackOverFlowError`： 若虚拟机栈的内存大小不允许动态扩展，那么当线程请求虚拟机栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。
- `OutOfMemoryError`： 如果虚拟机栈的内存大小可以动态扩展， 但是虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出 `OutOfMemoryError` 异常。

## 3、本地方法栈

**本地方法栈** 为虚拟机使用到的 `Native` **方法** 服务。

**本地方法** 被执行的时候，在**本地方法栈**也会创建一个**栈帧**，用于存放该本地方法的**局部变量表**、**操作数栈**、**动态链接**、**出口信息**。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和 `OutOfMemoryError` 两种错误。

>  在 `HotSpot 虚拟机` 中，**本地方法栈 和 Java 虚拟机栈 合二为一。**

> 问：为什么**虚拟机栈**和**本地方法栈**是线程私有的呢？
>
> 答：为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

## 4、程序计数器

**程序计数器**（`Program Counter Register`）也被成为 **PC寄存器**，是一块较小的内存空间，可以看作 **当前线程所执行的字节码的行号指示器**。

其作用如下：

+ **字节码解释器** 通过改变程序计数器来**依次读取指令**，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
+ 在 **多线程** 的情况下，程序计数器用于 **记录当前线程执行的位置**，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

> 问：为什么**程序计数器**是线程私有的呢？
>
> 答：正是**为了线程切换时能恢复到正确的执行位置**，所以每条线程都需要有一个独立的程序计数器，以保证各线程之间计数器互不影响，独立存储。

> 接下来是 线程共享区域：

## 5、堆

**堆**（`Java Heap`），是`JVM` 所管理的内存中最大的一块，所有**线程共享**堆的空间，在虚拟机启动时创建。

**堆 的唯一目的是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

> 但是：所有的对象都分配到堆中，太绝对！
>
> 从 JDK 1.7 开始已经默认开启**逃逸分析**，如果某些方法中的**对象引用**没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以**直接在栈上分配内存**。

**Java 堆** 是 **垃圾收集器** 管理的主要区域，因此也被称作 **GC 堆**（`Garbage Collected Heap`）。

从 **垃圾回收** 的角度，由于 **收集器** 基本都采用 **分代垃圾收集算法**，所以 **Java 堆** 还可以细分为**新生代**和**老年代**，再细致一点有：`Eden`、`Survivor`、`Old` 等空间。

![image-20220920205048132](https://img.zxdmy.com/2022/202209202050312.png)

> 进一步划分的目的是更好地回收内存，或者更快地分配内存。
>
> 但是：这种划分只是根据垃圾回收机制来进行的划分，不是Java虚拟机规范本身制定的。

在 JDK 7 版本及 JDK 7 版本之前，**堆内存** 被通常分为下面三部分：

1. 新生代内存（Young Generation）
2. 老年代内存（Old Generation）
3. 永久代内存（Permanent Generation）

**JDK 8 之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存**。

下图所示的 `Eden` 区、两个 `Survivor` 区 `S0` 和 `S1` 都属于**新生代**，中间一层属于**老年代**，最下面一层属于**永久代**。

![image-20220729170939107](https://img.zxdmy.com/2022/202207291709859.png)

> 关于各个年代内存，涉及到**垃圾回收算法**的使用，详见后文。

程序运行时，堆 中最容易出现 `OutOfMemoryError` 错误，比如：

+ `java.lang.OutOfMemoryError: GC Overhead Limit Exceeded` ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
+ `java.lang.OutOfMemoryError: Java heap space` :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。
+ ……

## 6、方法区（抽象概念）

#### 方法区简介

> 在不同的虚拟机实现上，方法区的实现是不同的。后面讲解通常的理解。

**方法区** （Method Area）属于是 JVM 运行时数据区域的一块 **逻辑区域**，是各个**线程共享**的内存区域。

> 注意，**方法区是一个逻辑区域**，并不是像堆、栈一样的 物理区域！

当虚拟机要使用一个类时，它需要读取并解析 `Class` 文件获取相关信息，再将信息存入到方法区。

**方法区** 会存储已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。

> 《Java 虚拟机规范》中把方法区描述为堆的一个逻辑部分，但方法区有个别名 非堆（Non-Heap）。

#### 方法区的演变

> 基于 HotSpot

|      JDK版本       |      <  JDK6       |    JDK 7    |           JDK 8           |
| :----------------: | :----------------: | :---------: | :-----------------------: |
| 方法区**具体实现** |       永久代       |   永久代    |    元空间（直接内存）     |
| 方法区**物理区域** | 永久代 （PermGen） | 堆 + 永久代 | 堆 + 元空间（Meta-space） |
|    **类**常量池    |       永久代       |   永久代    |    元空间（直接内存）     |
|  **运行时**常量池  |       永久代       |   永久代    |    元空间（直接内存）     |
|  **字符串**常量池  |       永久代       |     堆      |            堆             |

**永久代** 和 **元空间**是 HotSpot 虚拟机对虚拟机规范中**方法区**的两种实现方式。

+ **永久代** 是 JDK 1.8 之前方法区的实现，
+ **元空间** 是 JDK 1.8 及以后方法区的实现。

![image-20220729191012289](https://img.zxdmy.com/2022/202207291910278.png)

> **为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?**
>
> 1. 整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。
> 2. 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。
> 3. 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西，合并之后就没有必要额外的设置这么一个永久代的地方了。

#### 方法区的理解

**方法区 只是一个抽象的概念，并不是具体的 物理内存空间**。

**方法区** 在优化的过程中，只是实现方式有最初的 **永久代**，到中间的 **永久代 + 堆**，再到现在的 **元空间 + 堆**。

+ **概念**上：**方法区** 包含 **运行时常量池**（含字符串常量池）

+ **物理**上：

  + **字符串常量池**在堆中，比如 `new String()` 就在堆中；
  + **运行时常量池**（不含字符串常量池）（类的元数据）则在元空间（本地内存）中，比如 `xx.class` 类文件的字段、方法、接口等描述信息，以及其他的常量池信息。

## 7、栈和堆的区别

|    区别点    |                       栈（stack）                        |                          堆（heap）                          |
| :----------: | :------------------------------------------------------: | :----------------------------------------------------------: |
|   申请方式   |                       系统自动分配                       |                     程序员申请并指明大小                     |
| 申请后的响应 |    系统剩余空间大于申请空间，则分配，否则报栈溢出异常    | 遍历空闲内存地址链表，寻找第一个大于申请空间的堆节点，从链表中删除该记录，并分配给堆 |
| 申请内存限制 | 由高向低地址扩展，连续的内存区域，栈顶地址和容量是固定的 | 由低向高地址扩展，不连续的内存区域（即空闲内存链表的遍历方式） |
| 空间默认大小 |                         默认 1M                          |                 默认物理内存的1/8（有争议）                  |
| 空间申请方式 |                 可通过 `-Xss2048k` 修改                  |        可通过 `-Xms512m -Xmx4g` 设置堆 初始值、最大值        |
|   申请效率   |                   系统自动分配，速度快                   |          由 `new` 分配内存，速度比较慢，易产生碎片           |

## 8、常量池

### 附：运行时常量池（逻辑：方法区内；物理：元空间）

`Class` 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种 **字面量**（Literal）和 **符号引用**（Symbolic Reference）的 **常量池表(Constant Pool Table)** 。

+ **字面量** 是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量
+ **符号引用** 包括类符号引用、字段符号引用、方法符号引用和接口方法符号引用。

**常量池表** 会在类加载后存放到方法区的 **运行时常量池** 中。

**运行时常量池** 的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。

当 **常量池** 无法再申请到内存时会抛出 `OutOfMemoryError` 错误。

### 附：字符串常量池（逻辑：方法区；物理：堆）

> 字符串常量池 属于运行时常量池。

**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了**避免字符串的重复创建**。

JDK1.7 之前，**字符串常量池**存放在**永久代**。JDK1.7 **字符串常量池**和**静态变量**从**永久代**移动了 Java **堆**中，如下图所示。

![image-20220731140235334](https://img.zxdmy.com/2022/202207311402801.png)

> **JDK 1.7 为什么要将字符串常量池移动到堆中？**
>
> 因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集（Full GC）的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够**更高效及时地回收字符串内存**。

> + **运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的；**
>
> + **Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。**

### 附：直接内存（不是 运行时数据区 的部分）

> **直接内存并不是虚拟机运行时数据区的一部分**，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 错误出现。

JDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据**。

本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。