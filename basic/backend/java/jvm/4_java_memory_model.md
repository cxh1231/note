## 1、Java 内存模型（JMM）

**Java 内存模型**（下文简称 **JMM**）就是在底层处理器内存模型的基础上，定义自己的多线程语义。它明确**指定了一组排序规则，来保证线程间的可见性**。

这一组规则被称为 **Happens-Before**，关系如下：

- **单线程规则**：一个线程中的每个动作都 happens-before 该线程中后续的每个动作
- **监视器锁定规则**：监听器的**解锁**动作 happens-before 后续对这个监听器的**锁定**动作
- **volatile 变量规则**：对 volatile 字段的写入动作 happens-before 后续对这个字段的每个读取动作
- **线程 start 规则**：线程 **start()** 方法的执行 happens-before 一个启动线程内的任意动作
- **线程 join 规则**：一个线程内的所有动作 happens-before 任意其他线程在该线程 **join()** 成功返回之前
- **传递性**：如果 A happens-before B, 且 B happens-before C, 那么 A happens-before C

![image-20220810111518532](https://img.zxdmy.com/2022/202208101115126.png)

Java 提供了几种语言结构，包括 `volatile`， `final` 和 `synchronized` ，它们旨在帮助程序员向**编译器**描述程序的并发要求，其中：

- **volatile** ： 保证**可见性**和**有序性**（禁止代码重排）
- **synchronized** ： 保证**可见性**和**有序性**；通过**管程（Monitor）**保证一组动作的**原子性**（不保证禁止代码重排）
- **final** ： 通过禁止 **在构造函数初始化** 和 **给 final 字段赋值** 这两个动作的重排序，保证 **可见性**（如果 **this 引用逃逸** 就不好说可见性了）

编译器在遇到这些关键字时，会插入相应的内存屏障，保证语义的正确性。

> 总之，**Java 内存模型** 描述的是**多线程对共享内存修改后彼此之间的可见性**，另外，还**确保正确同步的 Java 代码可以在不同体系结构的处理器上正确运行**。