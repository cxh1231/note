## 1、类的生命周期概述

![image-20220816200049111](https://img.zxdmy.com/2022/202208162000525.png)



一个类从被加载到虚拟机内存中开始，到从内存中卸载，整个**生命周期**需要经过七个阶段：

![image-20220729172031135](https://img.zxdmy.com/2022/202207291720677.png)

**系统加载 `Class` 类型的文件** 包含 **加载**、**链接** 和 **初始化** 三步。

## 2、类加载

**加载** 是类生命周期的第一步，主要完成下面 `3` 件事情：

1. 通过全类名获取定义此**类的二进制字节流**
2. 将字节流所代表的**静态存储结构转换为方法区的运行时数据结构**
3. 在**内存**中生成一个代表该类的 `java.lang.Class` 对象，作为**方法区**这些数据的访问**入口**

一个 **非数组类** 的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步还可以自定义**类加载器**去控制字节流的获取方式（重写一个类加载器的 `loadClass()` 方法）。

> **数组类型** 不通过类加载器创建，它 **由 Java 虚拟机直接创建。**

> 所有的类都由类**加载器**加载，加载的作用就是**将 `.class`文件加载到内存**。

加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式**存储在方法区**之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。

**类型数据** 妥善安置在**方法区**之后，会在Java**堆内存**中实例化一个 `java.lang.Class` 类的对象， 这个对象将作为程序访问方法区中的类型数据的外部接口。

### 2.1 三大类加载器

**JVM** 中内置了三个重要的 `ClassLoader`，除了 `BootstrapClassLoader` 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`：

1. **BootstrapClassLoader(启动类加载器)** ：最顶层的加载类，由 `C++` 实现，负责加载 `%JAVA_HOME%/lib`目录下的 jar 包和类或者被 `-Xbootclasspath`参数指定的路径中的所有类。
2. **ExtensionClassLoader(扩展类加载器)** ：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 `jar` 包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的 `jar` 包。
3. **AppClassLoader(应用程序类加载器)** ：面向我们用户的加载器，负责加载 `当前应用 classpath` 下的所有 `jar` 包和`类`。
4. **用户自定义类加载器**，用户通过继承 `java.lang.ClassLoader` 类的方式自行实现的**类加载器**。

### 2.2 双亲委派机制

每一个类都有一个对应它的**类加载器**。

系统中的 `ClassLoader` 在协同工作的时候会默认使用 **双亲委派模型** 。

在 **类加载** 时，系统会首先判断当前类是否被加载过：

+ 已经被加载的类会直接返回，否则才会尝试加载。

加载的时候，首先会把该请求委派给**父类加载器**的 `loadClass()` 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 `BootstrapClassLoader` 中。

+ 当父类加载器无法处理时，才由自己来处理。

+ 当父类加载器为 `null` 时，会使用启动类加载器 `BootstrapClassLoader` 作为父类加载器。

![image-20220731153739081](https://img.zxdmy.com/2022/202207311537586.png)

> **null 并不代表没有父类加载器，而是 `BootstrapClassLoader`** 。
>
> 类加载器之间的“父子”关系不是通过继承来体现的，是由“**优先级**”来决定。

**亲委派模型的好处：**

双亲委派模型**保证了 Java 程序的稳定有序**，可以**避免类的重复加载**（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也**保证了 Java 的核心 API 不被篡改**。

如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 `java.lang.Object` 类的话，那么程序运行的时候，系统就会出现多个不同的 `Object` 类。

**自定义类加载器：**

除了 `BootstrapClassLoader` ，其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`。

如果我们要自定义自己的类加载器，需要继承 `ClassLoader`。

## 3、类连接

> **加载阶段** 和 **连接阶段** 的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能已经开始了。

#### 验证

**验证阶段** 主要对文件格式、元数据、字节码、符号引用 进行验证。

![image-20220731154258988](https://img.zxdmy.com/2022/202207311543209.png)

#### 准备

**准备阶段是正式为 `类变量` 分配内存并 `设置类变量初始值` 的阶段**，这些内存都将在方法区中分配。

详情如下：

+ **准备阶段** 只对 **类变量** 进行内存分配（即 Class Variables ，静态变量，被 `static` 关键字修饰的变量），不包括 实例变量（实例变量会在对象实例化时随着对象一块分配在 Java 堆中。）
+ 从概念上讲，类变量所使用的内存都应当在 **方法区** 中进行分配。而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的**字符串常量池**、**静态变量**等移动到**堆**中，这个时候类变量则会随着 `Class` 对象一起存放在 Java 堆中。
+ 这里所设置的**初始值**，通常情况下是数据类型默认的零值（如 0、0L、null、false 等）
    + 如： `public static int value=111` ， value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。
    + 但是：`public static final int value=111` ，那么准备阶段 value 的值就被赋值为 111。

#### 解析

**解析阶段** 是虚拟机将常量池内的`符号引用替换为直接引用`的过程。

解析动作主要针对`类或接口`、`字段`、`类方法`、`接口方法`、`方法类型`、`方法句柄`和`调用限定符` 7 类符号引用进行。

+ **符号引用**就是一组符号来描述目标，可以是任何字面量。
+ **直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

> **解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程**，也就是得到类或者字段、方法在内存中的指针或者偏移量。

## 4、类初始化

**初始化阶段** 是执行初始化方法 `<clinit> ()` 的过程，是类加载的最后一步，这一步 `JVM` 才开始真正执行类中定义的 `Java` 程序代码(**字节码**)。

> 说明： `<clinit> ()`方法是编译之后自动生成的。

对于`<clinit> ()` 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 `<clinit> ()` 方法是**带锁线程安全**，所以在多线程环境下进行类初始化的话可能会引起多个进程阻塞，并且这种阻塞很难被发现。

以下 5 种情况，必须 **对类进行初始化**：

1. 当遇到 `new` 、 `getstatic`、`putstatic` 或 `invokestatic` 这 4 条直接码指令时（比如 `new` 一个类， 读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时）：
    - 当 jvm 执行 `new` 指令时会初始化类。即**当程序创建一个类的实例对象**。
    - 当 jvm 执行 `getstatic` 指令时会初始化类。即**程序访问类的静态变量**(不是静态常量，常量会被加载到运行时常量池)。
    - 当 jvm 执行 `putstatic` 指令时会初始化类。即程序给类的静态变量赋值。
    - 当 jvm 执行 `invokestatic` 指令时会初始化类。即程序调用类的静态方法。
2. 使用 `java.lang.reflect` 包的方法对类进行**反射调用**时，如 `Class.forname("...")`, `newInstance()` 等等。如果类没初始化，需要触发其初始化。
3. 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。
4. 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 `main` 方法的那个类)，虚拟机会先初始化这个类。
5. `MethodHandle` 和 `VarHandle` 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 `findStaticVarHandle` 来初始化要调用的类。

另外：当一个接口中定义了 JDK8 新加入的**默认方法**（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化

## 5、类卸载

卸载类即该类的 Class 对象被 `GC`。

卸载类需要满足 3 个要求:

1. 该类的所有的实例对象都已被 GC，也就是说堆**不存在该类的实例对象**。
2. 该类在其他任何地方**没有被引用**
3. 该类的**类加载器的实例已被 GC**

> 由 jvm 自带的类加载器（ `BootstrapClassLoader`, `ExtClassLoader`, `AppClassLoader` ）加载的类是不会被卸载的，因为它们负责加载 JDK 提供的类。但由我们自定义的类加载器加载的类是可能被卸载的。