## 1、对象创建过程

> 在上一节中，JVM **类的加载机制**过程中，**类初始化** 阶段，是系统加载的 `Class` 类型文件的最后一步，其中有一条 **类初始化** 规则是：**遇到 `new` 直接码指令时，需要对类进行初始化**。

在`JVM`中 **对象** 的创建，我们从一个 `new` 指令开始，其大致过程如下：

![image-20220920214136061](https://img.zxdmy.com/2022/202209202141814.png)

1. 首先检查这个指令的参数是否能在常量池中定位到一个**类的符号引用**；
2. 检查这个符号引用代表的**类**是否已被**加载、解析和初始化**过。如果没有，就先执行相应的**类加载**过程；
3. **类加载检查** 通过后，接下来虚拟机将 **为新生对象分配内存**；
4. 内存分配完成之后，虚拟机将分配到的**内存空间**（但不包括对象头）都**初始化**为**零**值；
5. 接下来**设置对象头**，请求头里包含了**对象是哪个类的实例**、如何才能找到**类的元数据信息**、**对象的哈希码**、**对象的GC分代年龄** 等信息。

## 2、内存分配方式

**内存分配**有两种方式：

+ **指针碰撞**（Bump The Pointer）
+ **空闲列表**（Free List）

**指针碰撞**：假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。

**空闲列表**：如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。

两种方式的选择由Java堆是否规整决定，Java堆是否规整是由选择的垃圾收集器是否具有压缩整理能力决定的。

## 3、对象内存布局

在`HotSpot`虚拟机里，**对象**在 **堆内存** 中的存储布局可以划分为三个部分：

+ 对象头（Header）
+ 实例数据（Instance Data）
+ 对齐填充（Padding）

![image-20220920215145879](https://img.zxdmy.com/2022/202209202151980.png)

#### 对象头：

**对象头** 主要由两部分组成：

+ 第一部分存储**对象自身的运行时数据**：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，官方称它为`Mark Word`，它是个动态的结构，随着对象状态变化。
+ 第二部分是 **类型指针**，指向对象的类元数据类型（即对象代表哪个类）。
+ 如果对象是一个Java数组，那还应该有一块**用于记录数组长度的数据**。

`Mark Word` 在32位 JVM 中的存储结构如下图所示：

![image-20220923210130272](https://img.zxdmy.com/2022/202209232101959.png)

`Mark Word` 在64位 JVM 中的存储结构如下图所示：

![image-20220923210138943](https://img.zxdmy.com/2022/202209232101393.png)

结构中：

+ **锁标志位**（`lock`）：区分锁状态，11 时表示对象待GC回收状态，只有最后 2 位锁标识（11）有效；
+ **是否偏向锁**（`biased_lock`）：由于无锁和偏向锁的锁标识都是 01，没办法区分，这里引入一位的偏向锁标识位；
+ **分代年龄**（`age`）：表示对象被GC的次数，当该次数到达阈值的时候，对象就会转移到老年代。
+ **对象的hashcode**（`hash`）：运行期间调用 `System.identityHashCode()` 来计算，延迟计算，并把结果赋值到这里。当对象加锁后，计算的结果31位不够表示，在偏向锁，轻量锁，重量锁，hashcode会被转移到Monitor中。
+ **偏向锁的线程ID**（`JavaThread`）：偏向模式的时候，当某个线程持有对象的时候，对象这里就会被置为该线程的ID。 在后面的操作中，就无需再进行尝试获取锁的动作。
+ `epoch`：偏向锁在CAS锁操作过程中，偏向性标识，表示对象更偏向哪个锁。
+ `ptr_to_lock_record`：轻量级锁状态下，指向栈中锁记录的指针。当锁获取是无竞争的时，JVM使用原子操作而不是OS互斥。这种技术称为轻量级锁定。在轻量级锁定的情况下，JVM通过CAS操作在对象的标题字中设置指向锁记录的指针。
+ `ptr_to_heavyweight_monitor`：重量级锁状态下，指向对象监视器Monitor的指针。如果两个不同的线程同时在同一个对象上竞争，则必须将轻量级锁定升级到Monitor以管理等待的线程。在重量级锁定的情况下，JVM在对象的ptr_to_heavyweight_monitor设置指向Monitor的指针。

#### 实例数据：

**实例数据**用来存储对象真正的有效信息，也就是我们在程序代码里所定义的各种类型的字段内容，无论是从父类继承的，还是自己定义的。

#### 对齐填充：

**对齐填充**不是必须的，没有特别含义，仅仅起着占位符的作用。

## 4、对象的访问定位

> HotSpot虚拟机主要使用 **直接指针来进行对象访问**。

Java程序会通过栈上的 `reference` 数据来**操作堆上的具体对象**。

由于reference类型在《Java虚拟机规范》里面只规定了它是一个**指向对象的引用**，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有**使用句柄**和**直接指针**两种：

+ **使用句柄访问**：Java堆中将可能会划分出一块内存来作为**句柄池**，`reference`中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，其结构如图所示：

![image-20220920215353133](https://img.zxdmy.com/2022/202209202153208.png)

+ **使用直接指针访问**：Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，`reference`中**存储的直接就是对象地址**，如果只是访问对象本身的话，就不需要多一次间接访问的开销，如图所示：

![image-20220920215358656](https://img.zxdmy.com/2022/202209202153872.png)

这两种对象访问方式各有**优势**：

+ 使用**句柄**来访问的最大好处就是`reference`中存储的是**稳定句柄地址**，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而`reference`本身不需要被修改。
+ 使用**直接指针**来访问最大的好处就是**速度更快**，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。

## 5、对象的各种问题

### 5.1 new 对象时的堆抢占问题与线程安全问题

在 `JVM` 里 `new` 对象时，堆会发生抢占问题。

每一次 new 对象时，指针就会向右移动一个对象 `size` 的距离。当线程 A 正在给 A 对象分配内存，指针还没有来的及修改时，另一个为 B 对象分配内存的线程 B，又引用了这个指针来分配内存，这就发生了抢占。

![image-20220923205459829](https://img.zxdmy.com/2022/202209232055086.png)

JVM 中可以采用两种方案解决此问题：

1. 采用 `CAS` 分配重试的方式来**保证更新操作的原子性**；
2. 每个线程在 Java 堆中**预先分配**一小块内存，也就是**本地线程分配缓冲**（Thread Local Allocation
   Buffer，`TLAB`），要分配内存的线程，先在本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。

### 5.2 内存溢出与内存泄露问题

+ **内存泄露**就是申请的内存空间没有被正确释放，导致内存被白白占用。
+ **内存溢出**就是申请的内存超过了可用内存，内存不够了。

两者关系：**内存泄露可能会导致内存溢出**。

#### 内存溢出

在`JVM`的几个内存区域中，除了程序计数器外，其他几个运行时区域 **都有发生内存溢出**（OOM）异常的可能，重点关注**堆**和**栈**。

内存溢出主要有以下可能：

+ JVM 对象过多
+ 虚拟机栈过多
+ ……

**堆 溢出**：

Java 堆用于储存对象实例，只要 **不断创建不可被回收的对象**，比如 **静态对象**，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常（`OutOfMemoryError`）。

```java
/**
 * VM参数： -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
 */
public class HeapOOM {
   static class OOMObject {

   }
   public static void main(String[] args) {
      List<OOMObject> list = new ArrayList<OOMObject>();
      while (true) {
         list.add(new OOMObject());
      }
   }
}
```

**虚拟机栈 溢出**：

JDK 使用的HotSpot虚拟机的 **栈内存** 大小是固定的，我们可以把栈的内存设大一点，然后不断地去创建线程，因为操作系统给每个进程分配的内存是有限的，所以到最后，也会发生 `OutOfMemoryError` 异常。

```java
/**
 * vm参数：-Xss2M
 */
public class JavaVMStackOOM {
   private void dontStop() {
      while (true) {

      }
   }

   public void stackLeakByThread() {
      while (true) {
         Thread thread = new Thread(new Runnable() {
            public void run() {
               dontStop();
            }
         });
         thread.start();
      }
   }

   public static void main(String[] args) throws Throwable {
      JavaVMStackOOM oom = new JavaVMStackOOM();
      oom.stackLeakByThread();
   }
}
```

#### 内存泄露

**内存泄漏** 可能的原因有很多种：

+ 静态集合类
+ 单例模式
+ 连接（IO / 数据）未释放
+ 变量作用域过大
+ hash 值发生变化
+ ThreadLocal 使用不当

1、**静态集合类引起内存泄漏**

静态集合的生命周期和 JVM 一致，所以静态集合引用的对象不能被释放。

```java
public class OOM {
   static List list = new ArrayList();

   public void oomTests(){
      Object obj = new Object();
      list.add(obj);
   }
}
```

2、**单例模式**

和上面的例子原理类似，单例对象在初始化后会以静态变量的方式在 JVM 的整个生命周期中存在。如果单例对象持有外部的引用，那么这个外部对象将不能被 GC 回收，导致内存泄漏。

3、**数据连接、IO、Socket等连接**

创建的连接不再使用时，需要调用 close 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收。

4、**变量不合理的作用域**

一个**变量的定义作用域大于其使用范围**，很可能存在内存泄漏；或不再使用对象没有及时将对象设置为 null，很可能导致内存泄漏的发生。

```java
public class Simple {

   Object object;

   public void method1(){
      object = new Object();
      //...其他代码
      //由于作用域原因，method1执行完成之后，object 对象所分配的内存不会马上释放
      object = null;
   }
}
```

5、**hash值发生变化**

对象`Hash`值改变，使用HashMap、HashSet等容器中时候，由于对象修改之后的Hash值和存储进容器时的Hash值不同，所以无法找到存入的对象，自然也无法单独删除了，这也会造成内存泄漏。

说句题外话，这也是为什么String类型被设置成了不可变类型。

6、**ThreadLocal使用不当**

`ThreadLocal`的**弱引用**导致内存泄漏也是个老生常谈的话题了，使用完ThreadLocal一定要记得使用remove方法来进行清除。

