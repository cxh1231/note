### NoSQL四大分类

### KV键值对

Redis

#### 文档数据库（bson格式和json格式相同）

MongoDB

ConthDB

#### 列存储数据库

HBase

分布式文件系统

#### 图关系数据库

存放关系，是类似于图论中的图

#### 对比

| 分类         | 场景                                                | 数据模型                                         | 优点                                             | 缺点                                         |
| ------------ | --------------------------------------------------- | ------------------------------------------------ | ------------------------------------------------ | -------------------------------------------- |
| 键值对       | 内容缓存，处理高访问负载也用于一些日志系统          | KV对，通常用hash table实现                       | 查找快                                           | 数据无结构话，通常被当做字符串或者二进制数据 |
| 列存储       | 分布式文件系统（Hbase）                             | 列簇式存储，同列数据放在一起                     | 查找快，扩展性强，容易进行分布式扩展             | 功能有限                                     |
| 文档型数据库 | Web应用，value是结构化的，数据库可以了解value的内容 | KV对，V是结构化的数据，数据库可以了解value的内容 | 数据结构要求不严格，表结构可变，不需要定义表结构 | 查询性能能不高，缺乏统一的查询语法           |
| 图关系数据库 | 社交网络，推荐系统                                  | 图结构                                           | 利用结构关系算法，比如最短路径，N度关系查找      | 考虑整个图进行计算，不适应分布式和集群       |

### Redis概念

remote dictionary server远程字典服务

C语言编写，支持网络、可基于内存也可持久化的日志型，key_value数据库

周期性的把更新数据写入磁盘，或把修改操作写入追加的记录文件

### Redis的作用

1. 内存存储，持久化，
2. 效率高，用于高速缓存
3. 发布订阅系统
4. 地图信息分析
5. 计时器，计数器



### Redis基本数据类型

![](E:\短暂视界\面经\八股git\mianshibagu\img\redis-数据结构.png)

#### String类型

字符串，简单动态字符串，字符数组和一个数组长度

#### List 列表

双向链表（压缩列表），因为队列和栈等结构都是头尾的操作，所以可以模拟这些数据结构，

#### set 集合

集合，内容唯一

#### zset 有序集合

有一个可重复的score用于排列

#### Hash哈希



### 三种特殊数据类型

#### 地理位置

记录经纬度表示的位置，可以查看周围的人，或是计算距离等

#### Hyperloglog

基数（不重复的元素），可以接受误差

优点：内存固定，2^64不同元素的技术，只需要12KB内存

#### BitMap

只记录两个状态0和1

### 事务

Redis事务的本质，一组命令的集合，一个事务的所有命令都会被序列化，在事务的执行过程中，会按照顺序执行

Redis的事务没有隔离级别的概念

所有的命令在事务中，并没有直接被执行，只有发起执行命令的时候才会执行

单条命令是原子性的，事务不保证原子性

#### 事务

- 开启事务`multi`
- 命令入队
- 执行事务`exec`/取消事务`discard`



##### 监控 watch

算是乐观锁的机制，监控的时候记录当前值，如果修改的时候这个值发生了变化就会执行失败



### Redis.Config



### Redis持久化



#### RDB(Redis DataBase)

Redis单独创建一个子进程进行持久化

子进程现将数据写入临时的RDB文件，完成持久化之后，再替换文件

**触发机制**

save规则满足

flushall命令

退出Redis

**优点**：

适合大规模的数据恢复

对数据完整性要求不高

**缺点**

只保留最后一次的结果

fork进程会占用资源



#### AOF(Appnd only file)

把所有的命令（写入命令）记录下来，恢复时全部执行一遍，只允许追加文件，不可以改写，redis启动之初会读取这个数据

**优点**

每一次修改都同步，保证文件的完整性

同步周期设置为每一秒，可能会定时一秒的数据

从不同步，小路最高

**缺点**

aof文件远大于rdb，修复速度也比rdb慢

aof的运行效率比rdb慢

### 发布订阅

实现方式是频道哈希链，键是频道，值是订阅者链表



### Redis主从复制

**作用**

1. 实现数据的热备份，主从复制
2. 故障恢复：主节点出现问题的时候，从节点提供服务。
3. 负载均衡：读写分离
4. 高可用（集群）：

**复制原理**

从机向主机发送一条sync命令

> **全量复制**：从机接收主机的数据库文件
>
> **增量复制**：主机将所有新的用于修改的命令传给从机

#### 链路式的从复制

一个主机连接一个从机，新的从机是下一个从机的主机

主机失效的时候，下一个从机变成主机，但是其他节点需要手动连接到这个主节点。

#### 哨兵模式

哨兵：一个独立运行的进程，发送命令等待Redis服务器响应，监控多个Redis实例，实际使用中可能会有多个哨兵

两个作用：

- 监控Redis服务器运行状态
- 加测到master宕机，会将slave切换为master，通过发布订阅模式通知其他服务器修改配置文件切换主机



单独的某个哨兵检测到宕机（主观下线）

检测到服务器不可用的哨兵达到一定定制的时候，哨兵之间进行一次投票，结果有一个哨兵发起，进行故障转移，切换成功后通过发布订阅模式让各个哨兵把自己监控的服务器切换为主机。（客观下线）



如果原本的主机下线后重新接入，会归入新的主机下，变为从机

**优点**

1. 主从复制
2. 故障转移
3. 自动的故障转移，更加健壮

**缺点**

1. 在线扩容麻烦
2. 配置麻烦

### 缓存穿透和雪崩

#### 缓存穿透

查询数据，缓存没有命中，于是向持久层数据库查询。用户过多的手，缓存没有命中，对持久层数据库的请求过多（主要是对持久层也没有的数据的请求，因为持久层没有，所以不会有缓存，那么查多少次，都会访问持久层）

解决方法：

存储空值

bloom过滤器

#### 缓存击穿

数据库中有数据，但是缓存失效或过期，并发用户特别多，同时访问数据库带来数据访问量的增大

解决方案：

预先设置热门数据：将高峰访问数据加载如内存，延长存储时间

使用分布式锁：缓存失效的时候，不是立即查询数据库，先检测是否加锁，如果加锁说明有进程进行查询，这里只需要等待从缓存中查结果

#### 缓存雪崩

缓存大面积失效，比如设置的到期时间相同，过多请求到达持久化层

原因：redis宕机，过期时间相同

解决方案：

多级缓存：negix，redis，+其他缓存

使用锁和队列：防止大量请求访问持久化层，会影响并发性

设置过期标志更新缓存：数据过期前让后台进程更新缓存

随机化过期时间



