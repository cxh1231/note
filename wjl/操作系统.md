## IPC进程通信

### 为什么需要进程通信

数据传输、资源共享、通知事件、进程控制

### 管道

#### 管道原理

调用pipe函数在内核中开辟缓冲区用于通信，他有一个读端，一个写端；pipefd[0]是读端，pipefd[1]是写端。管道在用户程序看来是一个打开的文件，通过read(pipefd[0])或者write(pipefd[1])向这个文件写数据，起始是在读写内核缓冲。

==管道是VFS的虚拟文件节点，虚拟文件节点的inode在物理内存页，这个内存页是在内核空间中的==

#### 关于管道关闭的特殊情况

1. 写端关闭，读端不关闭
   读完剩余数据后read会返回0，如同读到文件尾
2. 读端关闭，写端不关闭
   写入进程向管道写数据的时候会收到SIGPIPE信号，SIGPIPE默认的方式是关闭进程
3. 写端不关闭，不写数据，读端不关闭
   读到中剩余的数据北图去后read会阻塞
4. 读端不关闭，也不读数据，写端不关闭
   写端写满之后write会阻塞，直到管道有空位置才会写入数据

#### 缺陷

匿名管是单向的，需要建立两个管道或者`sockpair`才能双向通信

只能用于具有亲缘关系的进程通信

### 命名管道

提供一个路径名用于关联，以FIFO文件的形式存储在文件系统中

API

```cpp
#include <sys/stat.h>
int mknod(const char* pathname, mode_t mode, dev_t dev);
int mkfifo(const char* pathname, mode_t mode);
/**
 *成功返回0，失败返回-1
 *mode是命名管道的模式，指明存取权限
 *path为全路径名
 *dev为设备值
*/
```

#### 特点

命名管道是存在==硬盘上的文件==需要先使用open打开，管道是内存中的特殊文件

==其本质是一个伪文件(实为**内核缓冲区**)==

通信进程不需要有亲缘关系

### 消息队列

特点：

消息随机查询，实际上是按照消息类型读取

允许一个或多个进程想他写入或者读取消息

消息读取后会被删除

消息队列有唯一标识符，整个系统中唯一

消息队列是消息链表，放在内存中，由内核**维护**，只有重启或者人工删除消息队列式，消息队列才会删除否则一直存在于系统中

==内核中的链表==

#### API

```cpp
#include <sys/msg.h>
#include <sys/types.h>
#include <sys/ipc.h>

typedef struct _msg
{
    long mtype;
    char mtext[100];
};
/**
 *pathname路径名，proj_id项目ID，非0低8位有效
 */
key_t ftok(const char* pathname, int proj_id);
/**
 *创建新的或者打开一个存在的消息队列
 *msgflg模型
 */
int msgget(key_t， int msgflg);
/**
 *接收msqid
 */
int msgrcv(int msqid, void*msg_ptr, size_t msg_sz, long int msg_type, int msgflg);
/**
 *发送消息（消息最大长度是100个字节？）
 */
int msgsnd(int msqid, const void * msg_ptr, size_t msg_sz, int msgflg);
/**
 *控制消息队列，删除或者备份或是重新写入
 */
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

key标识消息队列，通过fotk()获得

### 共享内存（shm）

将不同进程的虚拟内存映射到同一个物理内存上

API

```cpp
#include <sys/ipc.h>
#include <sys/shm.h>
/**
 *pathname路径名，proj_id项目ID，非0低8位有效
 */
key_t ftok(const char* pathname, int proj_id);
/**
 *失败返回1，成功返回标识符，创建共享内存
 */
int shmget(key_t key, size_t size, int shmflg);
/**
 *将一个内存端映射到进程数据段中
 *shmaddr共享映射地址，为NULL则由系统指定。
 */
void* shmat(int shmid, const void*shamaddr, int shmflg);
/**
 *将共享内存和当前进程年份里，智慧断开不回收，返回成功与否
 */
int shmdt(const void * shamddr);
/**
 *存放或者修改内存属性
*/
int shmctl(int shmid, int cmd, struct shmid_ds * buf);

```

### 信号量

信号量主要是用来保护共享资源的，信号量为整的时候，说明它空闲，所有测试的线程可以锁定二使用它。若为0，说明天被占用，测试线程要进入睡眠队列等待唤醒

工作原理，PV原语

1. 信号量分类：
   1. 内核信号量
   2. POSIX信号量
      1. 有名信号量，保存在文件中可以用去线程也可以用于进程
      2. 无名信号量保存在内存中，只用于线程同步
   3. SYSTEM信号量
      1. POSIX信号量是非负整数
      2. SYSTEM V信号量是一锅多个信号量的机会，是为IPC服务的，常用于进程同步

#### 内核信号量

一个任务想要获得已经被占用的信号量的时候，信号量会将其放入一个**等待队列**，然后让其睡眠

当持有信号量的进程将信号释放后，处于等待队列的任务会被唤醒，并让其获得信号量

内核信号量有读写形式的信号量，

读者可重入，必须是写者不在请求的情况下

写者独占，直到没有任何访问者



### 信号量POSIX

API

```cpp
#include <semaphore.h> 
int sem_init(sem_t * sem, int pshared, unsigned int val); //创建信号量并附初始值
int sem_wait(sem_t* sem); //P操作，减一信号量，申请资源
int sem_trywait(sem_t * sem); //非阻塞操作，成功0，失败-1
int sem_post(sem_t* sem); //V操作，唯一的可冲入，这个是唤醒任意进程
int sem_getvalue(sem_t * sem, int *val); //获取
int sem_destory(sem_t * sem);	//销毁信号量
```

有名信号量

主要用于进程同步，保护共享内存区的数据，创建在`/dev/shm`目录下

API

```c++
sem_t* sem_open(const char* name, int oflag, mode_t mode, int value);//有名信号量是在/dev/shm下的文件，只能写一级路径名，不能写多层路径
int sem_close(sem_t *sem);			//关闭描述符
int sem_unlink(const char*name)		//删除信号量
```

### System V信号量

信号量的集合，不是单个信号量，头文件是`<sys/ipc.h>`

API

```cpp
struct semid_ds{
    struct ipc_prem sem_perm;
    struct sem* sem_base; 	//信号量数组指针，每个元素对应一个信号量
    ushort sem_nsems;		//信号量个数
    time_t sem_otime;
    time_t sem_ctime;
};
struct sem {
    ushrot semval;		//
    short sempid;		//最后一次返回的进程号
    ushrot semncnt;		//
    ushrot semzcnt;		//
};
int semget(key_t key, int nsems, int oflag);		//创建一个信号量或是访问一个已经存在的信号量集，key通过ftok得到,创建几个，读写权限，失败返回-1
int semop(int semid, struct sembuf* opsptr, size_t ops) //设置信号量的值，PV操作
int semctl(int semid, int semnum, int cmd, ...);		//对信号集进行操作
```

### 进程

![](E:\短暂视界\面经\八股git\mianshibagu\img\_操作系统_进程_安之若素.png)

### 操作系统的角色

《操作系统导论》：一个软件负责让程序运行变得容易，允许程序共享内存与设备交互以及其他工作，这些软件成为操作系统。

三大部分：

1. 虚拟化：将物理资源转换为通用、且易于使用的虚拟形式
2. 并发：操作系统同时处理很多事情
3. 持久化：数据的持久存储

管理计算机硬件和软件资源的程序

五大功能：

进程管理（控制、通信、同步），存储管理（扩充，分配回收，保护），设备管理，作业管理，文件管理





#### 作业和进程

1.作业是用户向计算机提交任务的任务实体。在用户向计算机提交作业作业后，系统将它放入外存中的作业等待队列中等待执行。而进程则是完成用户任务的执行实体，是向系统申请分配资源的基本单位。任一进程，只要它被创建，总有相应的部分存在于内存中。

2.一个作业可由多个进程组成，且必须至少由一个进程组成，反过来不成立。

3.作业的概念主要用在批处理系统中，像UNIX这样的分时系统中就没有作业的概念。而进程的概念则用在几乎所有的多道程序系统中。




### 进程的概念

编译代码成的可执行文件只是存储在硬盘的静态文件，运行时被加载到内存，CPU执行内存中的指令，这个运行的程序被称为进程

进程是运行时程序的封装，是操作系统资源调度和分配的基本单位

### 中断执行过程

![](E:\短暂视界\面经\八股git\mianshibagu\img\中断.png)

1. 前半部分
   1. 关中断
   2. 保存断点，（压栈程序计数器PC）
   3. 识别中断，找到中断服务程序
   4. 保护现场
   5. 开中断
2. 执行中断服务程序
3. 中断返回
   1. 关中断
   2. 恢复现场
   3. 开中断

### 进程表

操作系统维护者一张表格，进程表

么个进程占有一个表项（进程控制块PCB）

表项包含进程状态信息

1.标识符（内部的和外部的）2.处理机状态，寄存器的值，程序计数器，对战指针内存信息，文件资源信息，调度信息（保证进程随后能再次启动）

### 并发和并行

**并发**：单个核心段时间内分别执行多个进程，是并发

**并行**：多个核心同时执行多个进程成为并行

对于并发来讲，CPU需要从一个进程切换到另一个进程，这个过程需要保存进程的状态

### 进程状态

![](E:\短暂视界\面经\八股git\mianshibagu\img\进程状态转换.jpg)

运行、就绪、阻塞三个状态

对于组阻塞状态的进程，进程会占用内存空间，把阻塞的进程换到磁盘里，进程不再占用物理内存叫挂起

sleep和Ctrl+Z也会导致进程挂起

三态转换

五态转换（加了创建和结束）

七态转换（加了就绪挂起-阻塞的挂起）
阻塞挂起：进程在外存，等待某个事件的出现
就绪挂起：进程在外存，放入内存就可以运行（变成就绪状态）

### 进程控制块(PCB)

1. 进程描述符（内部标识符用于系统识别，用户标识符用于用户识别）
2. 进程控制和管理信息：进程状态，优先级
3. 进程资源：虚拟内存信息，文件列表，IO设备信息
4. 处理机状态：寄存器的值，PC

通过链表组织，就绪队列或者阻塞队列等，方便增删

### 进程切换慢的问题

进程切换涉及虚拟内存的切换，虚拟地址的转换需要两次访问内存一次是找页表，一次是找数据，操作系统会用cache页表内容，就是块表，进程切换后，页表也要切换，快表失效，cache命中率降低，寻址变慢

### 守护进程

守护进程是指在后台运行，没有终端与他相连的进程，独立于控制终端，周期性执行某种任务

```cpp
#include <unistd.h>
/**
 *nochar为0则改变路径到root ‘/’
 *noclose为0表示标准输入输出和错误改为/dev/null
 */
int daemon(int nochdar, int noclose);
```

### 僵尸进程

多进程内关系，父进程一般需要跟踪子进程都退出状态，子进程退出，父进程运行，子进程等到父进程捕获了子进程的退出状态之后，子进程在真正结束。子进程结束后，父进程读取状态前，自己成就是僵尸进程。

设置僵尸进程的目的是维护子进程的信息，以便父进程在以后的某个时间获取，这些信息包含继承的ID，进程的终止状态，以及进程使用的CPU时间，父进程调动wait和waitpid的时候可以得到这些信息。

但是降至太会占据内核资源，所以需要避免僵尸进程产生或者like结束子进程的僵尸态

可以以让子进程使用`SIGCHLD`信号通知父进程，子进程结束

忽略SIGCHLD信号，init进程接管子进程

SIGCHLD的产生条件：

- 子进程终止
- 子进程接收到SIGSTOP信号停止时（kill -stop）
- 子进程处于停止状态，接收到SIGCONT(kill -cont)后唤醒

### 多进程

父进程创建子进程后，除了pid之外，父子进程所有部分几乎完全一样。

自己成在写数据的时候，会使用写时复制技术，蒋工的数据拷贝一份，之后再拷贝出的数据上操作；不是对统一数据进行操作；

如果子进程逍遥运行自己的代码段，还可以通过execv函数重新加载新的代码段，之后就和父进程独立开了

### 进程调度算法

> 批处理的调度

1. 先来先服务
2. 多作业优先
3. 最短剩余时间优先

> 交互式系统中的调度

1. 时间片轮转调度
2. 优先级调度
   为进程分配优先级，按照优先级进行调度，为了防止低优先级的进程等不到，会随着时间增加等待进程的优先级
3. 多级队列
   为需要连续执行多个时间片的进程考虑，设置多个队列，每个队列的时间片大小不同，进程在一个队列没执行完，会进入下一个队列，队列的优先级也不同，最上面的优先权最高，只有上一队列为空的时候，才能调度当前队列的进程

### 进程通信

1. 同一主机

   1. 管道
      1. 有名管道
      2. 无名管道
   2. 信号
   3. 共享内存
   4. 消息队列
   5. 信号量（同步方式/System V信号量和有名信号量）
   6. 存储映射
2. 不同主机

   1. 套接字（双向的管道）



#### 无名管道

管道不是普通文件，不属于某个文件系统，存在于内存中

对应一个内存缓冲区，大小由系统确定，

读是一次性操作

没有名字只用于亲缘进程通信

- 写端没关闭，读完缓冲区会阻塞
- 写端关闭，读完缓冲区会返回0
- 读端没关闭，写满会阻塞
- 读端关闭，写入会收到SIGPIPE，默认会让进程退出

#### 有名管道

管道作为FIFO文件是文件系统的中特殊文件，但是存在在内存中

进程退出后FIFO继续保存在文件系统中

FIFO有名字，无关进程可以访问，所以无名管道的通信可以说不是**"面向连接"**的，像是多对多的关系，读写上和无名管道类似

- 写端没有全部关闭，读完阻塞
- 写端全部关闭，读完返回0
- 读端没有全部关闭，写满阻塞
- 读端全部关闭，SIGPIPE

#### 共享存储映射（mmap）

存储映射（Memory-mapped I/O）是一个磁盘文件与存储空间中的缓冲区相映射

不用read和write的情况下完成I/O

![POSIX的共享内存](E:\短暂视界\面经\八股git\mianshibagu\img\POSIX的共享内存.png)

#### 消息队列

消息队列是，内存中保存的消息链表，消息体是固定大小的存储块（100Btye?）

没有释放队列或者关闭系统，消息队列会一直存在

缺点：

不及时，附件大小的有限制，单个消息的长度和队列的长度

用户态和内核态的切换

#### 信号

信号是软件中断，在软件层次上对中断机制的一种模拟是异步通信方式。

信号会导致一个运行的进程被另一个进程异步中断，专项处理突发时间

信号会直接进行用户空间进程和内核空间进程交互，你和金诚利用它来通知用户空间进程发生了那些时间

##### 信号特点

1. 简单
2. 信息少
3. 特定条件发送

##### 信号周期

信号产生， 在进程中注册，在进程中注销，执行处理函数

##### 信号编号

1-31常规信号

34-64试试信号

没有0/32/33信号

##### 几个典型信号

`SIGINT` <Ctrl+C>终止进程

`SIGSEGV` 多错误，访问内存出错

`SIGPIPE` 写入没有读端的管道

`SIGCHLD` 子进程状态变化

`SIGSTOP` kill -stop,有stop也有`SIGCONT`

`SIGKILL` kill -9

#### 不可重入函数、可重入函数

不可重入函数：

1. 不同任务调用这个函数时可能修改其他任务调用这个函数的数据，从而导致不可预料的后果
   - 使用静态数据
   - 函数体内调用malloc和free
   - 调用了标注I/O

可重入函数

可以被多个任务调用，不用担心会出错

#### SIGCHLD信号出现

子进程终止

子进程收到SIGSTOP

子进程处于停止状态，接收到SIGCONT后唤醒

#### 避免僵尸进程

1. 父进程wait或waitpid等待子进程结束
2. 认为处理SIGCHLD信号
3. 忽略SIGCHLD信号，交给init进程回收

#### 守护进程

1. 父进程脱离终端控制
2. 子进程简历新的会话
3. 父进程改变运行目录
4. 重设文件权限
5. 关闭文件描述符
6. 开始执行守护进程核心工作

## 线程

### 线程特点

1. 线程是轻量级的进程，也有PCB，创建线程使用底层函数和进程一样都是clone
2. 内核看线程和进程是一样的，有各自的PCB
3. 进程可以变成线程
4. Linux下，线程是最小的执行单位，进程是最小的分配资源单位

实际上`fork()`和`pthread_create()`函数都是调用`clone`

区别在于：

1. 复制地址空间出现进程
2. 共享地址空间出现线程

### 线程的实现

**（1）用户线程**

用户空间实现的线程，基于用户态的线程库管理

优点

1. 不需要内核参与，可以在不支持线程技术上的操作系统上实现
2. 线程库进行切换调度，不需要内核参与

缺点

1. 会被阻塞
2. 内核限制



**（2）内核线程**

操作系统管理调度

优点

1. 有点一个内核线程发起的阻塞不会影响其他线程
2. CPU资源分给线程，有更多CPU时间，适合多核系统

缺点

1. 占用内核资源
2. 开销大

### 线程共享资源

1. 文件描述符
2. 信号处理方式
3. 工作目录
4. 用户ID和组ID

### 线程非共享资源

1. 线程id
2. 处理器线程和栈指针
3. 栈空间
4. `errno`变量
5. 信号屏蔽字
6. 调度优先级

### 线程优缺点

优点

1. 并发性高

1. 开销小
2. 通信共享数据方便

缺点

1. 库函数不稳定
2. 调试、编写困难
3. 对信号支持不好

### 减少开销的原因

创建

销毁

切换

通信

资源

（多机分布）

### 线程的回收与退出

### 回收

`join()`，调用这个函数的线程将挂起等待直到对应的thread终止

### 分离

`detach`，进程一旦终止like回收资源，不保留终止状态

### 退出

`pthread_exit`，退出线程，资源不会释放

### 线程取消

`pthread_cancel`，取消线程，但不是实时的

`pthread_testcancel()`设置取消点

### 线程通信

线程共享内存区域，只需要将数据放在共享变量中就可以（全局或堆）

### 注：过快的线程

如果线程运行的很快，可能在pthread_create函数返回前终止，终止后可能江县称号和系统资源交给了其他线程，这个时候使用原本pthread_create返回的先后才能将有可能得到错误的线程号

可以采用一定的同步措施

```cpp
#include <pthread.h>
#include <semaphore.h>

int sem;
void* run(void* pthread_ptr){
    sem_wait(&sem);
}
int main(){
    sem_init(&sem, 0, 0);
    pthread_t the_thread;
	pthread_create(&thread, 0, run, 0);
    sem_post(&sem);
    pthread_join()   
    return 0;
}
```

### 注意事项

不取古文被回收的线程中的值

malloc和mmap申请的内存会被其他线程释放

避免fork

信号复杂语义很难和多线程共存，避免多线程引入信号机制



## 存储器

### 存储器层次

（1）寄存器

访问速度非常快

（2）CPU Cache

一般分成多级Cache（3级，L1和L2是单个核心独有，L3共享），

（3）内存

容量大，速度较慢

（4）SSD/HDD硬盘（外存）

持久存储，速度慢，需要IO

### 页置换算法

#### OPT 最佳页面置换算法

最欢在未来长时间不访问的页面，实际系统无法实现，因为不知道未来访问什么页面

#### 先进先出FIFO

#### 最近最久为未使用LRU

根据页面未被访问的市场永生徐列表排列页面，每次将最久未使用的页面置换出去。

#### 时钟页面置换算法

所有页面放在环形链表中，保存一页访问位

缺页中断是时候，顺时遍历，如果访问位是1则变为0，如果是0则替换

#### 最不常用

记录访问次数，置换访问次数最少的页面

### 内存分配

分段

分页

快表-二级页表

分段+分页

快表TLB（页表缓冲），如果虚拟地址在TLB中，就直接使用TLB中的地址访问内存
如果不在TLB中，就进行正常的页表查询，淘汰一个表项，然后新的页表向替换它。



### 倒排页表

虚拟内存大，但是系统的实际内存却比较小。

原本的页表是虚拟内存的一个页面（虚拟内存块）对应着页框(物理内存块)，如果虚拟内存地址过大的话，页表会变得非常大，在虚拟内存加到，物理内存较小的情况下，使用倒排页表，一个页框对应一个页面。

这样，可以大量节省空间，因为原本是虚拟内存页的页表项个数变成了页框的页表项个数，可以节省页表占用空间，

缺点是虚拟地址到物理地址的映射会变得困难，因为需要搜索整个倒排页表完成虚拟地址的转换，这个过程不只是缺页中断的时候，因为即使所有的页面在物理内存中通过虚拟地址没有办法物理内存中的页框是哪个。

缺点的应对办法是TLB和散列表搜索，前者记录频繁使用的页面，使得地址转换变快，不过TLB失效的时候，还是要搜索倒排列表；后者是优化倒排页表的搜索，实际上是把进程n的页表p当做散列的自变量，映射到一个页框的拉链中



### 内存保护

用户进程允许修改只读代码段，也不允许修改内核代码和数据结构，比如epoll对epoll表的修改就是通过epoll_ctl调用

虚拟寻址中

CPU将虚拟地址交给MMU（存储管理单元）得到物理地址，如果不限制就能访问和修改其他进程的私有内存，进而导致系统崩溃

通过MMU读取页表的时候，会对虚拟也增加标志位（RWX），实现访问权限控制



### 用户态和内核态

处理器中有一个模式为来提供这种功能，设置了模式位，运行在内核态，可以使用任何指令

没有设置运行在用户态，不能运行特权指令



### 上下文切换

1. 寄存器，TLB
2. 程序计数器
3. 用户栈
4. 内核栈
5. 内核数据

### 为什么使用虚拟内存

1. 结合磁盘和物理内存各自的优势，为进程提供速度够快，容量够大的存储
2. 为进程提供独立的内存空间，简化程序共享物理内存的开销，简化程序内存的分配过程
3. 控制程序对内存的访问，隔离进程访问权限

## 死锁

### 资源

**可抢占资源**：从拥有它的进程抢占不会产生副作用，存储器，CPU

**不可抢占资源**：不引起相关计算失败的情况下，无法把它从它的进程去强占过来

### 死锁的必要条件

1. 互斥：只能被分配个一个线程
2. 占有和等待：已经得到的类某个资源的进程可以再请求新的资源
3. 不可剥夺：分配给某个进程的资源不能强制性的被强占，只能显式的释放。
4. 环路等待：两个或以上的进程形成循环等待的环路，每个进程都在等待下一个进程所占有的资源

### 死锁处理

死锁家岑

检测有向图是否有环（dfs）



### 死锁恢复

1抢占恢复

把进程挂起，释放这个进程的资源，用完在放回

2.回滚恢复

复位到没有出现死锁的状态，这个需要保存程序运行的检查点

3.杀死进程

结束循环等待的某个进程，破坏循环等待条件



###  死锁预防

1. 破坏互斥条件
   多个进程同时输入到打印机上，只有打印机的守护进程完成请求物理打印机的处理
2. 破坏占有并请求条件
   一开始获得所有资源，请求资源的时候先释放自身资源然后一次性获取全部资源。
3. 破坏不可抢占条件
4. 破坏环路等待条件
   所有资源进行编号，进程按照编号顺序请求需要的资源

### 死锁避免

**安全状态**：存在某种资源分配的顺序，额能是每个进程运行完毕，则称状态是安全的

**银行家算法**

### 管程

资源封装进管程，程序通过管程访问，管程维护程序的互斥访问，会建立等待队列

## 文件

### 虚拟文件系统

多个文件系统整合到一个统一的结构中，多种文件系统对用户和进程不可见。

文件系统各块之间不一定相邻，1-4KB



### 记录空闲块

链表：

位图：

配额：限制每个用户拥有的文件和块的最大数量



### 磁盘结构：

盘面、磁道、扇区

### IO过程

寻道（先来先服务，最短巡道时间优先，电梯算法）

旋转

传输















