### 线程池的大小确定

> IO密集型

因为大部分CPU被阻塞没所以需要多配制线程数

- CPU核数*2
- CPU核数/(1 - 阻塞系数)，阻塞系数在0.8-0.9之间



> CPU密集型

没有阻塞，无论开几个模拟的多线程都得不到加速



### TCP握手失败

https://mp.weixin.qq.com/s/w4s6bn8_3iqsCpF8_zSbtw

### 多线程信号处理

1.sigaction注册时机

1. sigaction不论在主线程中注册还是在子线程中注册，最终进程内的所有线程都调用sigaction注册的回调函数来处理。
2. sigaction注册不同信号，则不同信号对应着sigaction注册时的回调函数
3. sigaction注册相同信号，相同信号被注册多个回调函数，此时信号发来，==执行的是最新的一个回调函数==，等又有一个sigaction注册了之前的信号，则之前信号的回调函数会被更新会新的回调函数

2.哪个线程处理信号

1. 如果主线程不阻塞某个信号，则优先处理信号的线程是主线程，==且一个信号只会被一个线程所处理==
2. 当主线程阻塞了某个信号，则交由子线程处理，通过多次测试得出，优先处理信号的线程是pthread_ID较大的那个
3. 虽然每个线程都有自己独立的signal mask，但是要注意子线程的mask是会从主线程继承而来的，如果主线程先阻塞了某个信号，再创建子线程，而子线程没有设置自己的signal mask ，则子线程也默认阻塞了该信号

### 线程调度策略

https://blog.csdn.net/weixin_39270987/article/details/107646275

#### 实时调度

FIFO

轮询

换出原因：高优先级占用，sched_yield函数，轮询的时间用完

#### 非实时调度，根据动态优先级nice值进行调度

OTHER 静态优先级为0遵循CFS调度，根据权重分配时间

BETCH假设线程是CPU密集型的，对线程的唤醒行为进行惩罚

IDEL线程的优先级极低



#### Redis内存淘汰

LRU

LFU

Random

将要过期





#### C++内存分配方式

堆、栈、全局、字符串



#### 过多TCP第一次握手

占用tcp半连接队列





### select poll epoll的线程安全问题

select poll没有线程安全考虑

epoll考虑了线程安全，有一个自旋锁保护就绪队列，有一个互斥锁保护被监听的文件描述符对应的红黑树



### 宏的递归

宏是可以递归调用的，展开的时候优先展开内部的宏



### 可重入和线程安全

由于可重入函数多次调用不会出错，因此可重入函数不用担心数据会被破坏。可重入函数任何时候都可以被中断，一段时间后又可以运行，而相应的数据不会丢失。可重入函数只使用局部变量，即保存在CPU寄存器或者堆栈中；或者如果使用全局变量时，则要对全局变量予以保护。 

线程安全是不同线程调用这个函数的时候不会出现问题，多个线程运行和单个线程运行的效果一样

malloc和free是不可重入的，但因为有全局链表加锁，所以是线程安全的





### SQL聚合函数对null的处理

max,min,avg,sum忽略null的值

count(*)会计算null

count(column_name)会忽略null



### TCP丢包和超时重传

https://blog.csdn.net/maple_wei/article/details/106332923?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-106332923-blog-104778916.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-106332923-blog-104778916.pc_relevant_default&utm_relevant_index=1





### 分布式服务器慢节点

慢节点排查

根据缓慢原因

- 持久化层访问：缓存
- 负载高：增加相同节点
- 处理逻辑复杂：优化处理逻辑



### 分布式

http://www.360doc.com/content/20/1221/08/39716884_952615590.shtml

**分布式效率优化**

#### 降低请求延时

内存，减少碎片，提升分配速度

CPU增加cache命中率

线程/进程调度，增加协程机制





### sleep和delay的区别

最明显也最重要的区别就是，在执行delay的时候，是执行了空指令，虽说是空的，但是还是会占用硬件资源，cpu要进行运算。而sleep是将此进程挂起，cpu还会执行其他进程，待到时间到，再恢复此进程。两者对比可以看出，sleep执行的时候，节省系统资源，但是弊端是sleep的定时并没有那么准确，因为是通过进程切换来实现的，delay则是严格按照机器周期来计算，而且sleep不能适用于时间太短的延时，delay可以精确到us。





### 共享内存

mmap机制

在磁盘上建立一个文件，每个进程存储器中，单独开辟一个空间来映射保存到实际硬盘，实际并没有反映到主存上。
使得进程之间通过映射同一个普通文件实现共享内存，普通文件被映射到进程地址空间后，进程可以向访问普通内存一样对文件进行访问，不必再调用read()，write（）等操作。

1. 优点：存储量大
2. 缺点：读取和写入速度比较慢

shm机制

每个进程的共享内存都直接映射到实际物理存储器上shm保存到物理存储器(主存)，实际的存储量直接反映到主存上。
进程间需要共享的数据被放在一个叫做IPC共享内存区域的地方，所有需要访问该共享区域的进程都要把该共享区域映射到本进程的地址空间中去。

1. 优点：进程间访问速度比磁盘快
2. 缺点：存储量不能非常大

通过shmget获得或创建一个IPC共享内存区域，并返回相应的标识符。
每一个共享内存区都有一个控制结构struct shmid_kernel。



### C++源文件到可执行文件的过程

https://www.cnblogs.com/smile233/p/8423015.html

#### 链接

*由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数，等等。所有的这些问题，都需要经链接程序的处理方能得以解决。*

通过调用链接器ld来链接程序运行需要的一大堆目标文件，以及所依赖的其它库文件，最后生成可执行文件。

ld -static crt1.o crti.o crtbeginT.o hello.o -start-group -lgcc -lgcc_eh -lc-end-group crtend.o crtn.o (省略了文件的路径名)。

链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够诶操作系统装入执行的统一整体。

根据开发人员指定的同库函数的链接方式的不同，链接处理可分为两种：

（1）静态链接　在这种链接方式下，函数的代码将从其所在地静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。(个人备注：静态链接将链接库的代码复制到可执行程序中，使得可执行程序体积变大)

（2）动态链接　　在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。==链指链接阶段仅仅只加入一些描述信息==，而程序执行时再从系统中把相应动态库加载到内存中去。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。（个人备注：动态链接指的是需要链接的代码放到一个共享对象中，共享对象映射到进程虚地址空间，链接程序记录可执行程序将来需要用的代码信息，根据这些信息迅速定位相应的代码片段。）

　　对于可执行文件中的函数调用，可分别采用动态链接或静态链接的方法。使用动态链接能够使最终的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一些内存，==因为在内存中只需要保存一份此共享对象的代码==。但并不是使用动态链接就一定比使用静态链接要优越。在某些情况下动态链接可能带来一些性能上损害。

经过上述五个过程，C++源程序就最终被转换成可执行文件了。缺省情况下这个可执行文件的名字被命名为a.out。



### 协程的实现

 c/c++不直接支持协程语义，但有不少开源的协程库，如：
 Protothreads：一个“蝇量级” C 语言协程库
 libco:来自腾讯的开源协程库libco介绍，官网
 coroutine:云风的一个C语言同步协程库,详细信息

 目前看到大概有四种实现协程的方式：

- 第一种：利用glibc 的 ucontext组件(云风的库)
- 第二种：使用汇编代码来切换上下文(实现c协程)
- 第三种：利用C语言语法switch-case的奇淫技巧来实现（Protothreads)
- 第四种：利用了 C 语言的 setjmp 和 longjmp（ 一种协程的 C/C++ 实现,要求函数里面使用 static local 的变量来保存协程内部的数据）

ucontent

切换栈，保存了栈的数据

long_jump

相当于程序计数器和寄存器的转换，一些跳转可能带来问题，类似于goto语句的模型，如果goto语句之中有改变堆栈的处理，会影响goto语句的跳转

~~setjump是宏，long_jump是函数~~，操作是改变栈顶指针和寄存器，但是函数退出的，==具体的栈数据没有保存，所以再次进入的时候访问setjmp之前的局部变量是会出问题得到，虽然编译会通过==

```cpp
#include <setjmp.h>
#include <stdio.h>
#include <stdlib.h>

static jmp_buf env;

void call_setjmp()
{
    int i; 
    int a[1024];//这个退出后会释放，如果跳转后再次使用就会出现问题
    i = setjmp(env);
    
    switch (i) {
        case 0:
            printf("Finished initialization of env\n");
            break;
        case 10:
            printf("Hit 10\n"); 
            break;
        case 20:
            printf("Hit 20\n");
            break;
        default:
            printf("Hit nothing useful\n");
    }
}

void call_longjmp(int val)
{
    longjmp(env, val);
}

int main()
{
    call_setjmp();
    call_longjmp(10);
    call_longjmp(20);
    call_longjmp(30);
    
    return 0;
}

```



### HPACK和QPACK

https://blog.csdn.net/weixin_33994429/article/details/88723750

区别是2.0通过请求头维护动态表

3.0有两个单向的流维护动态表



### HTTP2-》HTTP3

队头阻塞

TSL握手延时

网络重新连接



### TLS握手

https://tyler-zx.blog.csdn.net/article/details/107591115?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107591115-blog-122284670.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107591115-blog-122284670.pc_relevant_default&utm_relevant_index=1



第一次 c->s

1. 说明自己要建立TLS连接
2. 给出自己的支持的加密组件，比如算法，协议版本
3. 给出客户端的随机数



第二次

1. 确定版本，确定算法
2. 给出服务器的随机数
3. 给出服务器的CA证书



第三次

客户端在确认CA证书的情况下，生成密钥pre-master

根据哈希算法确定最后的协商密钥HASH(pre-master, random_s,ramdom_c)

1. 服务器公钥加密的pre-master
2. 约定之后通过通信密钥进行加密（编码改变通知）/客户端握手结束
3. 一段用通信信息的hash值用协商密钥加密的信息



第四次

解密获得pre-master，计算协商密钥

用客户端给的加密信息验证协商密钥的正确性

1. 约定之后通过通信密钥进行加密（编码改变通知）/服务器握手结束
2. 一段用通信信息的hash值用协商密钥加密的信息





### ECDHE算法下

第二次握手，服务器给出公钥

第三次握手，客户端给出公钥

密钥通过两个随机数和ECDHE算法的共享密钥得到，而不使用pre-master



0延时握手，是客户端存储了服务器公钥，直接从第三步开始





### 多线程锁和信号量

https://blog.csdn.net/jiang_t/article/details/120992761





### 索引优化

```sql
explain select ...
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | tb_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |      100 | NULL  |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+

mysql> explain select 3;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | NULL     | No tables used |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
1 row in set

mysql> explain select * from tb_user where user_id=1
;
+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | tb_user | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |      100 | NULL  |
+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set

mysql> explain select * from tb_user where user_id=1 and name = 'wujiali'
;
+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | tb_user | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |      100 | NULL  |
+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set
```

注：explain不会执行sql

一、id

SQL执行的顺序的标识,SQL从大到小的执行

1. id相同时，执行顺序由上至下

2. 如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行

3.id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行

二、select_type

示查询中每个select子句的类型

(1) SIMPLE(简单SELECT,不使用UNION或子查询等)

(2) PRIMARY(查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY)

(3) UNION(UNION中的第二个或后面的SELECT语句)

(4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)

(5) UNION RESULT(UNION的结果)

(6) SUBQUERY(子查询中的第一个SELECT)

(7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，取决于外面的查询)

(8) DERIVED(派生表的SELECT, FROM子句的子查询)

(9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)

三、table

显示这一行的数据是关于哪张表的，有时不是真实的表名字,看到的是derivedx(x是个数字,我的理解是第几步执行的结果)

mysql> explain select * from (select * from ( select * from t1 where id=2602) a) b;

+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+

| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |

+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+

| 1 | PRIMARY |  | system | NULL | NULL | NULL | NULL | 1 | |

| 2 | DERIVED |  | system | NULL | NULL | NULL | NULL | 1 | |

| 3 | DERIVED | t1 | const | PRIMARY,idx_t1_id | PRIMARY | 4 | | 1 | |

+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+

四、`type`

表示MySQL在表中找到所需行的方式，又称“访问类型”。

常用的类型有： ALL, index,  range, ref, eq_ref, const, system, NULL(从左到右，性能从差到好)

ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行

index: Full Index Scan，index与ALL区别为index类型只遍历索引树

range:只检索给定范围的行，使用一个索引来选择行

ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件

const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system

NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。

五、`possible_keys`

指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用

该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。

如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询

六、`Key`

key列显示MySQL实际决定使用的键(索引)

如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。

七、key_len

表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度(key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的)

不损失精确性的情况下，长度越短越好

八、`ref`

表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

九、rows

表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数

十、Extra

该列包含MySQL解决查询的详细信息,有以下几种情况：

Using where:列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤

Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询

Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序”

Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。

Impossible where：这个值强调了where语句会导致没有符合条件的行。

Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行

总结：

• EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况

• EXPLAIN不考虑各种Cache

• EXPLAIN不能显示MySQL在执行查询时所作的优化工作

• 部分统计信息是估算的，并非精确值

• EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划



### SQL优化

索引

限制查询字段

分库分表

选择引擎



### Linux命令

netstate 查看

tcpdump

ps 查看进程

kill结束进程

lsof查看打开的文件描述符

查看程序运行目录 ll /proc/PID/cwd



### 为什么使用B+树

深度浅，减少IO次数，查询效率稳定

方便扫库，和Range操作



### 视图的操作

查可以

增加-增加原本表中的数据，且符合原表的约束，对于聚合 Distinct，group子句没有本办法更新

修改数据，修改原表的数据，且智能修改一张表的信息

删除数据-如果视图是一个基表上的数据，可以删除，如果是多表连接的，则不可以



### 游标

概念

游标(Cursor)它使用户可逐行访问返回的结果集。使用游标(cursor)的一个主要的原因就是把集合操作转换成单个记录处理方式
优势

    允许程序对由查询语句select返回的行集合中的每一行执行相同或不同的操作，而不是对整个行集合执行同一个操作。
    提供对基于游标位置的表中的行进行删除和更新的能力
