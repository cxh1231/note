## 数据库范式

**码**：某一属性组的值能唯一标识一个元组，而其[子集](https://so.csdn.net/so/search?q=子集&spm=1001.2101.3001.7020)不能，则称该属性组为候选码。若一个关系中有多个候选码，则选定其中一个为主码。
 例如：所示的学生表中，学号和姓名都可以唯一标识一个元组，故该表的候选码为学号和姓名，我们可以随便选定其中一个作为主码。

**主属性**：所有候选码的属性称为主属性。不包含在任何候选码中的属性称为非主属性或非码属性
 在上面的学生表中，学号和姓名就是该关系的主属性，年龄和性别就是非主属性。

> 一范式（原子性）
>
> 数据库表的每一列都不可以再分

> 二范式（消除部分依赖）
>
> 每个字段都和主键完整相关，而不是部分依赖于主键
>
> 例：一对一的关系在分布在主属性和非主属性中

> 三范式（消除传递依赖）
>
> 表中的字段和主键直接相关，不允许间接相关
>
> （例：商品的二级分类），依赖关系分（非主键之间一对多的关系）

> BC范式
>
> 所有属性都完全依赖于码，每个决定因素都包含码
>
> （例：仓库名和唯一管理员做主键，不满足BC范式的情况出现于联合主键中，是主键中的字段之间的一对一的==互相依赖==，而且他们都可以单独成为码，如果主键是一个字段，就不用担心这种情况，它和二范式的区别在于二范式中的部分依赖来源于主键之中的一对多的单项依赖）

### 主键

用作唯一标识的字段



### 表的优化

#### 字段优化

使用TINYINT，SMALLINT，MEDIUM_INT代替INT，非负的加上无符号

VARCHAR的长度分配真正需要的控件

| varchar                            | char               |
| ---------------------------------- | ------------------ |
| 65535                              | 255                |
| 不定长                             | 定长补空格         |
| 效率低                             | 效率高             |
| 插入时不会忽略尾部空格，查找时忽略 | 插入时忽略尾部空格 |

尽量使用整数或者枚举代替字符串类型（sql server没有枚举）

时间类使用timestaamp而非Datetime

单表不要放太多字段

好用NULL

### 慢查询

设置超时时间，超过这个时间的sql语句被称为慢查询

long_query_time默认10秒

优化

运行sql测试

查询区分度高的字段

explain显示mysql如何使用索引处理select语句以及连接表

order by limit形式的sqlk让排序的表优先查

考虑简历索引的原则

### Mysql与MongoDB

| MySQL                | MongoDB                                  |
| -------------------- | ---------------------------------------- |
| 关系型               | 非关系型                                 |
| 引擎不同存储方式不同 | 虚拟内存+持久化                          |
| SQL查询              | MongoDB自己的查询方式                    |
|                      | 将数据存储在物理内存中，从而待到高速读写 |
| 海量数据效率较低     | 海量数据效率高，但不支持事务             |



## 表连接

**连接**

记录依次匹配然后发送给客户端

**笛卡尔积**



**连接过程**

1. 确定第一个查询的表，作为驱动表
2. 从驱动表中取每一条符合搜索天剑的记录，在接下来的表中查找匹配的记录，驱动表之后的表叫被驱动表

只需要访问驱动表一次，多次访问被驱动表

每获得一条满足条件的驱动表记录，马上到驱动表中寻找匹配的记录

#### 内/外连接

**内连接**

驱动表中的记录在被驱动表中找不到匹配的记录，那么驱动表的这条记录不会加入到最后的结果中

**外连接**

驱动表中的记录在被驱动表中找不到匹配记录，仍需要加入结果中

左右外连接分别将左侧和右侧的表作为驱动表

**过滤条件**

==where==，不符合where字句的记录不会加入到最后结果中

==on==，内连接中与where等价；外连接中，被驱动表没有匹配的仍会加入结果，被驱动表字段用null补充

#### 嵌套循环连接

如果3个表连接，那么新完成连接后的结果作为驱动表，在将另外的表作为被驱动表进行查询

#### 使用索引

根据驱动表的一跳记录查询被驱动表时，相当于确定搜索条件的单标查询，可以使用索引优化单表查询（==注意一下唯一索引==）

被驱动表使用二级索引进行查询的时候，如果过滤条件只有被驱动表的二级索引，就不使用*作为查询列，这个方法不用二级索引回表

#### Join Buffer连接缓冲区

在执行连接查询前，申请一块固定大小的内存，洗吧若干驱动表结果集中放在buffer中；扫描被驱动表时，每一条被驱动表记录与buffer中的多条驱动表记录进行匹配



## MySQL锁



innodb大部分情况使用行锁

使用表锁的情况

1. 表比较大，事务更新大部分数据
2. 涉及多个表处理，比较复杂可能死锁

锁的种类

1. 全局锁
   对整个数据库实例进行加锁
   MySQL提供了全局读锁的方法，`Flush Tables wiht read lock(FTWRL)`
   以下语句会被阻塞
   数据更新
   数据定义
   更新事务提交

2. 表级锁

   - 锁整张表
   - 开销小，加锁快
   - 并发度低

   语法`lock tables ... read/write`

   与FRWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。

   **元数据锁（meta data lock, MDL）**

   访问一个表的时候会自动加上
   
   作用是在查询表的时候，防止对表结构进行修改，删除列
   
   事务的MDL锁在语句执行开始时申请，但是语句结束后不会马上释放，而是等到整个事务提交后再释放（可能会产生死锁问题）
   
3. 行锁

   只锁一行数据

   开销大，加锁慢

   冲突低

   InnoDB事务中，行锁是需要的时候才加上的，但并不是不需要了就立即释放，而是等到事务结束时才释放。这就是**两阶段锁协议**。

   所以事务中需要锁索航的时候，把最可能造成冲突，影响并发的锁往后放

### 加锁规则

> https://blog.csdn.net/qq_39751320/article/details/106299388?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-106299388-blog-114286239.t5_layer_eslanding_C_0&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-106299388-blog-114286239.t5_layer_eslanding_C_0&utm_relevant_index=1

> RC模式下只用到了行级锁
>
> https://blog.csdn.net/weixin_42029860/article/details/118188166?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-118188166-blog-114286239.t5_layer_eslanding_C_0&spm=1001.2101.3001.4242.2&utm_relevant_index=4

> Record Lock+Gap Lock，如果一个事务在记录R上的某个索引有共享/互斥锁,也会对其前面一个范围加锁
>
> https://blog.csdn.net/qq_39751320/article/details/106299388?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-106299388-blog-114286239.t5_layer_eslanding_C_0&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-106299388-blog-114286239.t5_layer_eslanding_C_0&utm_relevant_index=1

innodb的不同的锁，MyISAM只支持表级锁

next-key lock防止幻读

> another session cannot insert a new index record in the gap immediately before R in the index order.
>
> https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html

**两个原则**

1. 加锁的基本单位是`next-key lock`。他是前开后闭区间
2. 查找过程中访问到的对象才会加锁
   关于对象是指加锁的索引，如果不是主键，则不会为主键加锁https://blog.csdn.net/why_still_confused/article/details/126167451

**两个优化**

1. 索引上的等值查询，唯一索引加锁，next-key lock退化为行锁
2. 索引上的等值查询，向右遍历时最后一个值不满足等值条件的时候，next-key lock退化为间隙锁

**一个bug**

唯一索引上的范围查询会访问到不满足条件的第一个值位置为止

- 这是在reoeatable-read下验证的，同时重复读隔离级别遵循两阶段加锁协议，所有加锁的资源在事务提交或者回滚的时候才会释放
- 读提交级别的话，只有行锁

### 锁的划分

#### 数据库角度

1. 共享锁
   锁定自愿可以被其他用户读取，但不能修改

   ```sql
   select id from tb_user where id = 10 lock in share mode;
   ```

2. 排他锁
   只允许缩影操作的事务使用，其他事务无法对已锁定的数据进行查询或修改

   ```sql
   select id from tb_user where id = 10 for update
   ```

   insert,update,delete的时候也会自动使用排他锁

3. 表锁操作

   ```sql
   lock table tb_user read;
   unlock table;
   lock table tb_user write;
   ```

4. 意向锁
   给更大以及别的控件仪式里面是否已经上过锁
   对一个数据表的某些记录加锁的时候，==给整个表添加上意向锁==，其他事务可以确定是否有事务对这个表的某些记录加了锁，判断能否进行整个表的==全表处理==

#### 程序员角度

https://blog.csdn.net/qq_35091353/article/details/116299465

1. 乐观锁
   认为==同一数据的并发操作不会总发生==，属于小概率事件，不用每次对数据上锁，==不采用数据库自身的锁机制，而是通过程序实现==，程序上可以采用版本号或是时间戳的方式
   时间戳：对比数据版本有没有改变；CAS单个变量，变量的预期值是不是读入的值
2. 悲观锁
   数据被其他事务的修改持==保守态度==，==通过数据库自身的锁机制实现==，从而保证数据操作的排他性

**适用场景**

**乐观锁**：读多写少，有点在于程序实现，不存在死锁，无法阻止程序之外的操作

**悲观锁**：适合写操作多的场景，数据库层面防止读-写，写-写冲突，但加锁时间长，并发性差

## MySQL事务

**基本概念**

不可再分的工作单元

一个事务对应一个完整的业务

### 事务特性

**ACID**

**A**原子性

一个事务的所有操作要么全部完成，要么都没完成

**C**一致性

数据库的完整性不会被破坏

**I**隔离性

允许多个事务并发时对数据进行读写，方式多个事务执行时因为交叉执行而导致数据不一致

**D**持久性

事务处理结束后，对数据的修改是永久的，即使出现了故障也不会丢失

### 四大隔离级别

**脏读**：读取了另一个事务还没提交的数据

**不可重复读**：同一个事务两次相同查询返回不同结果

**幻读**：范围查询的时候，多次读取同一个范围，结果集合变化

1. RU读未提交
   完全不进行隔离
2. RC读已提交
   读取其他事务提交的最新数据，但是统一事务中select可能会读到不同的结果（单纯的行级锁）
3. RR可重复读(innodb默认)
   同一个事务中，select的结果从开始到结束时一致的，innodb用到了（MVCC和next-key lock实现）
4. serializable串行化
   串行执行事务，隔离级别最高

### 分布式

#### 幂等操作

用户同一操作发起一次请求或者多次请求的结果是一直的，不会因为多次提交产生副作用

#### lvs负载均衡

Linux virtual server：一个实现负载均衡的项目

https://blog.csdn.net/weixin_45880055/article/details/120404231
逻辑架构
（1）调度层
（2）server集群层
（3）共享存储
基本工作原理
原理
IVS的IP负载均衡主要通过IPVS实现，IPVS虚拟一个IP地址，用户通过这个虚拟IP访问服务器。该虚拟IP被称为LVS的VIP，访问的请求首先进过LVS的VIP，到达负载调度器，负载调度器从real server列表中选取一个服务节点响应用户请求。IPVS会强行修改数据包里的==目标IP地址及端口==，并将新的数据包发往POSTROUTING链

#### ivs和Nginx的区别

**负载均衡**
LVS：4层负载均衡
Nginx：7层负载均衡
**原理**
LVS：IP+TCP端口
Nginx：URL应用层(内容交换)
**特点**
LVS：配置简单，效率高，不理解特定协议的内容
Nginx：智能化，可以对请求进行自定义修改，对负载均衡的设备要求高，配置复杂

#### 调度算法

静态调度：rr轮询，wrr加权轮询，dh目标地址散列，sh源地址散列

动态调度：lc最少连接数，wlc加权最少连接数， 



#### consul、etcd区别

https://www.cnblogs.com/cherylgi/p/15882845.html

在分布式微服务架构：一个应用可能由一组职责单一化的服务组成。这个时候需要一个注册服务机制，注册某个服务或者是节点是可用的，还需要一个服务发现机制找到那些节点还在提供服务

consul与etcd提供了服务管理功能

区别

服务健康检查

consul：服务状态、内存、硬盘等

etcd：连接心跳

多数据中心

consul：支持

etcd：不支持

使用接口

consul：http/dns

etcd：http/grpc

#### 分布式事务

保证分布式环境中，不同数据的数据一致性

#### 分布式锁

多线程锁机制应用到分布式的部署环境中

**特点**

(1)互斥性

(2)可重入：统一节点的统一线程，获取锁之后还可以两次获取这个锁

(3)锁超时：支持锁超时，防止死锁

(4)高效，高可用

(5)支持阻塞和非阻塞

(6)支持公平锁和非公平锁



公平锁：按照请求加锁的顺序获取锁

非公平锁：无需获取锁



**常见的分布式锁**

1. mysql
2. Redis
3. zookeeper



### 淘汰算法

**LRU**

最近最少使用，如果数据最近被访问过，那么将来被访问的几率也高

实现：

链表缓存

命中缓存和新数据放在头部

淘汰最后

**LFU**

最不常用的淘汰

实现：

每个数据块一个引用计数

使用引用计数排序

某个数据访问，重新排序

删除数据时，删除最后的数据

**FIFO**

先进先出

### 一致HASH算法

通常用于负载均衡请求资源均匀分布到所有节点上，并且对资源的请求能快速路由到对应的节点上面

特点

平衡性：哈希结果均匀的分配到整个输出空间中

单向性：相同数据映射到相同节点

稳定性：出现节点坏掉或者动态扩容的的时候，减少数据的移动

原理

（1）哈希环：输出控件是一个环形区域

（2）将服务器进行哈希，输出值映射到环形区域上

（3）对用户数据进行哈希操作，映射在环形区域上



### CAP原理

基本概念：

C一致性：分布在不同节点上的数据，如果一个节点更新数据，其他节点都能读到最新的数据

A可用性：非故障节点在合理的时间内返回合理的响应

P分区容错性：出现网络错误，部分节点失效的手，其他节点还能继续工作

**CAP不能同时共存**

CA：没有分区容错性的一般会不选择

CP：代表是Zookeeper，放弃可用性，最求一致性和容错性

AP：追求分区容错性和可用性

### BASE理论

基本可用性：分布式系统出现故障时，允许损失部分可用功能

软状态：允许系统出现中间状态，这个状态不影响可用性

最终一致性：经过一段时间后，所有节点数据达到一致

### MySQL索引

```sql
create index index_name on table_name(col_name);
drop index index_name on table;
```

使用`explian`关键字查看SQL是否使用了索引进行检索

#### 索引失效

1. 模糊匹配以“%”开头，索引失效
2. OR又一遍的条件字段没有索引时，索引失效
3. 复合索引时，没有使用左侧列查找，索引失效
4. where对索列进行了运算
5. 对索引列使用了函数，索引失效

#### 索引下推（index condation pushdown）

索引下推的下推其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。

没有ICP的时候

1. 存储引擎读取索引记录；
2. 根据索引中的主键值，定位并读取完整的行记录；
3. 存储引擎把记录交给`Server`层去检测该记录是否满足`WHERE`条件

使用ICP的时候

1. 存储引擎读取索引记录（不是完整的行记录）；

2. 判断条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；

3. 条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；

4. 存储引擎把记录交给层，层检测该记录是否满足条件的其余部分

这样可以减少一次回表处理

#### 索引的种类

普通索引：最基本的索引

唯一索引：允许为null，索引列的值必须唯一

主键索引：只能有一个主键，不允许为空

组合索引：多个字段上创建索引，从第一个字段开始匹配

全文索引：主要用来查找文本中的关键字，类似于搜索引擎

#### 索引优化

1. 避免使用空值判断，这会导致引擎放弃使用索引，而使用全表扫描
2. 字段取值比较少，不要使用索引，比如性别
3. 不使用字符字段做主键
4. 字符字段智简历前缀索引
5. 不要使用外键unique
6. 使用多列索引的时候，注意查询顺序

避免会让索引失效从操作：比如空值判断，多字段索引的错误比较顺序

索引的取值范围应该大

索引的更新应该少



#### 索引的常见类型

##### 哈希表

使用key-value对，存储数据

可能在hash冲突

拉链法 解决hash冲突的方法之一

优点：

等值查询效率高，插入、删除、修改单个数据的效率高

缺点：

区间搜索慢

##### 有序数组

等值查询和区间查询性能都优秀（二分搜索）

但是插入和删除的复杂度高

##### 二叉树

树的高度较高，多次IO

##### B树~B+树

最常用的方法，因为涉及到存盘

#### Innodb索引类型

B+树，每个索引对应一棵B+树

主键索引时郑航数据，主键索引也是聚簇索引

非主键索引叶子节点保存主键的值

二级索引/非聚簇索引

**主键索引和普通索引**

回表；唯一

#### 页分裂

B+树维护索引有序性，如果待插入的记录所在的数据页满了，则可能造成页分裂

代价：

影响性能

影响数据页的利用率

主键长度小，叶子节点就越小，普通索占用的控件也就越小

尽量使用自增主键

> 主键使用自增整形的原因，空间消耗小，比较运算快



#### 覆盖索引

执行如下语句时，只需要索引树上的数据的时候，不需要回表

#### 最左前缀原则

使用%匹配的时候，左边的%对应的索引列会让索引查询失效，因为索引是字典序



#### 索引的优缺点

**优点**

加快检索速度，唯一索引可以确保数据库数据的唯一性（也可以用约束限制，索引查找相同是可以加速的）

**缺点**

需要单独维护一个b+树，索引的修改需要耗费很多时间



#### InnoDB收集统计数据

表的统计数据 show table status;

索引的统计数据show index；

1. 永久性存储
   存在磁盘上，从其仍然有效
   实际上是在连个表中：
   innodb_index_stats
   innodb_table_stats
2. 非永久存储
   存储在内存中，重启失效

### MySQL用户管理

为了保证MySQL访问安全，每个MySQL用户对他们需要的数据具有适当的访问权限

比如

多数用户智能用到读写权限，少数能够创建、删除表格

一些用户只能访问某个数据库而不能访问其他数据库

一些用户可以管理其他用户账号

#### 1.账号存储

所有用户存储在mysql库的user表中

#### 2.账号管理

```sql
--新建用户
create user [user_name] identified by [user_pwd]
--重命名用户
rename user [user_name] to [new_user_name]
--修改密码
set password for [user_name] = password('[new password]')
set password = password('[new password]')
--删除用户
drop user [user_name]
--权限控制
	--查看用户权限
	show grants for [user_name]
	grant [权限名] on [数据库].[表名] to [用户名]
	revok [权限名] on [数据库].[表名] from [用户名]
```

### 语句执行

#### 查询语句

1. 连接
   连接器和客户端建立连接、获取权限、维护和管理链接，连接的建立比较复杂，所以尽量使用长链接，而不是短连接，但长链接过多的时候会占用过多内存导致OOM
2. 缓存
   执行查询语句前，先看下缓存有没有结果
   如果有，则不必执行查询语句，直接取出缓存结果
   如果没有，则执行查询，并保存查询结果到缓存中
3. 分析
   词法分析，语法分析，语义分析
4. 优化
   决定索引使用规则和表连接顺序
5. 执行
   执行语句，执行前判断是否有权限

#### 更新语句

redo log和bin log

| redo log                     | bin log                                |
| ---------------------------- | -------------------------------------- |
| InnoDB持有                   | server层实现                           |
| 物理日志，记录数据页上的修改 | 逻辑日志，记录sql语句的逻辑            |
| 循环写，空间会用光           | 追加写，文件写到一定程度会切换到下一个 |

数据恢复

两阶段提交可以维护两份日志之间的一致性



### 查询优化

将一些查询语句进行重写

1. 条件化简

2. 移除不必要括号

3. 常量传递（如果表达式某个列或是某个常量的等值匹配，会直接用常量替换列名）

4. 移除无用条件（必定为true或是false的条件）

5. 表达式计算（常量表达式直接计算）

6. having和where子句合并（没有聚集函数的话，会将having和where合并）

7. 常量表检测（主键/唯一索引的等值查询）

8. 外连接消除

9. 右连接和左连接的转换

10. 空值拒绝（外连接中，对被驱动表有不为null的判断条件/不允许查询出来的是null，外连接会转换为内连接）

11. 子查询优化

12. 子查询

    ```sql
    select (select m1 from t1 limit 1);
    select * from (select ...);
    
    select * from t1 where m1 in (select ...)
    ```

    1. 子查询用小括号
    2. select字句中的子查询必须是标量子查询(只返回一个值，必须用`limit 1`)
    3. 使用 `in/any/some/all`子查询部运输出现`limit`
    4. 子查询是集合所以不必使用order by,distinct，没有聚集函数的时候也不必使用group by

13. 子查询的执行方式

    1. 不优化
       不相关子查询，将子查询的结果作为外层查询的参数
       相关子查询，外层找到一条记录，再执行一次子查询
    2. 物化
       子查询放入临时表中，临时表就是物化表，基于内存的物化表建立哈希索引，基于磁盘的物化表是B+树索引
    3. 半连接
       只关心表一和表二是否有匹配的记录，不关心多少条记录匹配
    4. table pullout
       查询列表只有主键或是唯一索引列的时候，将子查询表上拉到外层查询的from子句中
    5. 重复值消除
       1. 临时表消除半连接结果集中的重复值
       2. 松散扫描
       3. 半连接物化

### MySQL高性能

#### 主从复制

1. 主从复制
   数据从一个服务器终结点复制到一个或者多个从节点
   MySQL默认采用异步复制的方式，从节点不用一直访问主服务器来更新数据
   从数据库可以复制主节点数据库中的所有数据库、特定数据库或者特定的表
2. 用途
   1. 数据备份：某个节点故障时方便故障切换
   2. 读写分离：主数据库负责写，从数据库负责读，减少主数据库的访问压力，主数据库锁表的时候，从库可以正常读取。
3. 架构扩展
   单机部署会造成I/O访问过高，提高单机的I/O性能

**原理**

涉及三个线程

主节点：binary log dump thread

两个运行在从节点：I/O therad，SQL thread

1. binary log dump
   当从节点连接主节点的时候，主节点创建改线程，用户发送bin-log内容
2. I/O thread
   读取主节点的binlog dump，保存在本地的relay-log中
3. SQL线程
   读取relay log中的内容，解析或具体的从操作并执行，保证数据一致性

**过程**

1. 从节点的IO进程连接主节点
2. 主节点根据IO进程的请求信息中的日志位置返回对应的日志信息，包含本次返回的日志内容和新的日志位置
3. 从节点将接收到的日志内容放到relay log中，保存位置到master-info中
4. SQL进程洁厕relay-log新增，并在数据库中执行

**复制模式**

1. 异步
2. 半同步
3. 同步
4. GTID复制模式（每个事务有一个ID，从节点执行relay log的时候，会对比这个ID如果自己的bin-log有，说明已经执行过了，这个方法不用认为设置日志位置）

#### 分库分表

原因：单库单表太大

1. 垂直拆分

   **垂直分表**：大表拆分为小表，基于列字段；将字段比较多的表进行拆分

   **垂直分库**：针对一个系统的不同业务进行拆分，放到多个服务器上

2. 水平拆分
   **水平分表**：数据多的单张表
   **水平分库**：单张表的数据分到多个服务器上

水平分库分表的切分规则

renge；根据范围

hash取模

地理区域

时间范围

#### MySQL高可用性

双节点+keepalived/heartbeat方案

master节点故障后，复用keepalived/heartbeat的机制切换到slave节点



## MySQL事务隔离

注：redis的事务中的隔离性没有保证原子性，已经做过的操作不会rollback，他的隔离性在于其他事物不会干扰到自己的事务

### 事务的ACID特性

A原子性

C一致性

I隔离性

D持久性

### 隔离性与隔离级别

1. 读未提交read uncommitted
   事务还没提交的时候，他的变更可以被其他事务看到
2. 读已提交read committed
   一个事务提交之后，他的变更才能被其他事物看到
3. 可重复读repeatable read
   一个事务之心过程中看到的数据可启动时看到的数据是一样的
4. 串行化serializable
   对同一行记录，写时加写锁，读时加读锁，出现冲突顺序完成

### MVCC和next-key lock

行锁和间隙锁合称为next-key lock，这个锁是左开又闭的区间

MySQL在可重复读的隔离级别下，执行以下优化

行锁和间隙锁的退化/加锁单位/







### drop、delete、truncate

`delete`是删除过滤的数据，会激发触发器，可以提交和回滚

`truncate`是清空表，会重置自增字段的初始值，如果有主键是其他表的外键，这个处理会失败，不会触发触发器，不能回滚

`drop`是对表结构的操作，删除表的列，表的键，表的索引或是删除整张表，后两者本身算是DDL数据定义语言

