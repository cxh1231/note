### IO模型 阻塞和非阻塞的区别
#### IO的两个阶段

1. 内核和IO设备之间的拷贝
1. 内核和用户内存之间的拷贝
#### 阻塞和非阻塞
阻塞：调用IO操作的时候，如果缓冲区空或者满，调用的简称或者线程会处于阻塞状态知道IO可用
非阻塞：调用IO操作的时候，内核马上返回结果，如果IO不可用会返回错误
### IO多路复用
同时监听多个描述符，一旦某个描述符就绪，就进行响应的IO操作
### 异步和同步
同步IO：函数和方法在调用的时候能返回最终结果，同步IO调用可以是阻塞的，也可以是非阻塞的
异步IO：函数和方法在调用的时候不能返回最终的结果，
### 文件系统
#### EXT(ext4)
场合：适合大多数使用场合包括Linux桌面用户，Android2.3版开始也在使用；
容量（ext4）：1EB分区，16TB文件，40亿文件数量
可靠性：对磁盘的位置和更改做记录，使用校验和
缺点：不支持透明压碎、透明加密、快照
#### XFS
场合：CentOS默认的格
容量：擅长大文件，适合大数据和企业级的应用单个文件8EB
特点： B+树存储，格式化和挂载快，分配存储快，擅长并行IO
缺点：不能直接压缩，不支持透明压缩，缺少校验保护
#### Btrfs
特点：容错、修复，快照功能，对SSD进行了读写优化提高了IO型能
### EPOLL的介绍和了解
|  | select | poll | epoll |
| --- | --- | --- | --- |
|  | ![](E:\短暂视界\面经\八股git\mianshibagu\img\select.png) | ![](E:\短暂视界\面经\八股git\mianshibagu\img\select.png) | ![](E:\短暂视界\面经\八股git\mianshibagu\img\epoll.png) |
|  | 把所有监听的文件描述符拷贝到内核中，挂起进程，某个文件描述符可读或可写的时候，中断程度唤起进程，将监听的描述符再次拷贝到用户空间。 ||在内核中创建一个eventpoll对象，用红黑树保存文件描述符，就绪链表保存就绪的IO事件|
| 描述符数量 | 1024<br />Linux中的宏进行了限制 | 65535<br />兼容旧版本的两个字节 | 65535<br />兼容旧版本的两个字节 |
| 工作模式 | LT | LT | LT/ET |

### Linux最多创建多少进程，多少线程
进程：
ulimit -u限制
兼容旧版32768(两字节)，不同环境下pid_t的类型不同，原本被定义成了shot，现在大部分是int
内核对pid的最大限制 /proc/sys/kernel/pid_max
来自资源的限制
线程：
虚拟内存的限制，Linux的线程栈8M
内核对thread_max的最大限制 /proc/sys/kernel/thread_max
### 协程
协程是用户态的线程，协程栈的大小只有几KB，切换由程序指定
优势
节省CPU，切换协程需要消耗的CPU远小于线程
节省内存
开发方便，可以将异步IO操作结合。 
### 冯诺依曼体系几个模块，分别对应什么
存储器-内存
控制器
运算器
输入设备
输出设备
### 进程线程的通信与同步
|  | **进程** | **线程** |
| --- | --- | --- |
| **同步** |信号量<br />管程|锁<br />信号量<br />条件变量<br />windows的多线程中有临界区和事件|
| **通信** |管道<br />信号<br />共享内存<br />消息队列|全局变量<br />信号机制<br />事件|

#### 管道
双方互相通信需要建立两个管道，管道的实质是内核缓冲区，进程以先进先出的方式从缓冲区中存取数据，缓冲区可以看做一个循环队列，缓冲区大小由ulimit -p限制
匿名管道只允许父子进程之间通信
命名管道没有限制
细节：Linux借助文件系统的file结构和VFS节点inode实现，两个file数据结构一个写一个读，file结构指向同一个临时的VFS索引节点，VFS索引节点指向同一个物理页（所以不能用seek改变指针）
注：不同进程的文件描述符表不同，进程的文件描述符表项指向内核中的文件表项
文件描述符[https://www.cnblogs.com/Jezze/archive/2011/12/23/2299861.html](https://www.cnblogs.com/Jezze/archive/2011/12/23/2299861.html)

#### 信号
Linux进程通信的计算值，信号可以在任意时候发送给某一进程，如果进程没有执行，信号会被内核保存起来，直到进程恢复执行并传递给它，信号可以被阻塞，开销小
#### 消息队列
一个消息链表，一系列保存在内核中的消息列表，用户可以向消息队列添加、读取信息，但是接收消息是可以看做接收特定的消息类型
#### 套接字
不只是网络套接字，地址有很多种，可以跨设备通信是套接字的特点，套接字的管道是全双工的
### 进程调度
| 方法 | 特点 | 优点 | 缺点 |
| --- | --- | --- | --- |
| FCFS 先来先服务 | 非抢占，利于长作业，不利于短作业 | 易于实现 | 效率不高，性能不好 |
| SJF 短作业有限 | 非抢占式 | 减少平均等待时间、提高吞吐量 | 不易于长作业，长作业一直等待 |
| 最短剩余时间优先 | 抢占式，新作业到达对比剩余服务时间 |  |  |
| HRRF(Highest Reponse Ratui First) 高响应比优先 | 非抢占式 | 均衡了等待时间和运行时间 | 需要计算响应比 |
| 时间片轮转 | 用于分时系统的进程调度 | 系统将CPU处理时间划分为若干时间片 | |
$$
响应比=\frac{等待时间+服务时间}{服务时间}
$$

### 进程的执行过程
编译：源代码编译成模块
链接：变异后的模块和所需的库函数进行链接，（静态链接，装入时链接，运行时链接）
装入：将模块装入内存执行

库函数改变，静态需要重新编译，装入时链接需要重启程序，运行时链接下次运行到就会用新的

### 操作系统内存管理

#### 内存管理内容：

##### 空间扩充

覆盖：
程序的空间分成一个固定区和若干覆盖区，经常使用的程序段在固定区，其余的分段，需要访问的放入覆盖区

交换：
把处于等待状态的程序从内存移入辅存（换出），需要运行的程序放入内存（换入）

区别：
覆盖是一个程序或进程的处理
交换是不同进程或程序之间
覆盖和交换是可以一同使用的

##### 存储保护

内存的逻辑地址是做了区分的，比如4G的内存是高1G为系统，低的3G为用户区，通过逻辑地址访问的时候，也有`界地址寄存器`和`重定位寄存器`进行核对，保证操作系统和其他用户程序不会被这个进程的运行影响。地址必须小于界地址寄存器

##### 内存分配/回收

单一连续分配：只区分用户区和系统去，一个用户使用，一个操作系统使用，只能用于单用户、单任务。

固定分区分配：切分内存，找合适的内存放入程序，程序内存过大或是过小不能分配或是有内部碎片

动态分区分配：段式分配，分配和回收会产生外部碎片，最先适应，最优适应，最佳适应算法，地址转换段号|段偏移

页式分配：
按照固定大小的页分配内存，地址：页号|页内偏移，不用的页面可以放入辅存。
注：二级页表：用于解决页表过大，快表：用于解决多次访问内存

段页式：
先分段再分页，地址组成：段号|页号|页内偏移

##### 地址转换

##### 换页算法

FIFO
LRU
最佳算法

### 死锁

#### 死锁产生的必要条件

1. 互斥访问：一个资源每次只能被一个进程使用
2. 占有并请求：一个进程因请求资源而阻塞时，依旧会占有已获得的资源
3. 不可剥夺：进程已经获得的资源，在未使用完之前，不能强行剥夺
4. 循环等待：若干简称之间形成一种头尾相接的循环等待资源关系

#### 死锁产生的预防

一次分配---破坏占有并请求中的请求
得不到所有资源的时候不分配---破坏占有并请求中的占有
得不到请求资源的时候释放---破坏不可剥夺
资源有序分配---破坏循环等待条件

#### 死锁的恢复

1.重启 2.终止进程回收资源3.剥夺进程资源4.进程回退（一个或多个进程回退到没有发生死锁的状态，需要保存进程的历史信息，设置检查点）

### 实现互斥锁

重点是lock方法需要实现原子级的test_and_set这里使用了`std::atomic_flag`

```cpp
#include <iostream>
#include <atomic>
#include <thread>
#include <vector>
#include <functional>
#include <stdlib.h>
#include <iostream>
#include <chrono>
using namespace std;
class mutex{
public:
    void lock(){
        while(m_flag.test_and_set());
    }
    void unlock(){
        m_flag.clear();
    }
    mutex():m_flag(false){}
    mutex(const mutex&) = delete;
    mutex& operator=(const mutex&) = delete;
private:
    atomic_flag m_flag;
};
mutex m;
void run(char ch){
    m.lock();
    cout<<"(";
    for(int i=0;i<20;++i){
        std::this_thread::sleep_for(std::chrono::microseconds(rand()%100));
        cout<<ch;
    }
    cout<<")";
    m.unlock();
}
int main()
{
    vector<std::thread> ths;
    for(int i=0;i<10;++i){
        ths.emplace_back(bind(run, 'A'+i));
    }
    for(int i=0;i<ths.size();++i){
        ths[i].join();
    }
    return 0;
}
```

### 饥饿

资源分配策略不公，进程或线程一直访问不到他需要的资源而不能继续执行就会发生饥饿现象

### 什么时候使用多线程什么时候使用多进程



| 原因           | 多进程                                               | 多线程                                         | 协程                                                         |
| -------------- | ---------------------------------------------------- | ---------------------------------------------- | ------------------------------------------------------------ |
| 创建和销毁频繁 | 进程的创建和销毁更加消耗CPU资源                      | 线程的创建和销毁相对省时                       | 协程的创建和销毁最简单，协程栈只有几KB                       |
| 并发任务交互   | 进程的通信较为麻烦                                   | 线程的地址空间共享，通信更简单                 | 本质是串行的，并发依赖于多线程                               |
| 资源限制       | 资源更多可以开新的进程                               | 只能访问到所诉进程的资源                       | 同线程                                                       |
| 切换           | 进程遵循操作系统的调度                               | 线程被操作系统调度                             | 协程换入换出由程序控制<br />异步IO可以用同步的写法实现<br />本质是串行运行 |
| 退出和分布     | 某个进程退出不影响其他进程<br />可以分布在多台机器上 | 一个线程退出全部退出<br />只能在单个主机上运行 | 同线程                                                       |

### 孤儿进程和僵尸进程分别是什么，怎么形成

- 孤儿进程是父进程退出后，子进程还在执行，这些子进程就成了孤儿进程，孤儿进程会被`init`进程表收养完成状态收集
- 僵尸进程是子进程完成并退出后，父进程没有使用`wait()`或者`waitpid()`对他进程状态收集，这些子进程的进程描述符会留在系统中，子进程成为僵尸进程表

### PCB进程控制块

> 进程控制块，操作系统中的一种数据结构，用于表示进程的状态，操作系统通过PCB对进程进行管理

进程控制块保存的信息

- 进程标识符
  内部标识符：系统标识进程的数字标识符
  外部标识符：用户提供的字母数字组成的标识符，用于用户访问进程
- 处理机状态
  各种寄存器的状态：通用寄存器，指令计数器，程序状态字、用户栈指针
- 进程调度信息
  进程状态、进程优先级、CPU等待时间、进程阻塞事件

- 进程控制信息
  程度和数据的地址、同步和通信机制、资源清单、连接指针

> 作用：OS通过PCB对进程进行控制和管理（比如中断和进程调度的例子）
>
> PCB的存储：线性：线性表、链接：链表、索引：索引的线性队列

### 进程地址空间

![](E:\短暂视界\面经\八股git\mianshibagu\img\地址空间.png)

- 代码段：存放程序的二进制代码
- 字符串常量区：存放常量字符串
- 全局变量区：存放全局变量和静态变量
  初始的/未初始化的
- 堆：程序动态申请的内存，自低地址向搞地质生长
- 栈：操作系统自动维护的内存，自搞地址向低地址生长
- 最高的1G区域为内核使用

### 内核空间和用户空间是怎么区分的

32位机器，最高1G(0xC0000000-0xFFFFFFFF)给系统，低的3G(0x00000000-0xBFFFFFFF)给用户，64位的系统则是定义在头文件下`/arch/x86/include/asm/page_64_types.h`

#### 用户态和内核态

进程运行在用户空间就是用户态，进程运行在内核空间就是内核态

#### 为什么区分户态和内核态

CPU的一些指令是比较危险的，比如清内存，设置时钟，如果允许所有进程使用这些命令可能会让系统崩溃
系统将指令区分为`特权指令`和`非特权指令`，危险的指令允许操作系统相关模块使用。

Intel的CPU特权顶级为Ring0~Ring3
Linux和Windows只使用Ring0和Ring3

http://t.zoukankan.com/xingmuxin-p-10967548.html

> 关于访问其他进程的内存
>
> 在Ring3 是提供了两个API函数，`WriteProcessMemory`和`ReadProcessMemory`来读取其他进程的内存
> http://t.zoukankan.com/lanrenxinxin-p-4675015.html

### 异常和中断

中断：通常被定义为一个事件，改时间给变处理器执行的指令顺序（不区分中断和异常的说法）需要在内核态的堆在中保存程序计数器的当前值

区分中断和异常

* 中断 | 外中断 ：外部设备引起的事件产生的中断，
  比如自**I/O中断，时钟中断，硬件故障**

* 异常 | 内中断 ：由于CPU内部事件引起的中断，
  比如非法指令，地址越界，断点指令，页故障，**缺页中断**

异常分类：

  陷阱：有意义的异常

  故障：潜在恢复的错误

  终止：不可恢复的错误

* 异步中断 | 硬件中断 ：设备的IRQ请求

* 同步中断 | 软中断：I/O请求

中断处理过程

1. 保护现场。 在中断服务程序的起始部分安排若干条入栈指令，将各寄存器的内容压入堆栈保存。
2. 开中断。 在中断服务程序执行期间允许级别更高的中断请求中断现 行的中断服务程序，实现中断嵌套。
3. 中断服务。 完成中断源的具体要求。
4. 恢复现场。 中断服务程序结束前，必须恢复主程序的中断现场。通常是将保存在堆栈中的现场信息弹出到原来的寄存器中。
5. 中断返回。 返回到原程序的断点处，继续执行原程序。

### 栈空间的大小

进程栈是虚拟内存中的，可以一直向下生长，主要不超过虚拟内存的限制

线程栈Linux8M。Windows1M，程序测的好像是2M，实际上线程栈是从进程的地址控件中map出的一块地址空间，不能动态生长，在ulimit中做了限制

### 虚拟内存

每个进程的内存空间都有4G（32位机器为4G，64位在系统头文件中有限制）所以这些空间都是虚拟内存，它的地址都是逻辑地址，每次在访问的时候都需要映射成物理地址。

当进程访问某个逻辑地址的时候，会去查看页表，如果页表中没有相应的物理地址，说明内存中没有这页的数据，发生缺页异常，这时候进程需要把数据从磁盘拷贝到物理内存中。如果物理内存已经满了，就需要覆盖已有的页，如果这个页曾经被修改过，那么还要把它写回磁盘。

### 高并发解决方案

* 应用数据和静态资源分离
  静态资源（图片、视频、js、css等）单独保存到静态资源服务器中，客户端访问的时候从静态资源服务器中返回静态资源，从主服务器返回应用数据
* 客户端缓存
  网站页面进坑使用静态页面实现，页面过期或数据更新之后在将页面重新缓存。
* 集群和分布式
  集群所有服务器都有相同功能，请求哪台头可以，主要起分流作用
  分布式是将不同的业务放到不同的服务器中，处理一个请求需要使用多态服务器，起到加快请求处理的速度
  使用集群和分布式加厚，使原本一个服务器的计算压力分散到多个服务器上，加快请求处理速度。
* 反向代理
  访问服务器的时候，服务器通过背的服务器获取资源或结果返回给客户端

### 进程的状态以及转换图

三态模型

- 执行：正在执行
- 就绪：已经就绪分到时间片就可以执行
- 阻塞：有IO事件或者是等待其他资源

![](img\三态模型.png)

五态模型

- 新建态：进程刚刚创建
- 就绪态：
- 运行态：
- 等待态：
- 终止态：进程运行结束进入终止态

![](img\五态模型.png)

七态模型

- 新建态：
- 就绪态：
- 挂起就绪态：和就绪态互相转换，也可以以从新建态和运行态转换而来，挂起等待态事件结束后进入
- 运行态：
- 等待态：
- 挂起等待态：和等待态互相转换，等待时间结束变成挂起就绪
- 终止态：进程运行结束进入终止态



![](img\七态模型.png)

### 执行malloc申请内存的时候，操作系统是怎么做的？/内存的分配原理/malloc函数的底层实现/进程怎么分配内存

https://blog.csdn.net/yusiguyuan/article/details/39496057

从操作同层面看，`malloc`通过两个系统调用实现`brk`和`mmap`

> `brk`将进程的数据段(.data)的最高地址指针(_edate)向高处推，释放的中间区域的内存段是没有真正释放的，但是会互相连接，最高处超过128k后会释放，中间的没释放的空闲段会重新

> `mmap`是在虚拟地址空间中找一块空闲的虚拟内存，在堆和栈之间，释放的时候虚拟内存和物理内存一起释放

一般情况下小于128K用brk，大于128k用malloc，实际上分配内存只是分配了虚拟内存，用到第一次访问这些内存的时候会产生缺页中断

### 字节序

字节序是数据在内存中存储的方式，大端是高度有效位在前面，小端设计低的有效位在前面

判断方式使用union结构，